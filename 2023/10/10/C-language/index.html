<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Hexo
    </title>
    <meta name="description" content= 嘿，我是Mortal这是我的博客，用于记录自己的笔记。欢迎指正！ >
    <meta name="keywords" content= Blog,Hexo,Theme,Mortal >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            C language
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h1><p>有一个不常用的命名约定，即在名称前带c_或k_前缀来表示常量（如，c_level或k_line）。</p>
<h1 id="显示八进制和十六进制"><a href="#显示八进制和十六进制" class="headerlink" title="显示八进制和十六进制"></a>显示八进制和十六进制</h1><p>在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同的转换说明。以十进制显示数字，使用<code>%d</code>；以八进制显示数字，使用<code>%o</code>；以十六进制显示数字，使用<code>%x</code>。另外，要显示各进制数的前缀<code>0</code>、<code>0x</code>和<code>0X</code>必须分别使用<code>%#o</code>、<code>%#x</code>、<code>%#X</code>。，</p>
<h1 id="打印short、long、long-long和unsigned类型"><a href="#打印short、long、long-long和unsigned类型" class="headerlink" title="打印short、long、long long和unsigned类型"></a>打印short、long、long long和unsigned类型</h1><p>打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用<code>%ld</code>转换说明。如果系统中int和long的大小相同，使用<code>%d</code>就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，<code>%lx</code>表示以<code>十六进制格式打印long类型整数</code>，<code>%lo</code>表示以<code>八进制格式打印long类型整数</code>。</p>
<ul>
<li>注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。</li>
</ul>
<p>C语言有多种<code>printf()</code>格式。对于short类型，可以使用h前缀。<code>%hd</code>表示以<code>十进制显示short类型的整数</code>，<code>%ho</code>表示以<code>八进制显示short类型的整数</code>。h和l前缀都可以和u一起使用，用于表示无符号类型。例如，<code>%lu</code>表示打印<code>unsigned long类型</code>的值。</p>
<h1 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h1><p><code>scanf()</code>的输入形式，<code>scanf(&quot;%d&quot;,&amp;Alphabet)</code> 要先将<code>%d</code>包含以后才能使用<code>&amp;</code>进行传参。</p>
<h1 id="打印浮点数"><a href="#打印浮点数" class="headerlink" title="打印浮点数"></a>打印浮点数</h1><p>十六进制浮点数<br><code>printf(&quot;And it&#39;s %a in hexadecimal, powers of 2 notation\n&quot;,a boat);</code></p>
<h1 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h1><p><img src="/image/printf()%E8%BD%AC%E6%8D%A2%E6%A0%87%E5%87%86.png" alt="ANSI C标准 printf() 转换说明"></p>
<p><img src="/image/printf()%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" alt="printf()的修饰符"><br><strong>注意类型可移植性</strong></p>
<p><img src="/image/printf()%E4%B8%AD%E7%9A%84%E6%A0%87%E8%AE%B0.png" alt="printf()中的标记"></p>
<h1 id="scanf-1"><a href="#scanf-1" class="headerlink" title="scanf()"></a>scanf()</h1><p><img src="/image/scanf()%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E.png" alt="ANSI C中scanf()的转换说明"></p>
<p><img src="/image/scanf()%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6.png" alt="scanf()转换说明中的修饰符"><br><img src="/image/scanf()%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E%E4%B8%AD%E7%9A%84%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%BB%AD.png" alt="scanf()转换说明中的修饰符续"></p>
<ul>
<li><code>scanf()</code> 更像是获取单词的函数，而不是获取整个字符串的函数。</li>
<li>使用 <code>%s</code> 转换说明时，<code>scanf()</code> 会从第一个非空白字符开始，读取直到遇到下一个空白字符（空格、制表符、换行符等）为止。</li>
<li>如果指定了字段宽度，如 <code>%10s</code>，<code>scanf()</code> 将读取指定数量的字符或者在遇到第一个空白字符时停止（以先满足条件为准）。<br><img src="/image/%E5%AD%97%E6%AE%B5%E5%AE%BD%E5%BA%A6%E5%92%8Cscanf().png" alt="字段宽度和scanf()"></li>
</ul>
<p><code>scanf()</code>的典型用法是读取并转换混合数据类型为某种标准形式。<br>例如，如果输入行包含一种工具名、库存量和单价，就可以使用<code>scanf()</code>。</p>
<h1 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h1><p>从数值方面而不是从真&#x2F;假方面来看测试条件。要牢记：关系表达式为真，求值得1；关系表达式为假，求值得0。因此，这些表达式实际上相当于数值。<br>例如，用<code>while(goats)</code>替换<code>while (goats !=0)</code>，因为表达式<code>goats != 0</code>和<code>goats</code>都只有在goats的值为0时才为0或假。<br>第1种形式（while (goats !&#x3D; 0)）对初学者而言可能比较清楚，但是第2种形式（while (goats)）才是C程序员最常用的。</p>
<h1 id="比较常量"><a href="#比较常量" class="headerlink" title="比较常量"></a>比较常量</h1><p>如果待比较的一个值是常量，可以把该常量放在左侧有助于编译器捕获错误：<br>5 &#x3D; canoes   &lt;—— 语法错误<br>5 &#x3D;&#x3D; canoes  &lt;—— 检查canoes的值是否为5<br>可以这样做是因为C语言不允许给常量赋值，编译器会把赋值运算符的这种用法作为语法错误标记出来。许多经验丰富的程序员在构建比较是否相等的表达式时，都习惯把常量放在左侧。</p>
<h1 id="比较算数运算符优先级"><a href="#比较算数运算符优先级" class="headerlink" title="比较算数运算符优先级"></a>比较算数运算符优先级</h1><p><img src="/image/%E6%AF%94%E8%BE%83%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" alt="比较算数运算符优先级"></p>
<h1 id="ctype-h-头文件中的字符测试函数"><a href="#ctype-h-头文件中的字符测试函数" class="headerlink" title="ctype.h 头文件中的字符测试函数"></a>ctype.h 头文件中的字符测试函数</h1><p><img src="/image/ctype.%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0.png" alt=" ctype.h头文件中的字符测试函数"><br><img src="/image/ctype.h%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0.png" alt="ctype.h头文件中的字符映射函数"></p>
<h1 id="ctype-h"><a href="#ctype-h" class="headerlink" title="ctype.h"></a>ctype.h</h1><p><code>ctype.h</code>系列的字符函数（如，<code>issapce()</code>和<code>isalpha()</code>）为创建以分类字符为基础的测试表达式提供了便捷的工具。</p>
<h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符:  ?:"></a>条件运算符:  <code>?:</code></h1><p>expression1 ? expression2 : expression3</p>
<p>如果 expression1 为真（非 0），那么整个条件表达式的值与 expression2的值相同；如果expression1为假（0），那么整个条件表达式的值与expression3的值相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(5 &gt; 3) ? 1 : 2 值为1</span><br><span class="line">(3 &gt; 5) ? 1 : 2 值为2</span><br><span class="line">(a &gt; b) ? a : b 如果a &gt;b，则取较大的值</span><br></pre></td></tr></table></figure>

<h1 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h1><p>switch在圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式（即，表达式中只包含整型常量）。不能用变量作为case标签。<br>switch的构造如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch ( 整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句 &lt;--可选</span><br><span class="line">case 常量2:</span><br><span class="line">语句 &lt;--可选</span><br><span class="line">default : &lt;--可选</span><br><span class="line">语句 &lt;--可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h1><p>考虑下面的输入：<br><code>is 28 12.4</code><br>在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。但是对 C程序而言，这是一个字节流。第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while ((ch = getchar()) != &#x27;\n&#x27;)</span><br><span class="line">putchar(ch); // 处理错误的输入</span><br></pre></td></tr></table></figure>
<p>虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值。例如，考虑下面的输入：<br><code>42</code><br>如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中。如果使用%s转换说明，它会读取字符4和字符2这两个字符，并将其储存在字符数组中。如果使用%d转换说明，scanf()同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-1-ANSI-C要求在每个变量前都声明其类型"><a href="#1-1-ANSI-C要求在每个变量前都声明其类型" class="headerlink" title="1.1 ANSI C要求在每个变量前都声明其类型"></a>1.1 ANSI C要求在每个变量前都声明其类型</h2><p>不能像普通变量声明那样使用同一类型的变量列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dibs(int x, y, z) /* 无效的函数头 */</span><br><span class="line">void dubs(int x, int y, int z) /* 有效的函数头 */</span><br></pre></td></tr></table></figure>
<p>如果变量是同一类型，这种形式可以用逗号分隔变量名列表，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dibs(x, y, z)</span><br><span class="line">int x, y, z; /* 有效 */</span><br></pre></td></tr></table></figure>

<h2 id="1-2-使用函数前先声明"><a href="#1-2-使用函数前先声明" class="headerlink" title="1.2 使用函数前先声明"></a>1.2 使用函数前先声明</h2><p>在使用函数之前，要用ANSI C形式声明函数原型：<br><code>void show_n_char(char ch, int num);</code><br>当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，你也可以省略变量名：<br><code>void show_n_char(char, int);</code><br>在原型中使用变量名并没有实际创建变量，char仅代表了一个char类型的变量，以此类推。</p>
<h2 id="1-3-省略函数原型却保留函数原型的优点"><a href="#1-3-省略函数原型却保留函数原型的优点" class="headerlink" title="1.3 省略函数原型却保留函数原型的优点"></a>1.3 省略函数原型却保留函数原型的优点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 下面这行代码既是函数定义，也是函数原型</span><br><span class="line">int imax(int a, int b) &#123; return a &gt; b ? a : b; &#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int x, z;</span><br><span class="line">...</span><br><span class="line">z = imax(x, 50);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归的关键在于每个递归调用都会等待它的下一级递归完成，然后再继续执行后面的代码，最终实现整个递归的效果。</p>
<p>可以假设有一条函数调用链——fun1()调用fun2()、fun2()调用 fun3()、fun3()调用fun4()。当 fun4()结束时，控制传回<br>fun3()；当fun3()结束时，控制传回 fun2()；当fun2()结束时，控制传回fun1()。递归的情况与此类似，只不过fun1()、fun2()、fun3()和fun4()都是相同的函数。</p>
<h2 id="递归的基本原理"><a href="#递归的基本原理" class="headerlink" title="递归的基本原理"></a>递归的基本原理</h2><ol>
<li>每级函数调用都有自己的变量。也就是说，第1级的n和第2级的n不同，所以程序创建了4个单独的变量，每个变量名都是n，但是它们的值各<br>不相同。当程序最终返回 up_and_down()的第1 级调用时，最初的n仍然是它的初值1。<br><img src="/image/%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F.png" alt="递归中的变量"></li>
<li>每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某级up_and_down()返回<br>上一级的up_and_down()，不能跳级回到main()中的第1级调用。</li>
<li>递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。例如，程序清单9.6中的打印语句#1位于递归调用之前，它按照递归的<br>顺序：第1级、第2级、第3级和第4级，被执行了4次。</li>
<li>递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。例如，打印语句#2位于递归调用之后，其执行的顺序是第4级、第3<br>级、第2级、第1级。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。稍后将介绍一个这样的例子。</li>
<li>虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代<br>码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。</li>
<li>递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，<br>每次递归调用的形参都要使用不同的值。例如，程序中的up_and_down(n)调用up_and_down(n+1)。最终，实际参数等于4时，if的测试<br>条件(n &lt; 4)为假。</li>
</ol>
<h1 id="return"><a href="#return" class="headerlink" title="return"></a>return</h1><p>返回值不仅可以赋给变量，也可以被用作表达式的一部分。<br>返回值不一定是变量的值，也可以是任意表达式的值。<br><code>return (n &lt; m) ? n : m;</code></p>
<p><code>void variables(double *, double *, double *);</code></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。</p>
<p>整个数组的大小除以单个元素的大小就是数组元素的个数。</p>
<p>for (index &#x3D; 0; index &lt; sizeof days &#x2F; sizeof days[0]; index++)<br>sizeof days是整个数组的大小（以字节为单位），sizeof day[0]是数组中一个元素的大小（以字节为单位）。</p>
<p>只有在函数原型或函数定义头中，才可以用<code>int ar[]</code>代替<code>int * ar</code></p>
<p>由于函数原型可以省略参数名，所以下面4种原型都是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(int *ar, int n);</span><br><span class="line">int sum(int *, int);</span><br><span class="line">int sum(int ar[], int n);</span><br><span class="line">int sum(int [], int);</span><br></pre></td></tr></table></figure>
<p>但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum(int *ar, int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum(int ar[], int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字<code>const</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum(const int ar[], int n); /* 函数原型 */</span><br><span class="line">int sum(const int ar[], int n) /* 函数定义 */</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int total = 0;</span><br><span class="line">for( i = 0; i &lt; n; i++)</span><br><span class="line">total += ar[i];</span><br><span class="line">return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用const。</p>
<p><strong>复合字面量</strong></p>
<p>普通的数组声明：<code>int diva[2] = &#123;10, 20&#125;;</code><br>下面的复合字面量创建了一个和diva数组相同的匿名数组，也有两个int类型的值：<br><code>(int [2])&#123;10, 20&#125; // 复合字面量</code></p>
<ul>
<li>去掉声明中的数组名，留下的int [2]即是复合字面量的类型名<br><code>(int [])&#123;50, 20, 90&#125; // 内含3个元素的复合字面量</code><br>因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。<br>还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(const int ar[], int n);</span><br><span class="line">...</span><br><span class="line">int total3;</span><br><span class="line">total3 = sum((int [])&#123;4,4,4,5,5,5&#125;, 6);</span><br></pre></td></tr></table></figure>
第1个实参是内含6个int类型值的数组，和数组名类似，这同时也是该数组首元素的地址。这种用法的好处是，把信息传入函数前不必先创建<br>数组，这是复合字面量的典型用法。</li>
</ul>
<p>可以把这种用法应用于二维数组或多维数组。例如，下面的代码演示了如何创建二维int数组并储存其地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (*pt2)[4]; // 声明一个指向二维数组的指针，该数组内含2个数组元素，</span><br><span class="line">// 每个元素是内含4个int类型值的数组</span><br><span class="line">pt2 = (int [2][4]) &#123; &#123;1,2,3,-9&#125;, &#123;4,5,6,-8&#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>如上所示，该复合字面量的类型是<code>int [2][4]</code>，即一个2×4的int数组。</p>
<p><strong>变长数组</strong></p>
<p>C99引入了变长数组（Variable-Length Arrays，VLA），允许使用变量表示数组的维度。以下是一个使用变长数组的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int quarters = 4;</span><br><span class="line">int regions = 5;</span><br><span class="line">double sales[regions][quarters]; // 变长数组（VLA）</span><br></pre></td></tr></table></figure>
<p>变长数组的限制和特点：</p>
<ol>
<li><p>存储类别限制： 变长数组必须是自动存储类别，不能使用static或extern存储类别说明符。</p>
</li>
<li><p>初始化限制： 不能在声明中初始化变长数组。</p>
</li>
<li><p>可选特性： C11标准将变长数组作为可选特性，而不是必须强制实现的特性。</p>
</li>
<li><p>不能改变大小： 变长数组的”变”指的是在创建数组时可以使用变量指定数组的维度，而不是可以修改已创建数组的大小。一旦创建，数组的大小保持不变。</p>
</li>
</ol>
<p>计算二维数组元素之和的示例：<br>考虑一个函数 sum2d，计算int类型的二维数组所有元素之和。以下是该函数的声明和定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int sum2d(int rows, int cols, int ar[rows][cols]); // ar是一个变长数组（VLA）</span><br><span class="line"></span><br><span class="line">int sum2d(int rows, int cols, int ar[rows][cols])</span><br><span class="line">&#123;</span><br><span class="line">    int r;</span><br><span class="line">    int c;</span><br><span class="line">    int tot = 0;</span><br><span class="line"></span><br><span class="line">    for (r = 0; r &lt; rows; r++)</span><br><span class="line">        for (c = 0; c &lt; cols; c++)</span><br><span class="line">            tot += ar[r][c];</span><br><span class="line"></span><br><span class="line">    return tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数原型中，<code>ar</code> 是一个二维变长数组，使用了 <code>rows</code> 和 <code>cols</code> 作为两个维度。</li>
<li>函数定义中，使用了 <code>rows</code> 和 <code>cols</code> 来表示二维数组的大小，可以处理任意大小的二维int数组。<br><strong>注意：</strong> 形参列表中必须在声明 <code>ar</code> 之前先声明 <code>rows</code> 和 <code>cols</code>。</li>
</ul>
<p>此外，函数的定义也可以使用省略形参名的方式：<br><code>int sum2d(int, int, int ar[*][*]); // ar是一个变长数组（VLA），省略了维度形参名</code></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><strong>声明指针</strong></p>
<p>声明指针时需要需要带有变量，如果不想加变量则需要有<code>*</code></p>
<p>不要混淆 <code>*(dates+2)</code> 和<code>*dates+2</code> 。间接运算符（*）的优先级高于+，所以 <code>*dates+2</code> 相当于(*dates)+2：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(dates + 2) // dates第3个元素的值</span><br><span class="line"></span><br><span class="line">*dates + 2 // dates第1个元素的值加2</span><br></pre></td></tr></table></figure>

<p>一元运算符<code>*</code>和<code>++</code>的优先级相同，但结合律是从右往左，所以<code>start++</code>先求值，然后才是<code>*start</code>。也就是说，指针start先递增后指向。使用后缀形式（即<code>start++</code>而不是<code>++start</code>）如果使用<code>*++start</code>，顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使<code>(*start)++</code>，则先使用start指向的值，再递增该值，而不是递增指针。这样，指针将一直指向同一个位置，但是该位置上的值发生了变化。虽然<code>*start++</code>的写法比较常用，但是<code>*(start++)</code>这样写更清楚。</p>
<p><strong>当涉及到 <code>const</code> 修饰符和指针时，有几个要点需要注意：</strong></p>
<ul>
<li><p><code>const </code>修饰指针所指向的数据，表示指针所指向的数据不能通过这个指针进行修改。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const double *pd = rates; // pd指向数组的首元素</span><br><span class="line">*pd = 29.89; // 不允许修改</span><br><span class="line">pd[2] = 222.22; // 不允许修改</span><br><span class="line">rates[0] = 99.99; // 允许修改，因为rates未被const限定</span><br></pre></td></tr></table></figure></li>
<li><p>指向 <code>const</code> 的指针 (<code>const double *pc</code>) 可以指向非 <code>const</code> 的数据，但不能通过这个指针修改所指向的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double *pc = rates; // 有效</span><br><span class="line">pc = &amp;rates[3]; // 有效</span><br><span class="line">*pc = 92.99; // 不允许修改</span><br></pre></td></tr></table></figure></li>
<li><p>指向非 <code>const</code> 的指针（<code>double *pnc</code>）可以指向 <code>const</code> 数据，但也不能通过这个指针修改所指向的 const 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double locked[4] = &#123;0.08, 0.075, 0.0725, 0.07&#125;;</span><br><span class="line">double *pnc = rates; // 有效</span><br><span class="line">pnc = &amp;rates[3]; // 有效</span><br><span class="line">pnc = locked; // 不允许</span><br></pre></td></tr></table></figure></li>
<li><p><code>const</code> 可以用于指向数组的指针，保护数组数据不被修改：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double *pc = rates; // 指向数组的首元素</span><br><span class="line">show_array(rates, 5); // 有效，数组名转换成指向 const 的指针</span><br><span class="line">show_array(locked, 4); // 有效，数组名转换成指向 const 的指针</span><br></pre></td></tr></table></figure></li>
<li><p><code>const</code> 还可以用于创建常量指针，该指针一旦指向一个地址，就不能再指向别处：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">double * const pc = rates; // pc指向数组的开始</span><br><span class="line">pc = &amp;rates[2]; // 不允许，因为该指针不能指向别处</span><br><span class="line">*pc = 92.99; // 允许修改 rates[0] 的值</span><br></pre></td></tr></table></figure></li>
<li><p><code>const</code> 也可以用于创建既不能更改所指向地址，也不能修改指向地址上的值的指针：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double * const pc = rates; // 不能修改指向的地址，也不能修改地址上的值</span><br><span class="line">pc = &amp;rates[2]; // 不允许</span><br><span class="line">*pc = 92.99; // 不允许</span><br></pre></td></tr></table></figure>

</li>
<li><p>演示程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* order.c -- 指针运算中的优先级 */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int data[2] = &#123; 100, 200 &#125;;</span><br><span class="line">int moredata[2] = &#123; 300, 400 &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int * p1, *p2, *p3;</span><br><span class="line">    p1 = p2 = data;</span><br><span class="line">    p3 = moredata;</span><br><span class="line">    printf(&quot;*p1 = %d, *p2 = %d, *p3 = %d\n&quot;, *p1, *p2, *p3);</span><br><span class="line">    printf(&quot;*p1++=%d, *++p2=%d, (*p3)++=%d\n&quot;, *p1++, *++p2, (*p3)++);</span><br><span class="line">    printf(&quot;*p1 = %d, *p2 = %d, *p3 = %d\n&quot;, *p1, *p2, *p3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>该程序输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p1 = 100, *p2 = 100, *p3 = 300</span><br><span class="line">*p1++=100, *++p2=200, (*p3)++=300</span><br><span class="line">*p1 = 200, *p2 = 200, *p3 = 301</span><br></pre></td></tr></table></figure>
<p>只有(*p3)++改变了数组元素的值，其他两个操作分别把p1和p2指向数组的下一个元素。</p>
</li>
</ul>
<h2 id="字符串声明比较"><a href="#字符串声明比较" class="headerlink" title="字符串声明比较"></a>字符串声明比较</h2><p>两种声明几乎相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *pt1 = &quot;Something is pointing at me;&quot;;</span><br><span class="line">const char ar1[] = &quot;Something is pointing at me;&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="数组形式（ar1-）"><a href="#数组形式（ar1-）" class="headerlink" title="数组形式（ar1[]）"></a>数组形式（ar1[]）</h3><ul>
<li>在内存中分配一个内含29个元素的数组，每个元素对应一个字符，还有一个末尾的空字符’\0’。</li>
<li>字符串作为可执行文件的一部分储存在数据段中，静态存储区。</li>
<li>程序开始运行时为数组分配内存，将字符串拷贝到数组中，此时有两个副本：一个在静态内存中，一个在数组中。</li>
<li>数组名ar1是该数组首元素地址的别名，是地址常量，不能更改。可以进行<code>ar1+1</code>等操作，但不允许进行<code>++ar1</code>这样的操作。</li>
</ul>
<h3 id="指针形式（-pt1）"><a href="#指针形式（-pt1）" class="headerlink" title="指针形式（*pt1）"></a>指针形式（*pt1）</h3><ul>
<li>编译器为字符串在静态存储区预留29个元素的空间，并为指针变量pt1留出一个储存位置，将字符串的地址储存在指针变量中。</li>
<li>指针形式只拷贝字符串的地址给指针，不会拷贝字符串本身。指针可以改变指向的位置，可以使用递增运算符。</li>
<li>字符串字面量被视为const数据，因此指针pt1需要声明为指向const数据的指针，不能通过pt1改变所指向的数据。</li>
</ul>
<p><strong>总结：初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。</strong></p>
<h3 id="空字符与空指针的区别"><a href="#空字符与空指针的区别" class="headerlink" title="空字符与空指针的区别"></a>空字符与空指针的区别</h3><ul>
<li><p><strong>空字符 (‘\0’)：</strong></p>
<ul>
<li>用于标记C字符串的末尾。</li>
<li>对应字符编码是0。</li>
<li>在字符串中不可能是其他字符的一部分。</li>
<li>是整数类型，占1字节。</li>
</ul>
</li>
<li><p><strong>空指针 (NULL)：</strong></p>
<ul>
<li>有一个值，该值不会与任何数据的有效地址对应。</li>
<li>通常用于表示特殊情况，例如遇到文件结尾或未能按预期执行。</li>
<li>是指针类型，占4字节（通常）。</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong><br>虽然它们可以用数值0来表示，但从概念上看，空字符和空指针是不同类型的0。</p>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul>
<li><strong>请注意，那些使用const关键字的函数原型表明，函数不会更改字符串。</strong></li>
</ul>
<p><code>char *strcpy(char * restrict s1, const char * restrict s2);</code><br>该函数把s2指向的字符串（包括空字符）拷贝至s1指向的位置，返回值是s1。</p>
<p><code>char *strncpy(char * restrict s1, const char * restrict s2, size_t n);</code><br>该函数把s2指向的字符串拷贝至s1指向的位置，拷贝的字符数不超过n，其返回值是s1。该函数不会拷贝空字符后面的字符，如果源字符串的字符少于n个，目标字符串就以拷贝的空字符结尾；如果源字符串有n个或超过n个字符，就不拷贝空字符。</p>
<p><code>char *strcat(char * restrict s1, const char * restrict s2);</code><br>该函数把s2指向的字符串拷贝至s1指向的字符串末尾。s2字符串的第1个字符将覆盖s1字符串末尾的空字符。该函数返回s1。</p>
<p><code>char *strncat(char * restrict s1, const char * restrict s2, size_t n);</code><br>该函数把s2字符串中的n个字符拷贝至s1字符串末尾。s2字符串的第1个字符将覆盖s1字符串末尾的空字符。不会拷贝s2字符串中空字符和其后的字符，并在拷贝字符的末尾添加一个空字符。该函数返回s1。</p>
<p><code>int strcmp(const char * s1, const char * s2);</code><br>如果s1字符串在机器排序序列中位于s2字符串的后面，该函数返回一个正数；如果两个字符串相等，则返回0；如果s1字符串在机器排序序列中位于s2字符串的前面，则返回一个负数。</p>
<p><code>int strncmp(const char * s1, const char * s2, size_t n);</code><br>该函数的作用和strcmp()类似，不同的是，该函数在比较n个字符后或遇到第1个空字符时停止比较。</p>
<p><code>char *strchr(const char * s, int c);</code><br>如果s字符串中包含c字符，该函数返回指向s字符串首位置的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串s中未找到c字符，该函数则返回空指针。</p>
<p><code>char *strpbrk(const char * s1, const char * s2);</code><br>如果 s1 字符中包含 s2 字符串中的任意字符，该函数返回指向 s1 字符串首位置的指针；如果在s1字符串中未找到任何s2字符串中的字符，则返回空字符。</p>
<p><code>char *strrchr(const char * s, int c);</code><br>该函数返回s字符串中c字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如果未找到c字符，则返回空指针。</p>
<p><code>char *strstr(const char * s1, const char * s2);</code><br>该函数返回指向s1字符串中s2字符串出现的首位置。如果在s1中没有找到s2，则返回空指针。</p>
<p><code>size_t strlen(const char * s);</code><br>该函数返回s字符串中的字符数，不包括末尾的空字符。</p>
<h2 id="s-gets"><a href="#s-gets" class="headerlink" title="s_gets()"></a>s_gets()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char * s_get(char * st, int n)</span><br><span class="line">&#123;</span><br><span class="line">char * ret_val;</span><br><span class="line">ret_val = fgets(st, n, stdin);</span><br><span class="line">if (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">while (*st != &#x27;\n&#x27; &amp;&amp; *st != &#x27;\0&#x27;)</span><br><span class="line">st++;</span><br><span class="line">if (*st == &#x27;\n&#x27;)</span><br><span class="line">*st = &#x27;\0&#x27;;</span><br><span class="line">else</span><br><span class="line">while (getchar() != &#x27;\n&#x27;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">return ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;        // 提供 fgets()和getchar()的原型</span><br><span class="line">#include &lt;string.h&gt;       // 提供 strchr()的原型</span><br><span class="line">char * s_gets(char * st, int n)</span><br><span class="line">&#123;</span><br><span class="line">char * ret_val;</span><br><span class="line">char * find;</span><br><span class="line">ret_val = fgets(st, n, stdin);</span><br><span class="line">if (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">find = strchr(st,  &#x27;\n&#x27;);</span><br><span class="line">if (find)		      // 如果地址不是 NULL,</span><br><span class="line">*find = &#x27;\0&#x27;;	    // 在此处放置一个空字符</span><br><span class="line">else</span><br><span class="line">while (getchar() != &#x27;\0&#x27;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">return ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="内存分配：malloc-和-free"><a href="#内存分配：malloc-和-free" class="headerlink" title="内存分配：malloc() 和 free()"></a>内存分配：malloc() 和 free()</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>malloc()函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说， malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。malloc()函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。如果 malloc()分配内存失败，将返回空指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double * ptd;</span><br><span class="line"></span><br><span class="line">ptd = (double *) malloc(30 * sizeof(double));</span><br></pre></td></tr></table></figure>

<p>以上代码为30个double类型的值请求内存空间，并设置ptd指向该位置。<br>注意，指针ptd被声明为指向一个double类型，而不是指向内含30个double类型值的块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double item[n];</span><br><span class="line"></span><br><span class="line">ptd = (double *) malloc(n * sizeof(double));</span><br></pre></td></tr></table></figure>

<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存<br>数量只会增加，除非用 free()进行释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">double glad[2000];</span><br><span class="line">int i;</span><br><span class="line">...</span><br><span class="line">for (i = 0; i &lt; 1000; i++)</span><br><span class="line">gobble(glad, 2000);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">void gobble(double ar[], int n)</span><br><span class="line">&#123;</span><br><span class="line">double * temp = (double *) malloc( n * sizeof(double));</span><br><span class="line">.../* free(temp); // 假设忘记使用free() */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long * newmem;</span><br><span class="line"></span><br><span class="line">newmem = (long *)calloc(100, sizeof (long));</span><br></pre></td></tr></table></figure>

<p>和malloc()类似，返回指向void的指针。如果要储存不同的类型，应使用强制类型转换运算符。</p>
<p>calloc()函数还有一个特性：它把块中的所有位都设置为0（注意，在某些硬件系统中，不是把所有位都设置为0来表示浮点值0）。</p>
<p>free()函数也可用于释放calloc()分配的内存。</p>
<h3 id="动态内存分配和变长数组"><a href="#动态内存分配和变长数组" class="headerlink" title="动态内存分配和变长数组"></a>动态内存分配和变长数组</h3><p>对多维数组而言，使用变长数组更方便。当然，也可以用 <code>malloc()</code> 创建二维数组，但是语法比较繁琐。如果编译器不支持变长数组特性，就只能固<br>定二维数组的维度，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n = 5;</span><br><span class="line">int m = 6;</span><br><span class="line">int ar2[n][m]; // n×m的变长数组（VLA）</span><br><span class="line">int (* p2)[6]; // C99之前的写法</span><br><span class="line">int (* p3)[m]; // 要求支持变长数组</span><br><span class="line">p2 = (int (*)[6]) malloc(n * 6 * sizeof(int)); // n×6 数组</span><br><span class="line">p3 = (int (*)[m]) malloc(n * m * sizeof(int)); // n×m 数组（要求支持变长数组）</span><br><span class="line">ar2[1][2] = p2[1][2] = 12;</span><br></pre></td></tr></table></figure>

<p>先复习一下指针声明。由于malloc()函数返回一个指针，所以p2必须是一个指向合适类型的指针。第1个指针声明：<br><code>int (* p2)[6]; // C99之前的写法</code></p>
<p>表明p2指向一个内含6个int类型值的数组。因此，<code>p2[i]</code>代表一个由6个整数构成的元素，<code>p2[i][j]</code>代表一个整数。<br>第2个指针声明用一个变量指定p3所指向数组的大小。因此，p3代表一个指向变长数组的指针，这行代码不能在C90标准中运行。</p>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h2><p><img src="/image/fopen().png" alt="fopen()的模式字符串"></p>
<h2 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h2><p>为了避免读到空文件，应该使用入口条件循环（不是do while循环）。鉴于getc() （和其他C输入函数）的设计，程序应该在进入循环体之前先尝试读取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 设计范例 #1</span><br><span class="line">int ch; // 用int类型的变量储存EOF</span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(&quot;wacky.txt&quot;, &quot;r&quot;);</span><br><span class="line">ch = getc(fp); // 获取初始输入</span><br><span class="line">while (ch != EOF)</span><br><span class="line">&#123;</span><br><span class="line">putchar(ch); // 处理输入</span><br><span class="line">ch = getc(fp); // 获取下一个输入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码可简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 设计范例 #2</span><br><span class="line">int ch;</span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(&quot;wacky.txt&quot;, &quot;r&quot;);</span><br><span class="line">while (( ch = getc(fp)) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">putchar(ch); //处理输入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h2><p><img src="/image/%E6%96%87%E4%BB%B6%E7%9A%84%E8%B5%B7%E5%A7%8B%E7%82%B9%E6%A8%A1%E5%BC%8F.png" alt="文件的起始点模式"></p>
<p>fseek()的第1个参数是FILE指针，指向待查找的文件，fopen()应该已打开该文件。<br>fseek()的第2个参数是偏移量（offset）。该参数表示从起始点开始要移动的距离（参见表列出的起始点模式）。该参数必须是一个long类型的值，可以为正（前移）、负（后移）或0（保持不动）。<br>fseek()的第3个参数是模式，该参数确定起始点。</p>
<p>下面是调用fseek()函数的一些示例，fp是一个文件指针：<br>fseek(fp, 0L, SEEK_SET); &#x2F;&#x2F; 定位至文件开始处<br>fseek(fp, 10L, SEEK_SET); &#x2F;&#x2F; 定位至文件中的第10个字节<br>fseek(fp, 2L, SEEK_CUR); &#x2F;&#x2F; 从文件当前位置前移2个字节<br>fseek(fp, 0L, SEEK_END); &#x2F;&#x2F; 定位至文件结尾<br>fseek(fp, -10L, SEEK_END); &#x2F;&#x2F; 从文件结尾处回退10个字节</p>
<p><img src="/image/%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F%E8%B0%83%E7%94%A8.png" alt="文本模式调用.png"></p>
<h2 id="指针访问结构成员"><a href="#指针访问结构成员" class="headerlink" title="指针访问结构成员"></a>指针访问结构成员</h2><p>如果<code>him == &amp;fellow[0]</code>，那么<code>*him == fellow[0]</code>，因为<code>&amp;</code>和<code>*</code>是一对互逆运算符。<br>因此，可以做以下替代：<br><code>fellow[0].income == (*him).income</code><br>必须要使用圆括号，因为<code>.</code>运算符比<code>*</code>运算符的优先级高。<br>总之，如果<code>him</code>是指向<code>guy</code>类型结构<code>barney</code>的指针，下面的关系恒成立：<br><code>barney.income == (*him).income == him-&gt;income // 假设 him == &amp;barney</code></p>
<h2 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h2><p>移位运算符针对2的幂提供快速有效的乘法和除法：</p>
<p><code>number &lt;&lt; n</code>     number 乘以2的n次幂<br><code>number &gt;&gt; n</code>     如果number为非负，则用number除以2的n次幂</p>
<p>这些移位运算符类似于在十进制中移动小数点来乘以或除以10。</p>
<h2 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h2><p>因为ASCII码只使用最后7位，所以有时需要用掩码关闭其他位，其相应的二进制掩码是什么？分别用十进制、八进制和十六进制来表示这个掩码。</p>
<p>掩码的二进制是<code>1111111</code>；十进制是<code>127</code>；八进制是<code>0177</code>；十六进制是<code>0x7F</code>。</p>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p><code>#ifdef</code> 判断是否定义了标识符。如果定义了则执行<code>#else</code>或<code>#endif</code>指令之前的所有指令并编译所有C代码，如果未定义则执行<code>#else</code>和<code>#endif</code>指令之间的所有代码。</p>
<p><code>#ifndef</code> 判断后面的标识符是否是未定义的。通常用于防止多次包含一个文件。</p>
<p><code>#if</code>指令很像C语言中的<code>if</code>。<code>#if</code>后面跟整型常量表达式，如果表达式为非零，则表达式为真。<br>可以按照if else的形式使用<code>#elif</code>。<br>较新的编译器提供另一种方法测试名称是否已定义，即用<code>#if defined(VAX)</code>代替<code>#ifdef VAX</code>。<br>这里，defined是一个预处理运算符，如果它的参数是用<code>#defined</code>定义过，则返回<code>1</code>；否则返回<code>0</code>。这种新方法的优点是，它可以和<code>#elif</code>一起使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if defined (IBMPC)</span><br><span class="line">#include &quot;ibmpc.h&quot;</span><br><span class="line">#elif defined (VAX)</span><br><span class="line">#include &quot;vax.h&quot;</span><br><span class="line">#elif defined (MAC)</span><br><span class="line">#include &quot;mac.h&quot;</span><br><span class="line">#else</span><br><span class="line">#include &quot;general.h&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>如果在VAX机上运行这几行代码，那么应该在文件前面用下面的代码定义VAX：<br><code>#define VAX</code></p>
<h2 id="在-define-中使用参数"><a href="#在-define-中使用参数" class="headerlink" title="在 #define 中使用参数"></a>在 <code>#define</code> 中使用参数</h2><p>在#define中使用参数可以创建外形和作用与函数类似的类函数宏。带有参数的宏看上去很像函数，因为这样的宏也使用圆括号。类函数宏定义的圆括号中可以有一个或多个参数，随后这些参数出现在替换体中。</p>
<p><img src="/image/%E5%87%BD%E6%95%B0%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%84%E6%88%90.png" alt="函数宏定义的组成"></p>
<ul>
<li><code>#define SQUARE(X) X*X</code></li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="#运算符"></a><code>#运算符</code></h3><p>下面是一个类函数宏：<br><code>#define PSQR(X) printf(&quot;The square of X is %d.\n&quot;, ((X)*(X)));</code><br>假设这样使用宏：<br><code>PSQR(8);</code><br>输出为：<br><code>The square of X is 64.</code><br>C允许在字符串中包含宏参数。在类函数宏的替换体中，<code>#</code>号作为一个预处理运算符，可以把记号转换成字符串。例如，如果<code>x</code>是一个宏形参，那么<code>#x</code>就是转换为字符串”x”的形参名。这个过程称为字符串化（stringizing）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* subst.c -- 在字符串中替换 */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define PSQR(x) printf(&quot;The square of &quot; #x &quot; is %d.\n&quot;,((x)*(x)))</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int y = 5;</span><br><span class="line">PSQR(y);</span><br><span class="line">PSQR(2 + 4);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">该程序的输出如下：</span><br><span class="line">The square of y is 25.</span><br><span class="line">The square of 2 + 4 is 36.</span><br></pre></td></tr></table></figure>
<p>调用第1个宏时，用”<code>y</code>“替换#x。调用第2个宏时，用”<code>2 + 4</code>“替换<code>#x</code>。ANSI C字符串的串联特性将这些字符串与printf()语句的其他字符串组合，生成最终的字符串。</p>
<h3 id="预处理器粘合剂：-运算符"><a href="#预处理器粘合剂：-运算符" class="headerlink" title="预处理器粘合剂：##运算符"></a>预处理器粘合剂：<code>##运算符</code></h3><p>与<code>#</code>运算符类似，<code>##</code>运算符可用于类函数宏的替换部分。而且，<code>##</code>还可用于对象宏的替换部分。<code>##</code>运算符把两个记号组合成一个记号。例如，可以这样做：<br><code>#define XNAME(n) x ## n</code><br>然后，宏<code>XNAME(4)</code>将展开为<code>x4</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// glue.c -- 使用##运算符</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define XNAME(n) x ## n</span><br><span class="line">#define PRINT_XN(n) printf(&quot;x&quot; #n &quot; = %d\n&quot;, x ## n);</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int XNAME(1) = 14; // 变成 int x1 = 14;</span><br><span class="line">int XNAME(2) = 20; // 变成 int x2 = 20;</span><br><span class="line">int x3 = 30;</span><br><span class="line">1212</span><br><span class="line">PRINT_XN(1); // 变成 printf(&quot;x1 = %d\n&quot;, x1);</span><br><span class="line">PRINT_XN(2); // 变成 printf(&quot;x2 = %d\n&quot;, x2);</span><br><span class="line">PRINT_XN(3); // 变成 printf(&quot;x3 = %d\n&quot;, x3);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">该程序的输出如下：</span><br><span class="line">x1 = 14</span><br><span class="line">x2 = 20</span><br><span class="line">x3 = 30</span><br></pre></td></tr></table></figure>
<ul>
<li>注意，PRINT_XN()宏用#运算符组合字符串，##运算符把记号组合为一个新的标识符。</li>
</ul>
<h3 id="变参宏：-和-VA-ARGS"><a href="#变参宏：-和-VA-ARGS" class="headerlink" title="变参宏： ...和__VA_ARGS__"></a>变参宏： <code>...</code>和<code>__VA_ARGS__</code></h3><p><code>stdvar.h</code> 头文件提供了工具，让用户自定义带可变参数的函数。<br>通过把宏参数列表中最后的参数写成省略号（即，3个点…）来实现这一功能。这样，预定义宏<code>_ _VA_ARGS_ </code>_可用在替换部分中，表明省略号代表什么。例如，下面的定义：<br><code>#define PR(...) printf(_ _VA_ARGS_ _)</code><br>假设稍后调用该宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PR(&quot;Howdy&quot;);</span><br><span class="line">PR(&quot;weight = %d, shipping = $%.2f\n&quot;, wt, sp);</span><br><span class="line">对于第1次调用，_ _VA_ARGS_ _展开为1个参数：&quot;Howdy&quot;。</span><br><span class="line">对于第2次调用，_ _VA_ARGS_ _展开为3个参数：&quot;weight = %d,</span><br><span class="line">shipping = $%.2f\n&quot;、wt、sp。</span><br></pre></td></tr></table></figure>
<p>因此，展开后的代码是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Howdy&quot;);</span><br><span class="line">printf(&quot;weight = %d, shipping = $%.2f\n&quot;, wt, sp);</span><br></pre></td></tr></table></figure>

<h3 id="宏和函数的选择"><a href="#宏和函数的选择" class="headerlink" title="宏和函数的选择"></a>宏和函数的选择</h3><p>宏的一个优点是，不用担心变量类型（这是因为宏处理的是字符串，而不是实际的值）。<br>对于简单的函数，程序员通常使用宏，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(X,Y) ((X) &gt; (Y) ? (X) : (Y))</span><br><span class="line">#define ABS(X) ((X) &lt; 0 ? -(X) : (X))</span><br><span class="line">#define ISSIGN(X) ((X) == &#x27;+&#x27; || (X) == &#x27;-&#x27; ? 1 : 0)</span><br></pre></td></tr></table></figure>
<p>（如果x是一个代数符号字符，最后一个宏的值为1，即为真。）<br>用圆括号把宏的参数和整个替换体括起来。这样能确保被括起来的部分在下面这样的表达式中正确地展开：<br><code>forks = 2 * MAX(guests + 3, last);</code><br>用大写字母表示宏函数的名称。</p>
<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><p><img src="/image/%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F.png" alt="预定义宏"></p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>最简单的方法是使用函数说明符 <code>inline</code> 和存储类别说明符<code>static</code>。通常，内联函数应定义在首次使用它的文件中，所以内联函数也相当于函数原型。<br>编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定义与函数调用必须在同一个文件中。最简单的做法是，把内联函数定义放入头文件，并在使用该内联函数的文件中包含该头文件即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// eatline.h</span><br><span class="line">#ifndef EATLINE_H_</span><br><span class="line">#define EATLINE_H_</span><br><span class="line">inline static void eatline()</span><br><span class="line">&#123;</span><br><span class="line">while (getchar() != &#x27;\n&#x27;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>一般都不在头文件中放置可执行代码，内联函数是个特例。因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题。</p>
<h2 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h2><p><img src="/image/%E6%95%B0%E5%AD%A6%E5%BA%93.png" alt="数学函数"></p>
<h2 id="可变参数：stdarg-h"><a href="#可变参数：stdarg-h" class="headerlink" title="可变参数：stdarg.h"></a>可变参数：<code>stdarg.h</code></h2><p>必须按如下步骤进行：</p>
<ol>
<li>提供一个使用省略号的函数原型；</li>
<li>在函数定义中创建一个va_list类型的变量；</li>
<li>用宏把该变量初始化为一个参数列表；</li>
<li>用宏访问参数列表；</li>
<li>用宏完成清理工作。</li>
</ol>
<p>因为<code>va_arg()</code>不提供退回之前参数的方法，所以有必要保存<code>va_list</code>类型变量的副本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;                 // 声明一个对象储存参数</span><br><span class="line">va_list apcopy;             // 声明一个复制对象储存参数</span><br><span class="line">double</span><br><span class="line">double tic;</span><br><span class="line">int toc;</span><br><span class="line">...</span><br><span class="line">va_start(ap, lim);          // 把ap初始化为一个参数列表</span><br><span class="line">va_copy(apcopy, ap);        // 把apcopy作为ap的副本</span><br><span class="line">tic = va_arg(ap, double);   // 检索第1个参数</span><br><span class="line">toc = va_arg(ap, int);      // 检索第2个参数</span><br><span class="line">va_end(ap);                 // 清理工作</span><br></pre></td></tr></table></figure>
    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: Mortal | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
