<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"allofmortal.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="常量命名有一个不常用的命名约定，即在名称前带c或k前缀来表示常量（如，c_level或k_line）。 显示八进制和十六进制在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同的转换说明。以十进制显示数字，使用%d；以八进制显示数字，使用%o；以十六进制显示数字，使用%x。另外，要显示各进制数的前缀0、0x和0X必须分别使用%#o、%#x、%#X。， 打印short、long、long">
<meta property="og:type" content="article">
<meta property="og:title" content="C language">
<meta property="og:url" content="https://allofmortal.github.io/2023/10/10/C-language/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="常量命名有一个不常用的命名约定，即在名称前带c或k前缀来表示常量（如，c_level或k_line）。 显示八进制和十六进制在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同的转换说明。以十进制显示数字，使用%d；以八进制显示数字，使用%o；以十六进制显示数字，使用%x。另外，要显示各进制数的前缀0、0x和0X必须分别使用%#o、%#x、%#X。， 打印short、long、long">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://allofmortal.github.io/image/printf(">
<meta property="og:image" content="https://allofmortal.github.io/image/printf(">
<meta property="og:image" content="https://allofmortal.github.io/image/printf(">
<meta property="og:image" content="https://allofmortal.github.io/image/scanf(">
<meta property="og:image" content="https://allofmortal.github.io/image/scanf(">
<meta property="og:image" content="https://allofmortal.github.io/image/scanf(">
<meta property="og:image" content="https://allofmortal.github.io/image/%E5%AD%97%E6%AE%B5%E5%AE%BD%E5%BA%A6%E5%92%8Cscanf(">
<meta property="og:image" content="https://allofmortal.github.io/image/%E6%AF%94%E8%BE%83%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png">
<meta property="og:image" content="https://allofmortal.github.io/image/ctype.%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0.png">
<meta property="og:image" content="https://allofmortal.github.io/image/ctype.h%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%98%A0%E5%B0%84%E5%87%BD%E6%95%B0.png">
<meta property="og:image" content="https://allofmortal.github.io/image/%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F.png">
<meta property="og:image" content="https://allofmortal.github.io/image/fopen(">
<meta property="og:image" content="https://allofmortal.github.io/image/%E6%96%87%E4%BB%B6%E7%9A%84%E8%B5%B7%E5%A7%8B%E7%82%B9%E6%A8%A1%E5%BC%8F.png">
<meta property="og:image" content="https://allofmortal.github.io/image/%E6%96%87%E6%9C%AC%E6%A8%A1%E5%BC%8F%E8%B0%83%E7%94%A8.png">
<meta property="og:image" content="https://allofmortal.github.io/image/%E5%87%BD%E6%95%B0%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E7%BB%84%E6%88%90.png">
<meta property="og:image" content="https://allofmortal.github.io/image/%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F.png">
<meta property="og:image" content="https://allofmortal.github.io/image/%E6%95%B0%E5%AD%A6%E5%BA%93.png">
<meta property="article:published_time" content="2023-10-10T07:45:41.000Z">
<meta property="article:modified_time" content="2024-04-28T01:43:55.464Z">
<meta property="article:author" content="Mortal">
<meta property="article:tag" content="language">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://allofmortal.github.io/image/printf(">

<link rel="canonical" href="https://allofmortal.github.io/2023/10/10/C-language/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-cn'
  };
</script>

  <title>C language | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Navigationsleiste an/ausschalten">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Startseite</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>Über</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Schlagwörter<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Kategorien<span class="badge">15</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archiv<span class="badge">28</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-cn">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2023/10/10/C-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C language
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Veröffentlicht am</span>

              <time title="Erstellt: 2023-10-10 15:45:41" itemprop="dateCreated datePublished" datetime="2023-10-10T15:45:41+08:00">2023-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Bearbeitet am</span>
                <time title="Geändert am: 2024-04-28 09:43:55" itemprop="dateModified" datetime="2024-04-28T09:43:55+08:00">2024-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h1><p>有一个不常用的命名约定，即在名称前带c<em>或k</em>前缀来表示常量（如，c_level或k_line）。</p>
<h1 id="显示八进制和十六进制"><a href="#显示八进制和十六进制" class="headerlink" title="显示八进制和十六进制"></a>显示八进制和十六进制</h1><p>在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同的转换说明。以十进制显示数字，使用<code>%d</code>；以八进制显示数字，使用<code>%o</code>；以十六进制显示数字，使用<code>%x</code>。另外，要显示各进制数的前缀<code>0</code>、<code>0x</code>和<code>0X</code>必须分别使用<code>%#o</code>、<code>%#x</code>、<code>%#X</code>。，</p>
<h1 id="打印short、long、long-long和unsigned类型"><a href="#打印short、long、long-long和unsigned类型" class="headerlink" title="打印short、long、long long和unsigned类型"></a>打印short、long、long long和unsigned类型</h1><p>打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用<code>%ld</code>转换说明。如果系统中int和long的大小相同，使用<code>%d</code>就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，<code>%lx</code>表示以<code>十六进制格式打印long类型整数</code>，<code>%lo</code>表示以<code>八进制格式打印long类型整数</code>。</p>
<ul>
<li>注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。</li>
</ul>
<p>C语言有多种<code>printf()</code>格式。对于short类型，可以使用h前缀。<code>%hd</code>表示以<code>十进制显示short类型的整数</code>，<code>%ho</code>表示以<code>八进制显示short类型的整数</code>。h和l前缀都可以和u一起使用，用于表示无符号类型。例如，<code>%lu</code>表示打印<code>unsigned long类型</code>的值。</p>
<h1 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h1><p><code>scanf()</code>的输入形式，<code>scanf(&quot;%d&quot;,&amp;Alphabet)</code> 要先将<code>%d</code>包含以后才能使用<code>&amp;</code>进行传参。</p>
<h1 id="打印浮点数"><a href="#打印浮点数" class="headerlink" title="打印浮点数"></a>打印浮点数</h1><p>十六进制浮点数<br><code>printf(&quot;And it&#39;s %a in hexadecimal, powers of 2 notation\n&quot;,a boat);</code></p>
<h1 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h1><p><img src="/image/printf(" alt="ANSI C标准 printf() 转换说明">转换标准.png)</p>
<p><img src="/image/printf(" alt="printf()的修饰符">的修饰符.png)<br><strong>注意类型可移植性</strong></p>
<p><img src="/image/printf(" alt="printf()中的标记">中的标记.png)</p>
<h1 id="scanf-1"><a href="#scanf-1" class="headerlink" title="scanf()"></a>scanf()</h1><p><img src="/image/scanf(" alt="ANSI C中scanf()的转换说明">转换说明.png)</p>
<p><img src="/image/scanf(" alt="scanf()转换说明中的修饰符">转换说明中的修饰符.png)<br><img src="/image/scanf(" alt="scanf()转换说明中的修饰符续">转换说明中的修饰符续.png)</p>
<ul>
<li><code>scanf()</code> 更像是获取单词的函数，而不是获取整个字符串的函数。</li>
<li>使用 <code>%s</code> 转换说明时，<code>scanf()</code> 会从第一个非空白字符开始，读取直到遇到下一个空白字符（空格、制表符、换行符等）为止。</li>
<li>如果指定了字段宽度，如 <code>%10s</code>，<code>scanf()</code> 将读取指定数量的字符或者在遇到第一个空白字符时停止（以先满足条件为准）。<br><img src="/image/字段宽度和scanf(" alt="字段宽度和scanf()">.png)</li>
</ul>
<p><code>scanf()</code>的典型用法是读取并转换混合数据类型为某种标准形式。<br>例如，如果输入行包含一种工具名、库存量和单价，就可以使用<code>scanf()</code>。</p>
<h1 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h1><p>从数值方面而不是从真/假方面来看测试条件。要牢记：关系表达式为真，求值得1；关系表达式为假，求值得0。因此，这些表达式实际上相当于数值。<br>例如，用<code>while(goats)</code>替换<code>while (goats !=0)</code>，因为表达式<code>goats != 0</code>和<code>goats</code>都只有在goats的值为0时才为0或假。<br>第1种形式（while (goats != 0)）对初学者而言可能比较清楚，但是第2种形式（while (goats)）才是C程序员最常用的。</p>
<h1 id="比较常量"><a href="#比较常量" class="headerlink" title="比较常量"></a>比较常量</h1><p>如果待比较的一个值是常量，可以把该常量放在左侧有助于编译器捕获错误：<br>5 = canoes   &lt;—— 语法错误<br>5 == canoes  &lt;—— 检查canoes的值是否为5<br>可以这样做是因为C语言不允许给常量赋值，编译器会把赋值运算符的这种用法作为语法错误标记出来。许多经验丰富的程序员在构建比较是否相等的表达式时，都习惯把常量放在左侧。</p>
<h1 id="比较算数运算符优先级"><a href="#比较算数运算符优先级" class="headerlink" title="比较算数运算符优先级"></a>比较算数运算符优先级</h1><p><img src="/image/比较算数运算符优先级.png" alt="比较算数运算符优先级"></p>
<h1 id="ctype-h-头文件中的字符测试函数"><a href="#ctype-h-头文件中的字符测试函数" class="headerlink" title="ctype.h 头文件中的字符测试函数"></a>ctype.h 头文件中的字符测试函数</h1><p><img src="/image/ctype.头文件中的字符测试函数.png" alt=" ctype.h头文件中的字符测试函数"><br><img src="/image/ctype.h头文件中的字符映射函数.png" alt="ctype.h头文件中的字符映射函数"></p>
<h1 id="ctype-h"><a href="#ctype-h" class="headerlink" title="ctype.h"></a>ctype.h</h1><p><code>ctype.h</code>系列的字符函数（如，<code>issapce()</code>和<code>isalpha()</code>）为创建以分类字符为基础的测试表达式提供了便捷的工具。</p>
<h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符:  ?:"></a>条件运算符:  <code>?:</code></h1><p>expression1 ? expression2 : expression3</p>
<p>如果 expression1 为真（非 0），那么整个条件表达式的值与 expression2的值相同；如果expression1为假（0），那么整个条件表达式的值与expression3的值相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(5 &gt; 3) ? 1 : 2 值为1</span><br><span class="line">(3 &gt; 5) ? 1 : 2 值为2</span><br><span class="line">(a &gt; b) ? a : b 如果a &gt;b，则取较大的值</span><br></pre></td></tr></table></figure>
<h1 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h1><p>switch在圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式（即，表达式中只包含整型常量）。不能用变量作为case标签。<br>switch的构造如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch ( 整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句 &lt;--可选</span><br><span class="line">case 常量2:</span><br><span class="line">语句 &lt;--可选</span><br><span class="line">default : &lt;--可选</span><br><span class="line">语句 &lt;--可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h1><p>考虑下面的输入：<br><code>is 28 12.4</code><br>在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。但是对 C程序而言，这是一个字节流。第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while ((ch = getchar()) != &#x27;\n&#x27;)</span><br><span class="line">putchar(ch); // 处理错误的输入</span><br></pre></td></tr></table></figure><br>虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值。例如，考虑下面的输入：<br><code>42</code><br>如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中。如果使用%s转换说明，它会读取字符4和字符2这两个字符，并将其储存在字符数组中。如果使用%d转换说明，scanf()同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-1-ANSI-C要求在每个变量前都声明其类型"><a href="#1-1-ANSI-C要求在每个变量前都声明其类型" class="headerlink" title="1.1 ANSI C要求在每个变量前都声明其类型"></a>1.1 ANSI C要求在每个变量前都声明其类型</h2><p>不能像普通变量声明那样使用同一类型的变量列表：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dibs(int x, y, z) /* 无效的函数头 */</span><br><span class="line">void dubs(int x, int y, int z) /* 有效的函数头 */</span><br></pre></td></tr></table></figure><br>如果变量是同一类型，这种形式可以用逗号分隔变量名列表，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dibs(x, y, z)</span><br><span class="line">int x, y, z; /* 有效 */</span><br></pre></td></tr></table></figure></p>
<h2 id="1-2-使用函数前先声明"><a href="#1-2-使用函数前先声明" class="headerlink" title="1.2 使用函数前先声明"></a>1.2 使用函数前先声明</h2><p>在使用函数之前，要用ANSI C形式声明函数原型：<br><code>void show_n_char(char ch, int num);</code><br>当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，你也可以省略变量名：<br><code>void show_n_char(char, int);</code><br>在原型中使用变量名并没有实际创建变量，char仅代表了一个char类型的变量，以此类推。</p>
<h2 id="1-3-省略函数原型却保留函数原型的优点"><a href="#1-3-省略函数原型却保留函数原型的优点" class="headerlink" title="1.3 省略函数原型却保留函数原型的优点"></a>1.3 省略函数原型却保留函数原型的优点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 下面这行代码既是函数定义，也是函数原型</span><br><span class="line">int imax(int a, int b) &#123; return a &gt; b ? a : b; &#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int x, z;</span><br><span class="line">...</span><br><span class="line">z = imax(x, 50);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归的关键在于每个递归调用都会等待它的下一级递归完成，然后再继续执行后面的代码，最终实现整个递归的效果。</p>
<p>可以假设有一条函数调用链——fun1()调用fun2()、fun2()调用 fun3()、fun3()调用fun4()。当 fun4()结束时，控制传回<br>fun3()；当fun3()结束时，控制传回 fun2()；当fun2()结束时，控制传回fun1()。递归的情况与此类似，只不过fun1()、fun2()、fun3()和fun4()都是相同的函数。</p>
<h2 id="递归的基本原理"><a href="#递归的基本原理" class="headerlink" title="递归的基本原理"></a>递归的基本原理</h2><ol>
<li>每级函数调用都有自己的变量。也就是说，第1级的n和第2级的n不同，所以程序创建了4个单独的变量，每个变量名都是n，但是它们的值各<br>不相同。当程序最终返回 up_and_down()的第1 级调用时，最初的n仍然是它的初值1。<br><img src="/image/递归中的变量.png" alt="递归中的变量"></li>
<li>每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某级up_and_down()返回<br>上一级的up_and_down()，不能跳级回到main()中的第1级调用。</li>
<li>递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。例如，程序清单9.6中的打印语句#1位于递归调用之前，它按照递归的<br>顺序：第1级、第2级、第3级和第4级，被执行了4次。</li>
<li>递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。例如，打印语句#2位于递归调用之后，其执行的顺序是第4级、第3<br>级、第2级、第1级。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。稍后将介绍一个这样的例子。</li>
<li>虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代<br>码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。</li>
<li>递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，<br>每次递归调用的形参都要使用不同的值。例如，程序中的up_and_down(n)调用up_and_down(n+1)。最终，实际参数等于4时，if的测试<br>条件(n &lt; 4)为假。</li>
</ol>
<h1 id="return"><a href="#return" class="headerlink" title="return"></a>return</h1><p>返回值不仅可以赋给变量，也可以被用作表达式的一部分。<br>返回值不一定是变量的值，也可以是任意表达式的值。<br><code>return (n &lt; m) ? n : m;</code></p>
<p><code>void variables(double *, double *, double *);</code></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。</p>
<p>整个数组的大小除以单个元素的大小就是数组元素的个数。</p>
<p>for (index = 0; index &lt; sizeof days / sizeof days[0]; index++)<br>sizeof days是整个数组的大小（以字节为单位），sizeof day[0]是数组中一个元素的大小（以字节为单位）。</p>
<p>只有在函数原型或函数定义头中，才可以用<code>int ar[]</code>代替<code>int * ar</code></p>
<p>由于函数原型可以省略参数名，所以下面4种原型都是等价的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(int *ar, int n);</span><br><span class="line">int sum(int *, int);</span><br><span class="line">int sum(int ar[], int n);</span><br><span class="line">int sum(int [], int);</span><br></pre></td></tr></table></figure><br>但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum(int *ar, int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum(int ar[], int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字<code>const</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum(const int ar[], int n); /* 函数原型 */</span><br><span class="line">int sum(const int ar[], int n) /* 函数定义 */</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int total = 0;</span><br><span class="line">for( i = 0; i &lt; n; i++)</span><br><span class="line">total += ar[i];</span><br><span class="line">return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用const。</p>
<p><strong>复合字面量</strong></p>
<p>普通的数组声明：<code>int diva[2] = &#123;10, 20&#125;;</code><br>下面的复合字面量创建了一个和diva数组相同的匿名数组，也有两个int类型的值：<br><code>(int [2])&#123;10, 20&#125; // 复合字面量</code></p>
<ul>
<li>去掉声明中的数组名，留下的int [2]即是复合字面量的类型名<br><code>(int [])&#123;50, 20, 90&#125; // 内含3个元素的复合字面量</code><br>因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。<br>还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(const int ar[], int n);</span><br><span class="line">...</span><br><span class="line">int total3;</span><br><span class="line">total3 = sum((int [])&#123;4,4,4,5,5,5&#125;, 6);</span><br></pre></td></tr></table></figure>
第1个实参是内含6个int类型值的数组，和数组名类似，这同时也是该数组首元素的地址。这种用法的好处是，把信息传入函数前不必先创建<br>数组，这是复合字面量的典型用法。</li>
</ul>
<p>可以把这种用法应用于二维数组或多维数组。例如，下面的代码演示了如何创建二维int数组并储存其地址：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (*pt2)[4]; // 声明一个指向二维数组的指针，该数组内含2个数组元素，</span><br><span class="line">// 每个元素是内含4个int类型值的数组</span><br><span class="line">pt2 = (int [2][4]) &#123; &#123;1,2,3,-9&#125;, &#123;4,5,6,-8&#125; &#125;;</span><br></pre></td></tr></table></figure><br>如上所示，该复合字面量的类型是<code>int [2][4]</code>，即一个2×4的int数组。</p>
<p><strong>变长数组</strong></p>
<p>C99引入了变长数组（Variable-Length Arrays，VLA），允许使用变量表示数组的维度。以下是一个使用变长数组的例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int quarters = 4;</span><br><span class="line">int regions = 5;</span><br><span class="line">double sales[regions][quarters]; // 变长数组（VLA）</span><br></pre></td></tr></table></figure><br>变长数组的限制和特点：</p>
<ol>
<li><p>存储类别限制： 变长数组必须是自动存储类别，不能使用static或extern存储类别说明符。</p>
</li>
<li><p>初始化限制： 不能在声明中初始化变长数组。</p>
</li>
<li><p>可选特性： C11标准将变长数组作为可选特性，而不是必须强制实现的特性。</p>
</li>
<li><p>不能改变大小： 变长数组的”变”指的是在创建数组时可以使用变量指定数组的维度，而不是可以修改已创建数组的大小。一旦创建，数组的大小保持不变。</p>
</li>
</ol>
<p>计算二维数组元素之和的示例：<br>考虑一个函数 sum2d，计算int类型的二维数组所有元素之和。以下是该函数的声明和定义：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int sum2d(int rows, int cols, int ar[rows][cols]); // ar是一个变长数组（VLA）</span><br><span class="line"></span><br><span class="line">int sum2d(int rows, int cols, int ar[rows][cols])</span><br><span class="line">&#123;</span><br><span class="line">    int r;</span><br><span class="line">    int c;</span><br><span class="line">    int tot = 0;</span><br><span class="line"></span><br><span class="line">    for (r = 0; r &lt; rows; r++)</span><br><span class="line">        for (c = 0; c &lt; cols; c++)</span><br><span class="line">            tot += ar[r][c];</span><br><span class="line"></span><br><span class="line">    return tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>函数原型中，<code>ar</code> 是一个二维变长数组，使用了 <code>rows</code> 和 <code>cols</code> 作为两个维度。</li>
<li>函数定义中，使用了 <code>rows</code> 和 <code>cols</code> 来表示二维数组的大小，可以处理任意大小的二维int数组。<br><strong>注意：</strong> 形参列表中必须在声明 <code>ar</code> 之前先声明 <code>rows</code> 和 <code>cols</code>。</li>
</ul>
<p>此外，函数的定义也可以使用省略形参名的方式：<br><code>int sum2d(int, int, int ar[*][*]); // ar是一个变长数组（VLA），省略了维度形参名</code></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><strong>声明指针</strong></p>
<p>声明指针时需要需要带有变量，如果不想加变量则需要有<code>*</code></p>
<p>不要混淆 <code>*(dates+2)</code> 和<code>*dates+2</code> 。间接运算符（<em>）的优先级高于+，所以 `</em>dates+2` 相当于(*dates)+2：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(dates + 2) // dates第3个元素的值</span><br><span class="line"></span><br><span class="line">*dates + 2 // dates第1个元素的值加2</span><br></pre></td></tr></table></figure></p>
<p>一元运算符<code>*</code>和<code>++</code>的优先级相同，但结合律是从右往左，所以<code>start++</code>先求值，然后才是<code>*start</code>。也就是说，指针start先递增后指向。使用后缀形式（即<code>start++</code>而不是<code>++start</code>）如果使用<code>*++start</code>，顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使<code>(*start)++</code>，则先使用start指向的值，再递增该值，而不是递增指针。这样，指针将一直指向同一个位置，但是该位置上的值发生了变化。虽然<code>*start++</code>的写法比较常用，但是<code>*(start++)</code>这样写更清楚。</p>
<p><strong>当涉及到 <code>const</code> 修饰符和指针时，有几个要点需要注意：</strong></p>
<ul>
<li><code>const</code>修饰指针所指向的数据，表示指针所指向的数据不能通过这个指针进行修改。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const double *pd = rates; // pd指向数组的首元素</span><br><span class="line">*pd = 29.89; // 不允许修改</span><br><span class="line">pd[2] = 222.22; // 不允许修改</span><br><span class="line">rates[0] = 99.99; // 允许修改，因为rates未被const限定</span><br></pre></td></tr></table></figure></li>
<li>指向 <code>const</code> 的指针 (<code>const double *pc</code>) 可以指向非 <code>const</code> 的数据，但不能通过这个指针修改所指向的数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double *pc = rates; // 有效</span><br><span class="line">pc = &amp;rates[3]; // 有效</span><br><span class="line">*pc = 92.99; // 不允许修改</span><br></pre></td></tr></table></figure></li>
<li>指向非 <code>const</code> 的指针（<code>double *pnc</code>）可以指向 <code>const</code> 数据，但也不能通过这个指针修改所指向的 const 数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double locked[4] = &#123;0.08, 0.075, 0.0725, 0.07&#125;;</span><br><span class="line">double *pnc = rates; // 有效</span><br><span class="line">pnc = &amp;rates[3]; // 有效</span><br><span class="line">pnc = locked; // 不允许</span><br></pre></td></tr></table></figure></li>
<li><code>const</code> 可以用于指向数组的指针，保护数组数据不被修改：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double *pc = rates; // 指向数组的首元素</span><br><span class="line">show_array(rates, 5); // 有效，数组名转换成指向 const 的指针</span><br><span class="line">show_array(locked, 4); // 有效，数组名转换成指向 const 的指针</span><br></pre></td></tr></table></figure></li>
<li><code>const</code> 还可以用于创建常量指针，该指针一旦指向一个地址，就不能再指向别处：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">double * const pc = rates; // pc指向数组的开始</span><br><span class="line">pc = &amp;rates[2]; // 不允许，因为该指针不能指向别处</span><br><span class="line">*pc = 92.99; // 允许修改 rates[0] 的值</span><br></pre></td></tr></table></figure></li>
<li><code>const</code> 也可以用于创建既不能更改所指向地址，也不能修改指向地址上的值的指针：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double * const pc = rates; // 不能修改指向的地址，也不能修改地址上的值</span><br><span class="line">pc = &amp;rates[2]; // 不允许</span><br><span class="line">*pc = 92.99; // 不允许</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>演示程序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* order.c -- 指针运算中的优先级 */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int data[2] = &#123; 100, 200 &#125;;</span><br><span class="line">int moredata[2] = &#123; 300, 400 &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int * p1, *p2, *p3;</span><br><span class="line">    p1 = p2 = data;</span><br><span class="line">    p3 = moredata;</span><br><span class="line">    printf(&quot;*p1 = %d, *p2 = %d, *p3 = %d\n&quot;, *p1, *p2, *p3);</span><br><span class="line">    printf(&quot;*p1++=%d, *++p2=%d, (*p3)++=%d\n&quot;, *p1++, *++p2, (*p3)++);</span><br><span class="line">    printf(&quot;*p1 = %d, *p2 = %d, *p3 = %d\n&quot;, *p1, *p2, *p3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>该程序输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p1 = 100, *p2 = 100, *p3 = 300</span><br><span class="line">*p1++=100, *++p2=200, (*p3)++=300</span><br><span class="line">*p1 = 200, *p2 = 200, *p3 = 301</span><br></pre></td></tr></table></figure>
只有(*p3)++改变了数组元素的值，其他两个操作分别把p1和p2指向数组的下一个元素。</li>
</ul>
<h2 id="字符串声明比较"><a href="#字符串声明比较" class="headerlink" title="字符串声明比较"></a>字符串声明比较</h2><p>两种声明几乎相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *pt1 = &quot;Something is pointing at me;&quot;;</span><br><span class="line">const char ar1[] = &quot;Something is pointing at me;&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="数组形式（ar1-）"><a href="#数组形式（ar1-）" class="headerlink" title="数组形式（ar1[]）"></a>数组形式（ar1[]）</h3><ul>
<li>在内存中分配一个内含29个元素的数组，每个元素对应一个字符，还有一个末尾的空字符’\0’。</li>
<li>字符串作为可执行文件的一部分储存在数据段中，静态存储区。</li>
<li>程序开始运行时为数组分配内存，将字符串拷贝到数组中，此时有两个副本：一个在静态内存中，一个在数组中。</li>
<li>数组名ar1是该数组首元素地址的别名，是地址常量，不能更改。可以进行<code>ar1+1</code>等操作，但不允许进行<code>++ar1</code>这样的操作。</li>
</ul>
<h3 id="指针形式（-pt1）"><a href="#指针形式（-pt1）" class="headerlink" title="指针形式（*pt1）"></a>指针形式（*pt1）</h3><ul>
<li>编译器为字符串在静态存储区预留29个元素的空间，并为指针变量pt1留出一个储存位置，将字符串的地址储存在指针变量中。</li>
<li>指针形式只拷贝字符串的地址给指针，不会拷贝字符串本身。指针可以改变指向的位置，可以使用递增运算符。</li>
<li>字符串字面量被视为const数据，因此指针pt1需要声明为指向const数据的指针，不能通过pt1改变所指向的数据。</li>
</ul>
<p><strong>总结：初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。</strong></p>
<h3 id="空字符与空指针的区别"><a href="#空字符与空指针的区别" class="headerlink" title="空字符与空指针的区别"></a>空字符与空指针的区别</h3><ul>
<li><p><strong>空字符 (‘\0’)：</strong></p>
<ul>
<li>用于标记C字符串的末尾。</li>
<li>对应字符编码是0。</li>
<li>在字符串中不可能是其他字符的一部分。</li>
<li>是整数类型，占1字节。</li>
</ul>
</li>
<li><p><strong>空指针 (NULL)：</strong></p>
<ul>
<li>有一个值，该值不会与任何数据的有效地址对应。</li>
<li>通常用于表示特殊情况，例如遇到文件结尾或未能按预期执行。</li>
<li>是指针类型，占4字节（通常）。</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong><br>虽然它们可以用数值0来表示，但从概念上看，空字符和空指针是不同类型的0。</p>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul>
<li><strong>请注意，那些使用const关键字的函数原型表明，函数不会更改字符串。</strong></li>
</ul>
<p><code>char *strcpy(char * restrict s1, const char * restrict s2);</code><br>该函数把s2指向的字符串（包括空字符）拷贝至s1指向的位置，返回值是s1。</p>
<p><code>char *strncpy(char * restrict s1, const char * restrict s2, size_t n);</code><br>该函数把s2指向的字符串拷贝至s1指向的位置，拷贝的字符数不超过n，其返回值是s1。该函数不会拷贝空字符后面的字符，如果源字符串的字符少于n个，目标字符串就以拷贝的空字符结尾；如果源字符串有n个或超过n个字符，就不拷贝空字符。</p>
<p><code>char *strcat(char * restrict s1, const char * restrict s2);</code><br>该函数把s2指向的字符串拷贝至s1指向的字符串末尾。s2字符串的第1个字符将覆盖s1字符串末尾的空字符。该函数返回s1。</p>
<p><code>char *strncat(char * restrict s1, const char * restrict s2, size_t n);</code><br>该函数把s2字符串中的n个字符拷贝至s1字符串末尾。s2字符串的第1个字符将覆盖s1字符串末尾的空字符。不会拷贝s2字符串中空字符和其后的字符，并在拷贝字符的末尾添加一个空字符。该函数返回s1。</p>
<p><code>int strcmp(const char * s1, const char * s2);</code><br>如果s1字符串在机器排序序列中位于s2字符串的后面，该函数返回一个正数；如果两个字符串相等，则返回0；如果s1字符串在机器排序序列中位于s2字符串的前面，则返回一个负数。</p>
<p><code>int strncmp(const char * s1, const char * s2, size_t n);</code><br>该函数的作用和strcmp()类似，不同的是，该函数在比较n个字符后或遇到第1个空字符时停止比较。</p>
<p><code>char *strchr(const char * s, int c);</code><br>如果s字符串中包含c字符，该函数返回指向s字符串首位置的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串s中未找到c字符，该函数则返回空指针。</p>
<p><code>char *strpbrk(const char * s1, const char * s2);</code><br>如果 s1 字符中包含 s2 字符串中的任意字符，该函数返回指向 s1 字符串首位置的指针；如果在s1字符串中未找到任何s2字符串中的字符，则返回空字符。</p>
<p><code>char *strrchr(const char * s, int c);</code><br>该函数返回s字符串中c字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如果未找到c字符，则返回空指针。</p>
<p><code>char *strstr(const char * s1, const char * s2);</code><br>该函数返回指向s1字符串中s2字符串出现的首位置。如果在s1中没有找到s2，则返回空指针。</p>
<p><code>size_t strlen(const char * s);</code><br>该函数返回s字符串中的字符数，不包括末尾的空字符。</p>
<h2 id="s-gets"><a href="#s-gets" class="headerlink" title="s_gets()"></a>s_gets()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char * s_get(char * st, int n)</span><br><span class="line">&#123;</span><br><span class="line">char * ret_val;</span><br><span class="line">ret_val = fgets(st, n, stdin);</span><br><span class="line">if (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">while (*st != &#x27;\n&#x27; &amp;&amp; *st != &#x27;\0&#x27;)</span><br><span class="line">st++;</span><br><span class="line">if (*st == &#x27;\n&#x27;)</span><br><span class="line">*st = &#x27;\0&#x27;;</span><br><span class="line">else</span><br><span class="line">while (getchar() != &#x27;\n&#x27;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">return ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;        // 提供 fgets()和getchar()的原型</span><br><span class="line">#include &lt;string.h&gt;       // 提供 strchr()的原型</span><br><span class="line">char * s_gets(char * st, int n)</span><br><span class="line">&#123;</span><br><span class="line">char * ret_val;</span><br><span class="line">char * find;</span><br><span class="line">ret_val = fgets(st, n, stdin);</span><br><span class="line">if (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">find = strchr(st,  &#x27;\n&#x27;);</span><br><span class="line">if (find)		      // 如果地址不是 NULL,</span><br><span class="line">*find = &#x27;\0&#x27;;	    // 在此处放置一个空字符</span><br><span class="line">else</span><br><span class="line">while (getchar() != &#x27;\0&#x27;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">return ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存分配：malloc-和-free"><a href="#内存分配：malloc-和-free" class="headerlink" title="内存分配：malloc() 和 free()"></a>内存分配：malloc() 和 free()</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>malloc()函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说， malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。malloc()函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。如果 malloc()分配内存失败，将返回空指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double * ptd;</span><br><span class="line"></span><br><span class="line">ptd = (double *) malloc(30 * sizeof(double));</span><br></pre></td></tr></table></figure>
<p>以上代码为30个double类型的值请求内存空间，并设置ptd指向该位置。<br>注意，指针ptd被声明为指向一个double类型，而不是指向内含30个double类型值的块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double item[n];</span><br><span class="line"></span><br><span class="line">ptd = (double *) malloc(n * sizeof(double));</span><br></pre></td></tr></table></figure>
<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存<br>数量只会增加，除非用 free()进行释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">double glad[2000];</span><br><span class="line">int i;</span><br><span class="line">...</span><br><span class="line">for (i = 0; i &lt; 1000; i++)</span><br><span class="line">gobble(glad, 2000);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">void gobble(double ar[], int n)</span><br><span class="line">&#123;</span><br><span class="line">double * temp = (double *) malloc( n * sizeof(double));</span><br><span class="line">.../* free(temp); // 假设忘记使用free() */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long * newmem;</span><br><span class="line"></span><br><span class="line">newmem = (long *)calloc(100, sizeof (long));</span><br></pre></td></tr></table></figure>
<p>和malloc()类似，返回指向void的指针。如果要储存不同的类型，应使用强制类型转换运算符。</p>
<p>calloc()函数还有一个特性：它把块中的所有位都设置为0（注意，在某些硬件系统中，不是把所有位都设置为0来表示浮点值0）。</p>
<p>free()函数也可用于释放calloc()分配的内存。</p>
<h3 id="动态内存分配和变长数组"><a href="#动态内存分配和变长数组" class="headerlink" title="动态内存分配和变长数组"></a>动态内存分配和变长数组</h3><p>对多维数组而言，使用变长数组更方便。当然，也可以用 <code>malloc()</code> 创建二维数组，但是语法比较繁琐。如果编译器不支持变长数组特性，就只能固<br>定二维数组的维度，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n = 5;</span><br><span class="line">int m = 6;</span><br><span class="line">int ar2[n][m]; // n×m的变长数组（VLA）</span><br><span class="line">int (* p2)[6]; // C99之前的写法</span><br><span class="line">int (* p3)[m]; // 要求支持变长数组</span><br><span class="line">p2 = (int (*)[6]) malloc(n * 6 * sizeof(int)); // n×6 数组</span><br><span class="line">p3 = (int (*)[m]) malloc(n * m * sizeof(int)); // n×m 数组（要求支持变长数组）</span><br><span class="line">ar2[1][2] = p2[1][2] = 12;</span><br></pre></td></tr></table></figure>
<p>先复习一下指针声明。由于malloc()函数返回一个指针，所以p2必须是一个指向合适类型的指针。第1个指针声明：<br><code>int (* p2)[6]; // C99之前的写法</code></p>
<p>表明p2指向一个内含6个int类型值的数组。因此，<code>p2[i]</code>代表一个由6个整数构成的元素，<code>p2[i][j]</code>代表一个整数。<br>第2个指针声明用一个变量指定p3所指向数组的大小。因此，p3代表一个指向变长数组的指针，这行代码不能在C90标准中运行。</p>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h2><p><img src="/image/fopen(" alt="fopen()的模式字符串">.png)</p>
<h2 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h2><p>为了避免读到空文件，应该使用入口条件循环（不是do while循环）。鉴于getc() （和其他C输入函数）的设计，程序应该在进入循环体之前先尝试读取。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 设计范例 #1</span><br><span class="line">int ch; // 用int类型的变量储存EOF</span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(&quot;wacky.txt&quot;, &quot;r&quot;);</span><br><span class="line">ch = getc(fp); // 获取初始输入</span><br><span class="line">while (ch != EOF)</span><br><span class="line">&#123;</span><br><span class="line">putchar(ch); // 处理输入</span><br><span class="line">ch = getc(fp); // 获取下一个输入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码可简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 设计范例 #2</span><br><span class="line">int ch;</span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(&quot;wacky.txt&quot;, &quot;r&quot;);</span><br><span class="line">while (( ch = getc(fp)) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">putchar(ch); //处理输入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h2><p><img src="/image/文件的起始点模式.png" alt="文件的起始点模式"></p>
<p>fseek()的第1个参数是FILE指针，指向待查找的文件，fopen()应该已打开该文件。<br>fseek()的第2个参数是偏移量（offset）。该参数表示从起始点开始要移动的距离（参见表列出的起始点模式）。该参数必须是一个long类型的值，可以为正（前移）、负（后移）或0（保持不动）。<br>fseek()的第3个参数是模式，该参数确定起始点。</p>
<p>下面是调用fseek()函数的一些示例，fp是一个文件指针：<br>fseek(fp, 0L, SEEK_SET); // 定位至文件开始处<br>fseek(fp, 10L, SEEK_SET); // 定位至文件中的第10个字节<br>fseek(fp, 2L, SEEK_CUR); // 从文件当前位置前移2个字节<br>fseek(fp, 0L, SEEK_END); // 定位至文件结尾<br>fseek(fp, -10L, SEEK_END); // 从文件结尾处回退10个字节</p>
<p><img src="/image/文本模式调用.png" alt="文本模式调用.png"></p>
<h2 id="指针访问结构成员"><a href="#指针访问结构成员" class="headerlink" title="指针访问结构成员"></a>指针访问结构成员</h2><p>如果<code>him == &amp;fellow[0]</code>，那么<code>*him == fellow[0]</code>，因为<code>&amp;</code>和<code>*</code>是一对互逆运算符。<br>因此，可以做以下替代：<br><code>fellow[0].income == (*him).income</code><br>必须要使用圆括号，因为<code>.</code>运算符比<code>*</code>运算符的优先级高。<br>总之，如果<code>him</code>是指向<code>guy</code>类型结构<code>barney</code>的指针，下面的关系恒成立：<br><code>barney.income == (*him).income == him-&gt;income // 假设 him == &amp;barney</code></p>
<h2 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h2><p>移位运算符针对2的幂提供快速有效的乘法和除法：</p>
<p><code>number &lt;&lt; n</code>     number 乘以2的n次幂<br><code>number &gt;&gt; n</code>     如果number为非负，则用number除以2的n次幂</p>
<p>这些移位运算符类似于在十进制中移动小数点来乘以或除以10。</p>
<h2 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h2><p>因为ASCII码只使用最后7位，所以有时需要用掩码关闭其他位，其相应的二进制掩码是什么？分别用十进制、八进制和十六进制来表示这个掩码。</p>
<p>掩码的二进制是<code>1111111</code>；十进制是<code>127</code>；八进制是<code>0177</code>；十六进制是<code>0x7F</code>。</p>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p><code>#ifdef</code> 判断是否定义了标识符。如果定义了则执行<code>#else</code>或<code>#endif</code>指令之前的所有指令并编译所有C代码，如果未定义则执行<code>#else</code>和<code>#endif</code>指令之间的所有代码。</p>
<p><code>#ifndef</code> 判断后面的标识符是否是未定义的。通常用于防止多次包含一个文件。</p>
<p><code>#if</code>指令很像C语言中的<code>if</code>。<code>#if</code>后面跟整型常量表达式，如果表达式为非零，则表达式为真。<br>可以按照if else的形式使用<code>#elif</code>。<br>较新的编译器提供另一种方法测试名称是否已定义，即用<code>#if defined(VAX)</code>代替<code>#ifdef VAX</code>。<br>这里，defined是一个预处理运算符，如果它的参数是用<code>#defined</code>定义过，则返回<code>1</code>；否则返回<code>0</code>。这种新方法的优点是，它可以和<code>#elif</code>一起使用。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if defined (IBMPC)</span><br><span class="line">#include &quot;ibmpc.h&quot;</span><br><span class="line">#elif defined (VAX)</span><br><span class="line">#include &quot;vax.h&quot;</span><br><span class="line">#elif defined (MAC)</span><br><span class="line">#include &quot;mac.h&quot;</span><br><span class="line">#else</span><br><span class="line">#include &quot;general.h&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><br>如果在VAX机上运行这几行代码，那么应该在文件前面用下面的代码定义VAX：<br><code>#define VAX</code></p>
<h2 id="在-define-中使用参数"><a href="#在-define-中使用参数" class="headerlink" title="在 #define 中使用参数"></a>在 <code>#define</code> 中使用参数</h2><p>在#define中使用参数可以创建外形和作用与函数类似的类函数宏。带有参数的宏看上去很像函数，因为这样的宏也使用圆括号。类函数宏定义的圆括号中可以有一个或多个参数，随后这些参数出现在替换体中。</p>
<p><img src="/image/函数宏定义的组成.png" alt="函数宏定义的组成"></p>
<ul>
<li><code>#define SQUARE(X) X*X</code></li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="#运算符"></a><code>#运算符</code></h3><p>下面是一个类函数宏：<br><code>#define PSQR(X) printf(&quot;The square of X is %d.\n&quot;, ((X)*(X)));</code><br>假设这样使用宏：<br><code>PSQR(8);</code><br>输出为：<br><code>The square of X is 64.</code><br>C允许在字符串中包含宏参数。在类函数宏的替换体中，<code>#</code>号作为一个预处理运算符，可以把记号转换成字符串。例如，如果<code>x</code>是一个宏形参，那么<code>#x</code>就是转换为字符串”x”的形参名。这个过程称为字符串化（stringizing）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* subst.c -- 在字符串中替换 */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define PSQR(x) printf(&quot;The square of &quot; #x &quot; is %d.\n&quot;,((x)*(x)))</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int y = 5;</span><br><span class="line">PSQR(y);</span><br><span class="line">PSQR(2 + 4);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">该程序的输出如下：</span><br><span class="line">The square of y is 25.</span><br><span class="line">The square of 2 + 4 is 36.</span><br></pre></td></tr></table></figure><br>调用第1个宏时，用”<code>y</code>“替换#x。调用第2个宏时，用”<code>2 + 4</code>“替换<code>#x</code>。ANSI C字符串的串联特性将这些字符串与printf()语句的其他字符串组合，生成最终的字符串。</p>
<h3 id="预处理器粘合剂：-运算符"><a href="#预处理器粘合剂：-运算符" class="headerlink" title="预处理器粘合剂：##运算符"></a>预处理器粘合剂：<code>##运算符</code></h3><p>与<code>#</code>运算符类似，<code>##</code>运算符可用于类函数宏的替换部分。而且，<code>##</code>还可用于对象宏的替换部分。<code>##</code>运算符把两个记号组合成一个记号。例如，可以这样做：<br><code>#define XNAME(n) x ## n</code><br>然后，宏<code>XNAME(4)</code>将展开为<code>x4</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// glue.c -- 使用##运算符</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define XNAME(n) x ## n</span><br><span class="line">#define PRINT_XN(n) printf(&quot;x&quot; #n &quot; = %d\n&quot;, x ## n);</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int XNAME(1) = 14; // 变成 int x1 = 14;</span><br><span class="line">int XNAME(2) = 20; // 变成 int x2 = 20;</span><br><span class="line">int x3 = 30;</span><br><span class="line">1212</span><br><span class="line">PRINT_XN(1); // 变成 printf(&quot;x1 = %d\n&quot;, x1);</span><br><span class="line">PRINT_XN(2); // 变成 printf(&quot;x2 = %d\n&quot;, x2);</span><br><span class="line">PRINT_XN(3); // 变成 printf(&quot;x3 = %d\n&quot;, x3);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">该程序的输出如下：</span><br><span class="line">x1 = 14</span><br><span class="line">x2 = 20</span><br><span class="line">x3 = 30</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意，PRINT_XN()宏用#运算符组合字符串，##运算符把记号组合为一个新的标识符。</li>
</ul>
<h3 id="变参宏：-和-VA-ARGS"><a href="#变参宏：-和-VA-ARGS" class="headerlink" title="变参宏： ...和__VA_ARGS__"></a>变参宏： <code>...</code>和<code>__VA_ARGS__</code></h3><p><code>stdvar.h</code> 头文件提供了工具，让用户自定义带可变参数的函数。<br>通过把宏参数列表中最后的参数写成省略号（即，3个点…）来实现这一功能。这样，预定义宏<code>_ _VA_ARGS_</code><em>可用在替换部分中，表明省略号代表什么。例如，下面的定义：<br>`#define PR(…) printf(</em> <em>VA_ARGS</em> _)`<br>假设稍后调用该宏：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PR(&quot;Howdy&quot;);</span><br><span class="line">PR(&quot;weight = %d, shipping = $%.2f\n&quot;, wt, sp);</span><br><span class="line">对于第1次调用，_ _VA_ARGS_ _展开为1个参数：&quot;Howdy&quot;。</span><br><span class="line">对于第2次调用，_ _VA_ARGS_ _展开为3个参数：&quot;weight = %d,</span><br><span class="line">shipping = $%.2f\n&quot;、wt、sp。</span><br></pre></td></tr></table></figure><br>因此，展开后的代码是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Howdy&quot;);</span><br><span class="line">printf(&quot;weight = %d, shipping = $%.2f\n&quot;, wt, sp);</span><br></pre></td></tr></table></figure></p>
<h3 id="宏和函数的选择"><a href="#宏和函数的选择" class="headerlink" title="宏和函数的选择"></a>宏和函数的选择</h3><p>宏的一个优点是，不用担心变量类型（这是因为宏处理的是字符串，而不是实际的值）。<br>对于简单的函数，程序员通常使用宏，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(X,Y) ((X) &gt; (Y) ? (X) : (Y))</span><br><span class="line">#define ABS(X) ((X) &lt; 0 ? -(X) : (X))</span><br><span class="line">#define ISSIGN(X) ((X) == &#x27;+&#x27; || (X) == &#x27;-&#x27; ? 1 : 0)</span><br></pre></td></tr></table></figure><br>（如果x是一个代数符号字符，最后一个宏的值为1，即为真。）<br>用圆括号把宏的参数和整个替换体括起来。这样能确保被括起来的部分在下面这样的表达式中正确地展开：<br><code>forks = 2 * MAX(guests + 3, last);</code><br>用大写字母表示宏函数的名称。</p>
<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><p><img src="/image/预定义宏.png" alt="预定义宏"></p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>最简单的方法是使用函数说明符 <code>inline</code> 和存储类别说明符<code>static</code>。通常，内联函数应定义在首次使用它的文件中，所以内联函数也相当于函数原型。<br>编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定义与函数调用必须在同一个文件中。最简单的做法是，把内联函数定义放入头文件，并在使用该内联函数的文件中包含该头文件即可。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// eatline.h</span><br><span class="line">#ifndef EATLINE_H_</span><br><span class="line">#define EATLINE_H_</span><br><span class="line">inline static void eatline()</span><br><span class="line">&#123;</span><br><span class="line">while (getchar() != &#x27;\n&#x27;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><br>一般都不在头文件中放置可执行代码，内联函数是个特例。因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题。</p>
<h2 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h2><p><img src="/image/数学库.png" alt="数学函数"></p>
<h2 id="可变参数：stdarg-h"><a href="#可变参数：stdarg-h" class="headerlink" title="可变参数：stdarg.h"></a>可变参数：<code>stdarg.h</code></h2><p>必须按如下步骤进行：</p>
<ol>
<li>提供一个使用省略号的函数原型；</li>
<li>在函数定义中创建一个va_list类型的变量；</li>
<li>用宏把该变量初始化为一个参数列表；</li>
<li>用宏访问参数列表；</li>
<li>用宏完成清理工作。</li>
</ol>
<p>因为<code>va_arg()</code>不提供退回之前参数的方法，所以有必要保存<code>va_list</code>类型变量的副本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;                 // 声明一个对象储存参数</span><br><span class="line">va_list apcopy;             // 声明一个复制对象储存参数</span><br><span class="line">double</span><br><span class="line">double tic;</span><br><span class="line">int toc;</span><br><span class="line">...</span><br><span class="line">va_start(ap, lim);          // 把ap初始化为一个参数列表</span><br><span class="line">va_copy(apcopy, ap);        // 把apcopy作为ap的副本</span><br><span class="line">tic = va_arg(ap, double);   // 检索第1个参数</span><br><span class="line">toc = va_arg(ap, int);      // 检索第2个参数</span><br><span class="line">va_end(ap);                 // 清理工作</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/language/" rel="tag"><i class="fa fa-tag"></i> language</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/05/18/101-A10-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A43%20%C2%B7%20Farmsec%20Open%20Source/" rel="prev" title="">
      <i class="fa fa-chevron-left"></i> 
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/11/27/C-primer-question/" rel="next" title="C-primer question">
      C-primer question <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Inhaltsverzeichnis
        </li>
        <li class="sidebar-nav-overview">
          Übersicht
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D"><span class="nav-number">1.</span> <span class="nav-text">常量命名</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%98%BE%E7%A4%BA%E5%85%AB%E8%BF%9B%E5%88%B6%E5%92%8C%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="nav-number">2.</span> <span class="nav-text">显示八进制和十六进制</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E5%8D%B0short%E3%80%81long%E3%80%81long-long%E5%92%8Cunsigned%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">打印short、long、long long和unsigned类型</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scanf"><span class="nav-number">4.</span> <span class="nav-text">scanf()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%93%E5%8D%B0%E6%B5%AE%E7%82%B9%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">打印浮点数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#printf"><span class="nav-number">6.</span> <span class="nav-text">printf()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#scanf-1"><span class="nav-number">7.</span> <span class="nav-text">scanf()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9C%9F%E5%80%BC"><span class="nav-number">8.</span> <span class="nav-text">真值</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E5%B8%B8%E9%87%8F"><span class="nav-number">9.</span> <span class="nav-text">比较常量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">10.</span> <span class="nav-text">比较算数运算符优先级</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ctype-h-%E5%A4%B4%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E6%B5%8B%E8%AF%95%E5%87%BD%E6%95%B0"><span class="nav-number">11.</span> <span class="nav-text">ctype.h 头文件中的字符测试函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ctype-h"><span class="nav-number">12.</span> <span class="nav-text">ctype.h</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">13.</span> <span class="nav-text">条件运算符:  ?:</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#switch-%E8%AF%AD%E5%8F%A5"><span class="nav-number">14.</span> <span class="nav-text">switch 语句</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">15.</span> <span class="nav-text">输入流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">16.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-ANSI-C%E8%A6%81%E6%B1%82%E5%9C%A8%E6%AF%8F%E4%B8%AA%E5%8F%98%E9%87%8F%E5%89%8D%E9%83%BD%E5%A3%B0%E6%98%8E%E5%85%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">16.1.</span> <span class="nav-text">1.1 ANSI C要求在每个变量前都声明其类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%89%8D%E5%85%88%E5%A3%B0%E6%98%8E"><span class="nav-number">16.2.</span> <span class="nav-text">1.2 使用函数前先声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-%E7%9C%81%E7%95%A5%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E5%8D%B4%E4%BF%9D%E7%95%99%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">16.3.</span> <span class="nav-text">1.3 省略函数原型却保留函数原型的优点</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">17.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">17.1.</span> <span class="nav-text">递归的基本原理</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#return"><span class="nav-number">18.</span> <span class="nav-text">return</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">18.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">18.2.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A3%B0%E6%98%8E%E6%AF%94%E8%BE%83"><span class="nav-number">18.3.</span> <span class="nav-text">字符串声明比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%BD%A2%E5%BC%8F%EF%BC%88ar1-%EF%BC%89"><span class="nav-number">18.3.1.</span> <span class="nav-text">数组形式（ar1[]）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%BD%A2%E5%BC%8F%EF%BC%88-pt1%EF%BC%89"><span class="nav-number">18.3.2.</span> <span class="nav-text">指针形式（*pt1）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%8E%E7%A9%BA%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">18.3.3.</span> <span class="nav-text">空字符与空指针的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0"><span class="nav-number">18.4.</span> <span class="nav-text">字符串函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#s-gets"><span class="nav-number">18.5.</span> <span class="nav-text">s_gets()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%EF%BC%9Amalloc-%E5%92%8C-free"><span class="nav-number">18.6.</span> <span class="nav-text">内存分配：malloc() 和 free()</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#malloc"><span class="nav-number">18.6.1.</span> <span class="nav-text">malloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#free"><span class="nav-number">18.6.2.</span> <span class="nav-text">free()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#calloc"><span class="nav-number">18.6.3.</span> <span class="nav-text">calloc()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="nav-number">18.6.4.</span> <span class="nav-text">动态内存分配和变长数组</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fopen"><span class="nav-number">18.7.</span> <span class="nav-text">fopen()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E5%B0%BE"><span class="nav-number">18.8.</span> <span class="nav-text">文件结尾</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fseek"><span class="nav-number">18.9.</span> <span class="nav-text">fseek()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span class="nav-number">18.10.</span> <span class="nav-text">指针访问结构成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97"><span class="nav-number">18.11.</span> <span class="nav-text">位移运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A9%E7%A0%81"><span class="nav-number">18.12.</span> <span class="nav-text">掩码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="nav-number">18.13.</span> <span class="nav-text">条件编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%A8-define-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0"><span class="nav-number">18.14.</span> <span class="nav-text">在 #define 中使用参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">18.14.1.</span> <span class="nav-text">#运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E7%B2%98%E5%90%88%E5%89%82%EF%BC%9A-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">18.14.2.</span> <span class="nav-text">预处理器粘合剂：##运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E5%8F%82%E5%AE%8F%EF%BC%9A-%E5%92%8C-VA-ARGS"><span class="nav-number">18.14.3.</span> <span class="nav-text">变参宏： ...和__VA_ARGS__</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%8F%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">18.14.4.</span> <span class="nav-text">宏和函数的选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="nav-number">18.15.</span> <span class="nav-text">预定义宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">18.16.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%AD%A6%E5%BA%93"><span class="nav-number">18.17.</span> <span class="nav-text">数学库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%EF%BC%9Astdarg-h"><span class="nav-number">18.18.</span> <span class="nav-text">可变参数：stdarg.h</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mortal</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">Artikel</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">Kategorien</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">schlagwörter</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AllofMortal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AllofMortal" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/AllofMortal" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;AllofMortal" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mortal</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
