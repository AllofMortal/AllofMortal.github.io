<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Hexo
    </title>
    <meta name="description" content= 嘿，我是Mortal这是我的博客，用于记录自己的笔记。欢迎指正！ >
    <meta name="keywords" content= Blog,Hexo,Theme,Mortal >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            Python基础
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="Python-基础"><a href="#Python-基础" class="headerlink" title="Python 基础"></a>Python 基础</h1><h2 id="1-Pyhton-简述"><a href="#1-Pyhton-简述" class="headerlink" title="1. Pyhton 简述"></a>1. Pyhton 简述</h2><p><a target="_blank" rel="noopener" href="https://www.python.org/">Pyhton 官网</a></p>
<h3 id="1-1-IDLE"><a href="#1-1-IDLE" class="headerlink" title="1.1 IDLE"></a>1.1 IDLE</h3><p>在 IDLE 的交互模式下，你给它一个指令，它立刻会还你一个反馈：<br><img src="/image/IDLE.png" alt="IDLE"></p>
<p>打开 IDLE 的编辑器模式<br>打开 IDLE，在菜单栏中依次点击 File-&gt;New File，或者直接使用快捷键 Ctrl+N：<br><img src="/image/IDLE%E7%BC%96%E8%BE%91%E5%99%A8.png" alt="IDLE编辑器模式"></p>
<h3 id="1-2-BIF-（Built-in-Function）"><a href="#1-2-BIF-（Built-in-Function）" class="headerlink" title="1.2 BIF （Built-in Function）"></a>1.2 BIF （Built-in Function）</h3><p>Python 提供了很多内置函数，以对付各种不同的需求。</p>
<p>在 IDLE 的交互模式下，输入 dir(<strong>builtins</strong>)，可以看到它们：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">dir(__builtins__)</span><br><span class="line"></span><br><span class="line">[&#x27;ArithmeticError&#x27;, &#x27;AssertionError&#x27;, &#x27;AttributeError&#x27;, &#x27;BaseException&#x27;, &#x27;BlockingIOError&#x27;, &#x27;BrokenPipeError&#x27;, &#x27;BufferError&#x27;, </span><br><span class="line">&#x27;BytesWarning&#x27;, &#x27;ChildProcessError&#x27;, &#x27;ConnectionAbortedError&#x27;, &#x27;ConnectionError&#x27;, &#x27;ConnectionRefusedError&#x27;, &#x27;ConnectionResetError&#x27;, &#x27;DeprecationWarning&#x27;, </span><br><span class="line">&#x27;EOFError&#x27;, &#x27;Ellipsis&#x27;, &#x27;EnvironmentError&#x27;, &#x27;Exception&#x27;, &#x27;False&#x27;, &#x27;FileExistsError&#x27;, &#x27;FileNotFoundError&#x27;, </span><br><span class="line">&#x27;FloatingPointError&#x27;, &#x27;FutureWarning&#x27;, &#x27;GeneratorExit&#x27;, &#x27;IOError&#x27;, &#x27;ImportError&#x27;, &#x27;ImportWarning&#x27;, &#x27;IndentationError&#x27;, &#x27;IndexError&#x27;, </span><br><span class="line">&#x27;InterruptedError&#x27;, &#x27;IsADirectoryError&#x27;, &#x27;KeyError&#x27;, &#x27;KeyboardInterrupt&#x27;, &#x27;LookupError&#x27;, &#x27;MemoryError&#x27;, &#x27;ModuleNotFoundError&#x27;, </span><br><span class="line">&#x27;NameError&#x27;, &#x27;None&#x27;, &#x27;NotADirectoryError&#x27;, &#x27;NotImplemented&#x27;, &#x27;NotImplementedError&#x27;, &#x27;OSError&#x27;, &#x27;OverflowError&#x27;, &#x27;PendingDeprecationWarning&#x27;, </span><br><span class="line">&#x27;PermissionError&#x27;, &#x27;ProcessLookupError&#x27;, &#x27;RecursionError&#x27;, &#x27;ReferenceError&#x27;, &#x27;ResourceWarning&#x27;, &#x27;RuntimeError&#x27;, &#x27;RuntimeWarning&#x27;, &#x27;StopAsyncIteration&#x27;, &#x27;StopIteration&#x27;, </span><br><span class="line">&#x27;SyntaxError&#x27;, &#x27;SyntaxWarning&#x27;, &#x27;SystemError&#x27;, &#x27;SystemExit&#x27;, &#x27;TabError&#x27;, &#x27;TimeoutError&#x27;, &#x27;True&#x27;, &#x27;TypeError&#x27;, &#x27;UnboundLocalError&#x27;, &#x27;UnicodeDecodeError&#x27;, </span><br><span class="line">&#x27;UnicodeEncodeError&#x27;, &#x27;UnicodeError&#x27;, &#x27;UnicodeTranslateError&#x27;, &#x27;UnicodeWarning&#x27;, &#x27;UserWarning&#x27;, &#x27;ValueError&#x27;, &#x27;Warning&#x27;, </span><br><span class="line">&#x27;WindowsError&#x27;, &#x27;ZeroDivisionError&#x27;, &#x27;__build_class__&#x27;, &#x27;__debug__&#x27;, &#x27;__doc__&#x27;, &#x27;__import__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, </span><br><span class="line">&#x27;abs&#x27;, &#x27;all&#x27;, &#x27;any&#x27;, &#x27;ascii&#x27;, &#x27;bin&#x27;, &#x27;bool&#x27;, &#x27;breakpoint&#x27;, &#x27;bytearray&#x27;, &#x27;bytes&#x27;, &#x27;callable&#x27;, &#x27;chr&#x27;, </span><br><span class="line">&#x27;classmethod&#x27;, &#x27;compile&#x27;, &#x27;complex&#x27;, &#x27;copyright&#x27;, &#x27;credits&#x27;, &#x27;delattr&#x27;, &#x27;dict&#x27;, &#x27;dir&#x27;, &#x27;divmod&#x27;, &#x27;enumerate&#x27;, &#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;exit&#x27;, &#x27;filter&#x27;, &#x27;float&#x27;, &#x27;format&#x27;, &#x27;frozenset&#x27;, </span><br><span class="line">&#x27;getattr&#x27;, &#x27;globals&#x27;, &#x27;hasattr&#x27;, &#x27;hash&#x27;, &#x27;help&#x27;, &#x27;hex&#x27;, &#x27;id&#x27;, &#x27;input&#x27;, </span><br><span class="line">&#x27;int&#x27;, &#x27;isinstance&#x27;, &#x27;issubclass&#x27;, &#x27;iter&#x27;, &#x27;len&#x27;, &#x27;license&#x27;, &#x27;list&#x27;, &#x27;locals&#x27;, &#x27;map&#x27;, &#x27;max&#x27;, &#x27;memoryview&#x27;, &#x27;min&#x27;, &#x27;next&#x27;, &#x27;object&#x27;, &#x27;oct&#x27;, &#x27;open&#x27;, &#x27;ord&#x27;, &#x27;pow&#x27;, &#x27;print&#x27;, &#x27;property&#x27;, </span><br><span class="line">&#x27;quit&#x27;, &#x27;range&#x27;, &#x27;repr&#x27;, &#x27;reversed&#x27;, &#x27;round&#x27;, &#x27;set&#x27;, &#x27;setattr&#x27;, &#x27;slice&#x27;, &#x27;sorted&#x27;, &#x27;staticmethod&#x27;, &#x27;str&#x27;, &#x27;sum&#x27;, &#x27;super&#x27;, &#x27;tuple&#x27;, &#x27;type&#x27;, &#x27;vars&#x27;, &#x27;zip&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="1-3-查看-Python-官方文档"><a href="#1-3-查看-Python-官方文档" class="headerlink" title="1.3 查看 Python 官方文档"></a>1.3 查看 Python 官方文档</h3><p>打开 IDLE，依次点击右上角的 “Help” -&gt; “Python Docs”（或者直接按下快捷键F1）：<br><img src="/image/help.png" alt="查看帮助文档"></p>
<p>这就弹出了一个叫 Python Documentation 的帮助文档，点击左上角的“索引”，然后输入想要查询的关键字:<br><img src="/image/help1.png" alt="文档界面"></p>
<p>或者直接在交互界面输出 <code>help(obj)</code> 查询:<br><img src="/image/help2.png" alt="help(obj)"></p>
<h2 id="2-变量与字符串"><a href="#2-变量与字符串" class="headerlink" title="2.变量与字符串"></a>2.变量与字符串</h2><h3 id="2-1-1-变量"><a href="#2-1-1-变量" class="headerlink" title="2.1.1 变量"></a>2.1.1 变量</h3><p>在 Python 中，变量就是一个名字。</p>
<p>变量就是一个名字，一个标签，通过这个变量，你就能找到对应的数据。</p>
<h3 id="2-1-2-创建一个变量"><a href="#2-1-2-创建一个变量" class="headerlink" title="2.1.2 创建一个变量"></a>2.1.2 创建一个变量</h3><p>Python 的变量无需声明，只需要一次赋值，该变量就能够被成功创建：<br><code>&gt;&gt;&gt;  x = 8 </code><br>这样我们就创建了一个变量，它的名字叫做x，它的值是8。<br>那么这个等于号（&#x3D;），表示的是一个赋值操作，也就是将右边的数值8跟变量名x进行挂钩的意思。</p>
<h3 id="2-1-3-访问一个变量"><a href="#2-1-3-访问一个变量" class="headerlink" title="2.1.3 访问一个变量"></a>2.1.3 访问一个变量</h3><p>当一个变量被创建之后，使用变量名就可以直接访问该变量了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-变量名"><a href="#2-1-4-变量名" class="headerlink" title="2.1.4 变量名"></a>2.1.4 变量名</h3><p>变量名呢，通常是由字母、数字和下划线（_）构成，但千万不能以数字打头，比如 fuckyou567 是合法的变量名，而 789bitch 却是非法的。<br><img src="/image/%E5%8F%98%E9%87%8F.png" alt="变量名"><br>另外，变量名是区分大小写的，也就是 FucK、fuck 在 Python 看来，是两个完全不同的名字。</p>
<p>Python3 还支持中文字符作为变量名，是的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">唐僧 = 81</span><br><span class="line">print(唐僧)</span><br><span class="line">81</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-字符串（Double-quotes）"><a href="#2-2-1-字符串（Double-quotes）" class="headerlink" title="2.2.1 字符串（Double quotes）"></a>2.2.1 字符串（Double quotes）</h3><p>Double quotes 就是使用一对双引号将文本包含起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;I love Pyhton&quot;)</span><br><span class="line">I love Python</span><br></pre></td></tr></table></figure>
<p>混合使用 Single quotes 和 Double quotes 的技巧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&quot;Let&#x27;s go!&quot;)</span><br><span class="line">Let&#x27;s go!</span><br><span class="line">&gt;&gt;&gt; print(&#x27;&quot;Life is short, you need Python.&quot;&#x27;)</span><br><span class="line">&quot;Life is short, you need Python.&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-转义字符"><a href="#2-2-2-转义字符" class="headerlink" title="2.2.2 转义字符"></a>2.2.2 转义字符</h3><p><img src="/image/%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6.png" alt="转义字符"></p>
<h3 id="2-2-3-原始字符串"><a href="#2-2-3-原始字符串" class="headerlink" title="2.2.3 原始字符串"></a>2.2.3 原始字符串</h3><p>使用原始字符串，可以避免反斜杠（\）被当作转义字符解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 未使用原始字符串</span><br><span class="line">&gt;&gt;&gt; print(&quot;D:\three\two\one\now&quot;)</span><br><span class="line">D:        hree        wo\one</span><br><span class="line">ow</span><br><span class="line">&gt;&gt;&gt; # 使用原始字符串</span><br><span class="line">&gt;&gt;&gt; print(r&quot;D:\three\two\one\now&quot;)</span><br><span class="line">D:\three\two\one\now</span><br></pre></td></tr></table></figure>
<p>多次换行可以在换行符 (\n) 再加一个反斜杠 <code>(\n\)</code> ：<br><img src="/image/%E6%8D%A2%E8%A1%8C.png" alt="多次换行"></p>
<h3 id="2-2-4-长字符串（Triple-quotes）"><a href="#2-2-4-长字符串（Triple-quotes）" class="headerlink" title="2.2.4 长字符串（Triple quotes）"></a>2.2.4 长字符串（Triple quotes）</h3><p>通常，使用三引号（单引号，双引号都可以——首尾呼应）字符串来引用多行文本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; demo = &quot;&quot;&quot;</span><br><span class="line">知世故而不世故，</span><br><span class="line">弥天真而芬芳。</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-字符串加法和乘法"><a href="#2-2-5-字符串加法和乘法" class="headerlink" title="2.2.5 字符串加法和乘法"></a>2.2.5 字符串加法和乘法</h3><p>字符串相加我们叫做拼接，就是将字符串组合成一个长的新的字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;365&#x27; + &#x27;258&#x27;</span><br><span class="line">&#x27;365258&#x27;</span><br></pre></td></tr></table></figure>
<p>还可以使用乘法符号（*）进行复制。<br>比如被老师罚写名字三百遍：<br><img src="/image/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B9%98%E6%B3%95.png" alt="字符串乘法"></p>
<h2 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h2><h3 id="3-1-赋值运算符"><a href="#3-1-赋值运算符" class="headerlink" title="3.1 赋值运算符"></a>3.1 赋值运算符</h3><p>单独一个等于号（&#x3D;）表示赋值运算符，作用是将右边的值跟左边的变量名进行挂钩。</p>
<h3 id="3-2-将字符串转换为整数"><a href="#3-2-将字符串转换为整数" class="headerlink" title="3.2 将字符串转换为整数"></a>3.2 将字符串转换为整数</h3><p>使用 int() 函数将指定的值转换成整数。</p>
<p>但要注意，并不是所有的字符串都能够转换为整数，比如 int(“Fuck”) 是无法转换的</p>
<h3 id="3-3-比较运算符"><a href="#3-3-比较运算符" class="headerlink" title="3.3 比较运算符"></a>3.3 比较运算符</h3><p><img src="/image/%E8%BF%90%E7%AE%97%E7%AC%A6.png" alt="运算符"></p>
<h3 id="3-4-is-同一性运算符"><a href="#3-4-is-同一性运算符" class="headerlink" title="3.4 is 同一性运算符"></a>3.4 <code>is</code> 同一性运算符</h3><p>is 运算符也称之为同一性运算符。<br>它是用于检验两个变量，是否指向同一个对象(内存)的运算符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = &#x27;mortal&#x27;</span><br><span class="line">y = &#x27;mortal&#x27;</span><br><span class="line">x is y</span><br></pre></td></tr></table></figure>


<h2 id="4-数字类型"><a href="#4-数字类型" class="headerlink" title="4. 数字类型"></a>4. 数字类型</h2><p>Python 有三种不同的数字类型，分别是：整数、浮点数和复数。</p>
<h3 id="4-1-1-整数-integer"><a href="#4-1-1-整数-integer" class="headerlink" title="4.1.1 整数 (integer)"></a>4.1.1 整数 (integer)</h3><p>Python 的整数长度是不受限制的，也就是说它是有无限大的精度。<br>所以，你可以随时随地的进行大数运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1568743148/115487896</span><br><span class="line">13.583615273413589</span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-浮点数"><a href="#4-1-2-浮点数" class="headerlink" title="4.1.2 浮点数"></a>4.1.2 浮点数</h3><p>我们通常数学意义上的小数在编程里叫浮点数。<br>由于浮点数在计算机中的存储是存在 “误差” 的，所以有时候可能会闹出一些 “BUG”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0.1 + 0.2</span><br><span class="line">0.30000000000000004</span><br></pre></td></tr></table></figure>

<p>由于浮点数并不是 100% 精确的，所以我们拿浮点数来做比较就要特别小心了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 0.3 == 0.1 + 0.2</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>可以借助<code>decimal</code>模块来进行十进制的运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import decimal</span><br><span class="line">&gt;&gt;&gt; a = decimal.Decimal(&quot;0.1&quot;)</span><br><span class="line">&gt;&gt;&gt; b = decimal.Decimal(&quot;0.2&quot;)</span><br><span class="line">&gt;&gt;&gt; print(a + b)</span><br><span class="line">0.3</span><br><span class="line">c = decimal.Decimal(&#x27;0.3&#x27;)</span><br><span class="line">a + b == c</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-E记法"><a href="#4-1-3-E记法" class="headerlink" title="4.1.3 E记法"></a>4.1.3 E记法</h3><p>E 记法也就是平时我们所说的科学计数法，用于表示一些比较极端的数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 0.00005</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">5e-05</span><br></pre></td></tr></table></figure>

<h3 id="4-1-4-复数"><a href="#4-1-4-复数" class="headerlink" title="4.1.4 复数"></a>4.1.4 复数</h3><p>复数包含了一个实部和一个虚部：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 + 2j</span><br><span class="line">(1+2j)</span><br></pre></td></tr></table></figure>
<p>它们都是以浮点数的形式存放的，如果将一个复数赋值给一个变量 x，则可以通过 x.real 访问该复数的实部，x.imag 访问其虚部：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 1 + 2j</span><br><span class="line">&gt;&gt;&gt; x.real</span><br><span class="line">1.0</span><br><span class="line">&gt;&gt;&gt; x.imag</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure>

<h3 id="4-2-数字运算"><a href="#4-2-数字运算" class="headerlink" title="4.2 数字运算"></a>4.2 数字运算</h3><p>Python 支持的数字运算如下：<br><img src="/image/%E6%95%B0%E5%AD%97%E8%BF%90%E7%AE%97.jpg" alt="数字运算"></p>
<h4 id="4-2-1-四则运算"><a href="#4-2-1-四则运算" class="headerlink" title="4.2.1 四则运算"></a>4.2.1 四则运算</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 + 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; 1 - 2</span><br><span class="line">-1</span><br><span class="line">&gt;&gt;&gt; 1 * 2</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 1 / 2</span><br><span class="line">0.5</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-地板除"><a href="#4-2-2-地板除" class="headerlink" title="4.2.2 地板除"></a>4.2.2 地板除</h4><p>双斜杠（&#x2F;&#x2F;）表示一种特殊的除法 —— 地板除。<br>地板除原理是<strong>取比目标结果小的最大整数</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 // 2</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; -3 // 2</span><br><span class="line">-2</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-取余"><a href="#4-2-3-取余" class="headerlink" title="4.2.3 取余"></a>4.2.3 取余</h4><p>百分号（%）用于求两数相除的余数，如果能够整除，则余数为 0：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 % 2</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 6 % 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-被除数"><a href="#4-2-4-被除数" class="headerlink" title="4.2.4 被除数"></a>4.2.4 被除数</h4><p>地板除的结果乘以除数 + 余数 &#x3D; 被除数：<br><code>x == (x // y) * y + (x % y)</code></p>
<h4 id="4-2-5-divmod-函数"><a href="#4-2-5-divmod-函数" class="headerlink" title="4.2.5 divmod() 函数"></a>4.2.5 divmod() 函数</h4><p>Python 有个内置函数叫 divmod()，它的作用就是同时求出两参数地板除的结果和余数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; divmod(3, 2)</span><br><span class="line">(1, 1)</span><br><span class="line">&gt;&gt;&gt; divmod(-3, 2)</span><br><span class="line">(-2, 1)</span><br></pre></td></tr></table></figure>

<h4 id="4-2-6-abs-函数"><a href="#4-2-6-abs-函数" class="headerlink" title="4.2.6 abs()函数"></a>4.2.6 abs()函数</h4><p><strong>abs()</strong> 函数的作用是返回指定数值的绝对值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = -520</span><br><span class="line">&gt;&gt;&gt; abs(x)</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; y = -3.14</span><br><span class="line">&gt;&gt;&gt; abs(y)</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure>
<p>如果传入的是一个复数，abs() 函数返回的结果就是<em>复数的模</em>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; z = 1 + 2j</span><br><span class="line">&gt;&gt;&gt; abs(z)</span><br><span class="line">2.23606797749979</span><br></pre></td></tr></table></figure>

<h4 id="4-2-7-int-float-和-complex-函数"><a href="#4-2-7-int-float-和-complex-函数" class="headerlink" title="4.2.7 int() float() 和 complex() 函数"></a>4.2.7 int() float() 和 complex() 函数</h4><p>int() 函数是将指定的值转换成整数，比如我们传入一个字符串 ‘250’，那么得到结果就是一个整数 250：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(&#x27;250&#x27;)</span><br><span class="line">250</span><br></pre></td></tr></table></figure>
<p>不过如果参数是一个浮点数，那么就要注意了，因为它得到的将是一个截掉小数的整数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; int(3.14)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; int(9.99)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意：它是直接截取整数部分，扔掉小数部分，而不是四舍五入。</strong><br>同样的道理，float() 和 complex() 函数是将指定的值转换成浮点数和复数</li>
</ul>
<h4 id="4-2-8-pow-函数和幂运算符（-）"><a href="#4-2-8-pow-函数和幂运算符（-）" class="headerlink" title="4.2.8 pow() 函数和幂运算符（**）"></a>4.2.8 pow() 函数和幂运算符（**）</h4><p>通常情况下，pow() 函数和幂运算符（**）这两个实现的效果是等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pow(2, 3)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; 2 ** 3</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; pow(2, -3)</span><br><span class="line">0.125</span><br><span class="line">&gt;&gt;&gt; 2 ** -3</span><br><span class="line">0.125</span><br></pre></td></tr></table></figure>
<p>不过，pow() 函数还留有一手，它支持第 3 个参数。<br>如果传入第 3 个参数，那么会将幂运算的结果和第 3 个参数进行取余数运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pow(2, 3, 3)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>相当于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 2 ** 3 % 3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="5-布尔类型"><a href="#5-布尔类型" class="headerlink" title="5. 布尔类型"></a>5. 布尔类型</h2><p>布尔类型的值只有两个：True 或者 False，也就是 “真” 或者 “假”。</p>
<h3 id="5-1-bool-函数"><a href="#5-1-bool-函数" class="headerlink" title="5.1 bool() 函数"></a>5.1 bool() 函数</h3><p>使用 <code>bool()</code> 函数可以直接给出 True 或者 False 的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bool(250)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; bool(&quot;假&quot;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; bool(&quot;False&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h3 id="5-2-真真假假"><a href="#5-2-真真假假" class="headerlink" title="5.2 真真假假"></a>5.2 真真假假</h3><p>结果是 True 的情况非常多，但 False 却是屈指可数，下面这些几乎就是结果为 False 的所有情况：</p>
<ul>
<li>定义为False的对象：None 和 False</li>
<li>值为 0 的数字类型：0, 0.0, 0j, Decimal(0), Fraction(0, 1)</li>
<li>空的序列和集合：’’, (), [], {}, set(), range(0)</li>
</ul>
<h3 id="5-3-真值检测"><a href="#5-3-真值检测" class="headerlink" title="5.3 真值检测"></a>5.3 真值检测</h3><p>Python 中任何对象都能直接进行<strong>真值检测</strong>（测试该对象的布尔类型值为 True 或者 False），用于 if 或者 while 语句的条件判断，也可以做为布尔逻辑运算符的操作数。</p>
<h3 id="5-3-逻辑运算符"><a href="#5-3-逻辑运算符" class="headerlink" title="5.3 逻辑运算符"></a>5.3 逻辑运算符</h3><p>Python 总共有三个逻辑运算符：and、or 和 not。<br><img src="/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.jgp" alt="逻辑运算符"></p>
<p>对于 and 和 or 运算符，它的计算结果不一定是 True 或者 False。</p>
<p>这要看它的操作数是什么了，如果你给到操作数的是两个数值，那么它的运算结果也是数值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 and 4</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; 4 or 5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>如果你给到操作数的是两个字符串，那么它的结果也是字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;Mortal&quot; and &quot;LOVE&quot;</span><br><span class="line">&#x27;LOVE&#x27;</span><br></pre></td></tr></table></figure>
<p>如歌你给到操作数是字符串和数值， <code>and</code> 时为数值, <code>or</code> 时为字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;&quot;Mortal&quot; and 250</span><br><span class="line">250</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &quot;Mortal&quot; or 350</span><br><span class="line">&#x27;Mortal&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-短路逻辑"><a href="#5-4-短路逻辑" class="headerlink" title="5.4 短路逻辑"></a>5.4 短路逻辑</h3><p>and 和 or 这两个运算符都是遵从短路逻辑的。<br>短路逻辑的核心思想就是：从左往右，只有当第一个操作数的值无法确定逻辑运算的结果时，才对第二个操作数进行求值。</p>
<ul>
<li><code>and</code> 同为真时 返回 <strong>True</strong>。 </li>
<li><code>or</code>  两边只要有一个是 True 那么结果就是 <strong>True</strong>.<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 5 and 6         # 5 为True不能确定结果，继续执行 6 最终返回结果6</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 5 or 6      # 5 为 Ture 可以确定结果，直接返回 5</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 and 5     # 0 为 False 可以确定结果，直接返回 0</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 0 or 6      # 0 为 False 无法确定结果，继续执行 6 ，6 为True 返回结果 6</span><br><span class="line">6</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-运算符优先级"><a href="#6-运算符优先级" class="headerlink" title="6. 运算符优先级"></a>6. 运算符优先级</h2><p>这个表格从低到高（<strong>↓</strong>）列出了 Python 的运算符优先级：</p>
<table>
<thead>
<tr>
<th>优先级</th>
<th align="center">运算符</th>
<th align="right">描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td align="center">lambda</td>
<td align="right">Lambda表达式</td>
</tr>
<tr>
<td>2</td>
<td align="center">if - else</td>
<td align="right">条件表达式</td>
</tr>
<tr>
<td>3</td>
<td align="center">or</td>
<td align="right">布尔“或”</td>
</tr>
<tr>
<td>4</td>
<td align="center">and</td>
<td align="right">布尔“与”</td>
</tr>
<tr>
<td>5</td>
<td align="center">not x</td>
<td align="right">布尔“非”</td>
</tr>
<tr>
<td>6</td>
<td align="center">in, not in, is, is not, &lt;, &lt;&#x3D;,&gt;, &gt;&#x3D;, !&#x3D;, &#x3D;&#x3D;</td>
<td align="right">成员测试，同一性测试，比较</td>
</tr>
<tr>
<td>7</td>
<td align="center">&#96;</td>
<td align="right">&#96;</td>
</tr>
<tr>
<td>8</td>
<td align="center">^</td>
<td align="right">按位异或</td>
</tr>
<tr>
<td>9</td>
<td align="center">&amp;</td>
<td align="right">按位与</td>
</tr>
<tr>
<td>10</td>
<td align="center">&lt;&lt;, &gt;&gt;</td>
<td align="right">移位</td>
</tr>
<tr>
<td>11</td>
<td align="center">+, -</td>
<td align="right">加法，减法</td>
</tr>
<tr>
<td>12</td>
<td align="center">*, @, &#x2F;, &#x2F;&#x2F;, %</td>
<td align="right">乘法，矩阵乘法，除法，地板除，取余数</td>
</tr>
<tr>
<td>13</td>
<td align="center">+x，-x, ~x</td>
<td align="right">正号，负号，按位翻转</td>
</tr>
<tr>
<td>14</td>
<td align="center">**</td>
<td align="right">指数</td>
</tr>
<tr>
<td>15</td>
<td align="center">await x</td>
<td align="right">Await表达式</td>
</tr>
<tr>
<td>16</td>
<td align="center">x[index], x[index:index],x(arguments…), x.attribute</td>
<td align="right">下标，切片，函数调用，属性引用</td>
</tr>
<tr>
<td>17</td>
<td align="center">(expressions…), [expressions…],{key: value…}, {expressions…}</td>
<td align="right">绑定或元组显示，列表显示，字典显示，集合显示</td>
</tr>
</tbody></table>
<h2 id="7-分支和循环-branch-and-loop"><a href="#7-分支和循环-branch-and-loop" class="headerlink" title="7. 分支和循环 (branch and loop)"></a>7. 分支和循环 (branch and loop)</h2><h3 id="7-1-分支结构"><a href="#7-1-分支结构" class="headerlink" title="7.1 分支结构"></a>7.1 分支结构</h3><p>Python 的分支结构由 if 语句来操刀实现。<br>if 语句总共有 5 钟语法结构，其中前 4 种是比较常见的。</p>
<p>第 1 种是判断一个条件，如果这个条件成立，就执行其包含的某条语句或某个代码块。<br>语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure>

<p>第 2 种同样是判断一个条件，跟第 1 种的区别是如果条件不成立，则执行另外的某条语句或某个代码块。<br>语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 条件:</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">else:</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure>

<p>第 3 种是判断多个条件，如果第 1 个条件不成立，则继续判断第 2 个条件，如果第 2 个条件还不成立，则接着判断第 3 个条件……<br>如果还有第 4、5、6、7、8、9 个条件，你还可以继续写下去。<br>语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if 第1个条件:</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">elif 第2个条件:</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">elif 第3个条件：</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure>

<p>第 4 种是在第 3 种的情况下添加一个 else，表示上面所有的条件均不成立的情况下，执行某条语句或某个代码块。<br>语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 第1个条件:</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">elif 第2个条件:</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">elif 第3个条件：</span><br><span class="line">    某条语句或某个代码块</span><br><span class="line">else:</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure>

<p>第 5 种其实是一个条件表达式，相当于将一个完整的 if-else 结构整合成一个表达式来使用。<br>语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件成立时执行的语句 if 条件 else 条件不成立时执行的语句</span><br></pre></td></tr></table></figure>
<p>它把条件放正中间，然后左右紧挨着关键字 if 和 else，最左侧是条件成立时执行的语句，最右侧是条件不成立时执行的语句。<br>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a = 3</span><br><span class="line">&gt;&gt;&gt; b = 5</span><br><span class="line">&gt;&gt;&gt; small = a if a &lt; b else b</span><br><span class="line">&gt;&gt;&gt; print(small)</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="7-2-分支结构的嵌套-nested-branches"><a href="#7-2-分支结构的嵌套-nested-branches" class="headerlink" title="7.2 分支结构的嵌套(nested branches)"></a>7.2 分支结构的嵌套(nested branches)</h3><p>所谓嵌套，就是跟俄罗斯套娃一样，一层套一层。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; age = 18</span><br><span class="line">&gt;&gt;&gt; isGamer = True</span><br><span class="line">&gt;&gt;&gt; if age &lt; 18:</span><br><span class="line">...     print(&quot;抱歉，本游戏不适合未成年。&quot;)</span><br><span class="line">... else:</span><br><span class="line">...     if isGamer:</span><br><span class="line">...         print(&quot;游戏愉快！&quot;)</span><br><span class="line">...     else:</span><br><span class="line">...         print(&quot;抱歉，本游戏不适合非专业选手哦~&quot;)</span><br><span class="line"></span><br><span class="line">游戏愉快！</span><br></pre></td></tr></table></figure>

<h3 id="7-3-循环结构"><a href="#7-3-循环结构" class="headerlink" title="7.3 循环结构"></a>7.3 循环结构</h3><p>分支结构能让你的程序根据条件去做不同的事情，而循环机构能让你的程序去不断做同一件事情，这就是所谓的道不同而一样很牛逼啦！</p>
<p>Python 有两种循环语句：while 循环和 for 循环。</p>
<h4 id="7-3-1-while-循环"><a href="#7-3-1-while-循环" class="headerlink" title="7.3.1 while 循环"></a>7.3.1 <code>while</code> 循环</h4><p>它的语法结构结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while 条件:</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure>

<p>只要条件一直成立，那么其包含的某条语句或某个代码块就会一直被执行。</p>
<h4 id="7-3-2-死循环"><a href="#7-3-2-死循环" class="headerlink" title="7.3.2 死循环"></a>7.3.2 死循环</h4><p>如果条件一直成立，那么循环体就一直被执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; while True:</span><br><span class="line">...     print(&quot;只要条件成立，我就循环到你死机！&quot;)</span><br></pre></td></tr></table></figure>
<p>像这种倔强的循环，我们给他起了一个不大好听的名字：死循环。<br>所谓的死循环，就是打死也不会结束的循环。</p>
<h4 id="7-3-3-break-语句"><a href="#7-3-3-break-语句" class="headerlink" title="7.3.3 break 语句"></a>7.3.3 <strong>break</strong> 语句</h4><p>在循环体内，一旦遇到 break 语句，Python 二话不说马上就会跳出循环体，即便这时候循环体内还有待执行的语句。</p>
<h4 id="7-3-4-continue-语句"><a href="#7-3-4-continue-语句" class="headerlink" title="7.3.4 continue 语句"></a>7.3.4 <strong>continue</strong> 语句</h4><p>实现跳出循环体还有另外一个语句，那就是 continue 语句。<br>continue 语句也会跳出循环体，但是，它只是跳出本一轮循环，它还会回到循环体的条件判断位置，然后继续下一轮循环（如果条件还满足的话）。</p>
<p>注意它和 break 语句两者的区别：</p>
<ul>
<li>continue 语句是跳出本次循环，回到循环的开头</li>
<li>break 语句则是直接跳出循环体，继续执行后面的语句<br><img src="/image/countine.jpg" alt="countine"></li>
</ul>
<h4 id="7-3-5-else-语句"><a href="#7-3-5-else-语句" class="headerlink" title="7.3.5 else 语句"></a>7.3.5 <strong>else</strong> 语句</h4><p>当循环的条件不再为真的时候，便执行 else 语句的内容。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; i = 1</span><br><span class="line">&gt;&gt;&gt; while i &lt; 3:</span><br><span class="line">...     print(&quot;循环内，i 的值是&quot;, i)</span><br><span class="line">...     i += 1</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;循环外, i 的值是&quot;, i)</span><br><span class="line">... </span><br><span class="line">...     </span><br><span class="line">循环内，i 的值是 1</span><br><span class="line">循环内，i 的值是 2</span><br><span class="line">循环外, i 的值是 3</span><br></pre></td></tr></table></figure>

<p><em><strong>小技巧</strong></em></p>
<p>while-else 可以非常容易地检测到循环的退出情况。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; this = 1</span><br><span class="line">&gt;&gt;&gt; while this &lt;= 5:</span><br><span class="line">...     answer = input(&quot;是否this?&quot;)</span><br><span class="line">...     if answer != &quot;是&quot;:</span><br><span class="line">...         break</span><br><span class="line">...     this += 1</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;好的，你已经坚持了5次&quot;)</span><br><span class="line">... </span><br><span class="line">...     </span><br><span class="line">是否this?是</span><br><span class="line">是否this?是</span><br><span class="line">是否this?是</span><br><span class="line">是否this?否</span><br></pre></td></tr></table></figure>

<h4 id="7-3-6-嵌套"><a href="#7-3-6-嵌套" class="headerlink" title="7.3.6 嵌套"></a>7.3.6 嵌套</h4><p>循环也也可以嵌套，而且更简洁！</p>
<p>有时候，我们的需求可能要用到不止一层循环来实现。</p>
<p>比如我们要实现打印一个九九乘法表，就可以这么实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; i = 1</span><br><span class="line">&gt;&gt;&gt; while i &lt;= 9:</span><br><span class="line">...     j = 1</span><br><span class="line">...     while j &lt;= i:</span><br><span class="line">...         print(j, &quot;*&quot;, i, &quot;=&quot;, j * i, end=&quot; &quot;)</span><br><span class="line">...         j += 1</span><br><span class="line">...     print()</span><br><span class="line">...     i += 1</span><br><span class="line">...</span><br><span class="line">1 * 1 = 1 </span><br><span class="line">1 * 2 = 2 2 * 2 = 4 </span><br><span class="line">1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 </span><br><span class="line">1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 </span><br><span class="line">1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 </span><br><span class="line">1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 </span><br><span class="line">1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 </span><br><span class="line">1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 </span><br><span class="line">1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 </span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意</strong>: 对于嵌套循环来说，无论是 break 语句还是 continue 语句，它们只能作用于一层循环体。</li>
</ul>
<h4 id="7-3-7-for-循环"><a href="#7-3-7-for-循环" class="headerlink" title="7.3.7 for 循环"></a>7.3.7 <strong>for</strong> 循环</h4><p>语法结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for 变量 in 可迭代对象:</span><br><span class="line">    某条语句或某个代码块</span><br></pre></td></tr></table></figure>

<p>什么是可迭代对象？<br>所谓可迭代对象，就是指那些元素能够被单独提取出来的对象。比如我们学过的字符串，它就是一个可迭代对象。</p>
<p>什么叫迭代呢？<br>比如说让你每一次从字符串 “Mortal” 里面拿一个字符出来，那么你依次会拿出 ‘M’、’o’、’r’、’t’、’a’、’l’ 六个字符，这个过程我们称之为迭代。</p>
<h4 id="7-3-8-range"><a href="#7-3-8-range" class="headerlink" title="7.3.8 range()"></a>7.3.8 <strong>range()</strong></h4><p>range() 会帮你生成一个数字序列，它的用法有以下三种：</p>
<ul>
<li>range(stop) - 将生成一个从 0 开始，到 stop（不包含）的整数数列</li>
<li>range(start, stop) - 将生成一个从 start 开始，到 stop（不包含）的整数数列</li>
<li>range(start, stop, step) - 将生成一个从 start 开始，到 stop（不包含）结束，步进跨度为 step 的整数数列</li>
</ul>
<p><strong>注意</strong>：无论你使用哪一种，它的参数都只能是整数。</p>
<h4 id="7-3-9-for-循环和-while-循环的共通性"><a href="#7-3-9-for-循环和-while-循环的共通性" class="headerlink" title="7.3.9 for 循环和 while 循环的共通性"></a>7.3.9 for 循环和 while 循环的共通性</h4><p>for 循环和 while 循环一样，都是可以支持嵌套的，同样它也可以搭配 break 和 continue 语句。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for n in range(2, 10):</span><br><span class="line">...     for x in range(2, n):</span><br><span class="line">...         if n % x == 0:</span><br><span class="line">...             print(n, &quot;=&quot;, x, &quot;*&quot;, n // x)</span><br><span class="line">...             break</span><br><span class="line">...     else:</span><br><span class="line">...         print(n, &quot;是一个素数&quot;)</span><br><span class="line">...</span><br><span class="line">2 是一个素数</span><br><span class="line">3 是一个素数</span><br><span class="line">4 = 2 * 2</span><br><span class="line">5 是一个素数</span><br><span class="line">6 = 2 * 3</span><br><span class="line">7 是一个素数</span><br><span class="line">8 = 2 * 4</span><br><span class="line">9 = 3 * 3</span><br></pre></td></tr></table></figure>

<h2 id="8-列表"><a href="#8-列表" class="headerlink" title="8. 列表"></a>8. 列表</h2><h3 id="8-1-创建列表"><a href="#8-1-创建列表" class="headerlink" title="8.1 创建列表"></a>8.1 创建列表</h3><p>创建一个列表非常简单，我们只需要使用中括号，将所有准备放入列表中的元素给包裹起来，不同元素之间使用逗号分隔：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rhyme = [1, 2, 3, 4, 5, &quot;上山打老虎&quot;]</span><br><span class="line">&gt;&gt;&gt; print(rhyme)</span><br><span class="line">[1, 2, 3, 4, 5, &#x27;上山打老虎&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="8-2-访问列表中的元素"><a href="#8-2-访问列表中的元素" class="headerlink" title="8.2 访问列表中的元素"></a>8.2 访问列表中的元素</h3><p>如果希望按顺序访问列表的每一个元素，可以使用 for 循环语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for each in rhyme:</span><br><span class="line">...     print(each)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">上山打老虎</span><br></pre></td></tr></table></figure>
<p>如果希望随机访问其中一个元素，那么可以使用下标索引的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rhyme[0]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; rhyme[2]</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; rhyme[5]</span><br><span class="line">&#x27;上山打老虎&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-下标索引"><a href="#8-3-下标索引" class="headerlink" title="8.3 下标索引"></a>8.3 下标索引</h3><p>序列类型的数据都可以使用下标索引的方法，第一个元素的下标是 0，第二个的下标是 1，以此类推：<br><img src="/image/%E4%B8%8B%E8%A1%A8%E7%B4%A2%E5%BC%951.jpg" alt="下表索引"><br>Python 还支持你 “倒着” 进行索引：<br><img src="/image/%E4%B8%8B%E8%A1%A8%E7%B4%A2%E5%BC%952.jpg" alt="下表索引2"></p>
<h3 id="8-4-列表切片"><a href="#8-4-列表切片" class="headerlink" title="8.4 列表切片"></a>8.4 列表切片</h3><p>将原先的单个索引值改成一个范围即可实现切片：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; rhyme[0:3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; rhyme[3:6]</span><br><span class="line">[4, 5, &#x27;上山打老虎&#x27;]</span><br><span class="line">&gt;&gt;&gt; rhyme[:3]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; rhyme[3:]</span><br><span class="line">[4, 5, &#x27;上山打老虎&#x27;]</span><br><span class="line">&gt;&gt;&gt; rhyme[:]</span><br><span class="line">[1, 2, 3, 4, 5, &#x27;上山打老虎&#x27;]</span><br><span class="line">&gt;&gt;&gt; rhyme[0:6:2]</span><br><span class="line">[1, 3, 5]</span><br><span class="line">&gt;&gt;&gt; rhyme[::2]</span><br><span class="line">[1, 3, 5]</span><br><span class="line">&gt;&gt;&gt; rhyme[::-2]</span><br><span class="line">[&#x27;上山打老虎&#x27;, 4, 2]</span><br><span class="line">&gt;&gt;&gt; rhyme[::-1]</span><br><span class="line">[&#x27;上山打老虎&#x27;, 5, 4, 3, 2, 1]</span><br></pre></td></tr></table></figure>
<p><strong>切片是一个非常棒的技能</strong></p>
<h3 id="8-5-列表的增删改查"><a href="#8-5-列表的增删改查" class="headerlink" title="8.5 列表的增删改查"></a>8.5 列表的增删改查</h3><h4 id="8-5-1-增（像列表添加数据）"><a href="#8-5-1-增（像列表添加数据）" class="headerlink" title="8.5.1 增（像列表添加数据）"></a>8.5.1 增（像列表添加数据）</h4><p>向列表添加元素可以使用 append() 方法，它的功能是在列表的末尾添加一个指定的元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.append(&quot;egg&quot;)</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[&#x27;milk&#x27;, &#x27;bread&#x27;, &#x27;egg&#x27;]</span><br></pre></td></tr></table></figure>
<p>append() 方法虽好，不过每次它只能添加一个元素到列表中，而 extend() 方法则允许一次性添加多个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.extend([&quot;cake&quot;, &quot;rice&quot;, &quot;vagetables&quot;])</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[&#x27;milk&#x27;, &#x27;bread&#x27;, &#x27;egg&#x27;, &#x27;cake&#x27;, &#x27;rice&#x27;, &#x27;vagetables&#x27;]</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意：</strong>extend() 方法的参数必须是一个可迭代对象，然后新的内容是追加到原列表最后一个元素的后面。</li>
</ul>
<p>使用万能的切片语法，也可以实现列表元素的添加：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; # 下面的做法等同于 s.append(6)</span><br><span class="line">&gt;&gt;&gt; s[len(s):] = [6]</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; # 下面的做法等同于 s.extend([7, 8, 9])</span><br><span class="line">&gt;&gt;&gt; s[len(s):] = [7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">[1, 2, 3, 4, 5, 6, 7, 8, 9]</span><br></pre></td></tr></table></figure>

<p>insert() 方法允许你在列表的任意位置添加数据。<br>insert() 方法有两个参数，第一个参数指定的是插入的位置，第二个参数指定的是插入的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; s.insert(1, 2)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">[1, 2, 3, 4, 5]</span><br></pre></td></tr></table></figure>

<h4 id="8-5-2-删（删除列表中的数据）"><a href="#8-5-2-删（删除列表中的数据）" class="headerlink" title="8.5.2 删（删除列表中的数据）"></a>8.5.2 删（删除列表中的数据）</h4><p>利用 remove() 方法，可以将列表中指定的元素删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.remove(&quot;vagetables&quot;)</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[&#x27;milk&#x27;, &#x27;bread&#x27;, &#x27;egg&#x27;, &#x27;cake&#x27;, &#x27;rice&#x27;]</span><br></pre></td></tr></table></figure>
<p>有两点要注意：</p>
<ul>
<li>如果列表中存在多个匹配的元素，那么它只会删除第一个</li>
<li>remove() 方法要求你指定一个待删除的元素，如果指定的元素压根儿不存在，那么程序就会报错</li>
</ul>
<p>有时候我们可能需要删除某个指定位置上的元素，那么可以使用 pop() 方法，它的参数就是元素的下标索引值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.pop(0)</span><br><span class="line">&#x27;milk&#x27;</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[&#x27;bread&#x27;, &#x27;egg&#x27;, &#x27;cake&#x27;, &#x27;rice&#x27;]</span><br></pre></td></tr></table></figure>
<p><code>pop()</code> 方法这个参数其实是可选的，如果你没有指定一个参数，那么它“弹”出来的就是最后一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.pop()</span><br><span class="line">&#x27;rice&#x27;</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[&#x27;bread&#x27;, &#x27;egg&#x27;, &#x27;cake&#x27;]</span><br></pre></td></tr></table></figure>

<p>如果想要一步到位清空列表，可以使用 clear() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; food.clear()</span><br><span class="line">&gt;&gt;&gt; food</span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<h4 id="8-5-3-改（修改列表中的元素）"><a href="#8-5-3-改（修改列表中的元素）" class="headerlink" title="8.5.3 改（修改列表中的元素）"></a>8.5.3 改（修改列表中的元素）</h4><p>列表跟字符串最大区别就是：列表是可变的，而字符串是不可变的。<br>替换列表中的元素跟访问元素类似，都是使用下标索引的方法，然后使用赋值运算符就可以将新的值给替换进去了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fruit = [&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;cherries&#x27;, &#x27;coconut&#x27;, &#x27;mango&#x27;, &#x27;peach&#x27;]</span><br><span class="line">&gt;&gt;&gt; fruit[3] = &#x27;lychees&#x27;</span><br><span class="line">&gt;&gt;&gt; fruit</span><br><span class="line">[&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;cherries&#x27;, &#x27;lychees&#x27;, &#x27;mango&#x27;, &#x27;peach&#x27;]</span><br></pre></td></tr></table></figure>

<p>如果有连续的多个元素需要替换，可以利用切片来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fruit[3:] = [&#x27;blackberries&#x27;, &#x27;cranberries&#x27;, &#x27;blueberries&#x27;]</span><br><span class="line">&gt;&gt;&gt; fruit</span><br><span class="line">[&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;cherries&#x27;, &#x27;blackberries&#x27;, &#x27;cranberries&#x27;, &#x27;blueberries&#x27;]</span><br></pre></td></tr></table></figure>

<p><strong>排序与翻转</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 4, 6, 9, 8, 2, 4, 7]</span><br><span class="line">&gt;&gt;&gt; nums.sort()</span><br><span class="line">&gt;&gt;&gt; nums</span><br><span class="line">[1, 2, 4, 4, 6, 7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; #如果想倒叙怎么做呢？</span><br><span class="line">&gt;&gt;&gt; nums.reverse()          # reverse 是将数组翻转</span><br><span class="line">&gt;&gt;&gt; nums</span><br><span class="line">[9, 8, 7, 6, 4, 4, 2, 1]</span><br></pre></td></tr></table></figure>

<p>sort() 方法还可以实现排序后翻转（即从大到小的排序）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 4, 6, 9, 8, 2, 4, 7]</span><br><span class="line">&gt;&gt;&gt; nums.sort(reverse=True)</span><br><span class="line">&gt;&gt;&gt; nums</span><br><span class="line">[9, 8, 7, 6, 4, 4, 2, 1]</span><br></pre></td></tr></table></figure>
<ul>
<li>这里可以参考 <code>sort</code> 的用法</li>
</ul>
<h4 id="8-5-4-查（定位列表中的元素）"><a href="#8-5-4-查（定位列表中的元素）" class="headerlink" title="8.5.4 查（定位列表中的元素）"></a>8.5.4 查（定位列表中的元素）</h4><p>如果我们想知道 nums 这个列表里面到底有多少个 4，可以使用 count() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums</span><br><span class="line">[9, 8, 7, 6, 4, 4, 2, 1]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; nums.count(4)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>如果我们要查找 fruit 列表中，”cherries”这个元素的索引值，可以使用 index() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fruit</span><br><span class="line">[&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;cherries&#x27;, &#x27;blackberries&#x27;, &#x27;cranberries&#x27;, &#x27;blueberries&#x27;]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; fruit.index(&#x27;cherries&#x27;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>index()</strong> 还可以直接更换列表中的元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; fruit[fruit.index(&#x27;cherries&#x27;)] = &#x27;melon&#x27;</span><br><span class="line">&gt;&gt;&gt; fruit</span><br><span class="line">[&#x27;apple&#x27;, &#x27;apricot&#x27;, &#x27;melon&#x27;, &#x27;blackberries&#x27;, &#x27;cranberries&#x27;, &#x27;blueberries&#x27;]</span><br></pre></td></tr></table></figure>
<p>相当于 fruit[   4   ] &#x3D; ‘melon’</p>
<p>index() 方法有两个可选的参数 —— start 和 end，<code>index(x, start, end)</code> 就是指定查找的开始和结束的下标位置：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums = [1, 4, 6, 9, 8, 2, 4, 7]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; nums.index(4, 2, 7)</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<p>列表还有一个方法叫 copy()，用于拷贝一个列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums_copy1 = nums.copy()</span><br><span class="line">&gt;&gt;&gt; nums_copy1</span><br><span class="line">[1, 4, 6, 9, 8, 2, 4, 7]</span><br></pre></td></tr></table></figure>

<p>我们也可以使用切片的语法来实现列表拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; nums_copy2 = nums[:]</span><br><span class="line">&gt;&gt;&gt; nums_copy2</span><br><span class="line">[1, 4, 6, 9, 8, 2, 4, 7]</span><br></pre></td></tr></table></figure>

<p>上面这两种拷贝方法实现的效果是等同的。<br>这两种拷贝的方法，在 Python 中都称为浅拷贝。</p>
<h3 id="8-6-列表的加法和乘法"><a href="#8-6-列表的加法和乘法" class="headerlink" title="8.6 列表的加法和乘法"></a>8.6 列表的加法和乘法</h3><p>列表的加法，其实也是拼接，所以要求加号（+）两边都应该是列表，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; t = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; s + t</span><br><span class="line">[4, 5, 6, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; matix = [[1, 2, 3],</span><br></pre></td></tr></table></figure>

<p>列表的乘法，则是重复列表内部的所有元素若干次：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s * 3</span><br><span class="line">[1, 2, 3, 1, 2, 3, 1, 2, 3]</span><br></pre></td></tr></table></figure>

<h3 id="8-7-嵌套列表"><a href="#8-7-嵌套列表" class="headerlink" title="8.7 嵌套列表"></a>8.7 嵌套列表</h3><p>Python 是允许列表进行嵌套的<br><code>&gt;&gt;&gt; matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code></p>
<p>可以把创建二维列表的语句这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; matrix = [[1, 2, 3],</span><br><span class="line">              [4, 5, 6],</span><br><span class="line">              [7, 8, 9]]</span><br></pre></td></tr></table></figure>
<p>这两种写法是等价的，只是后者在理解上更为直观。</p>
<h3 id="8-8-访问嵌套列表"><a href="#8-8-访问嵌套列表" class="headerlink" title="8.8 访问嵌套列表"></a>8.8 访问嵌套列表</h3><p>访问嵌套列表中的元素，可以使用嵌套的 for 语句来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in matrix:</span><br><span class="line">...     for each in i:</span><br><span class="line">...         print(each)</span><br><span class="line">...</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>通过下标同样可以访问嵌套列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; matrix[0]</span><br><span class="line">[1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; matrix[1]</span><br><span class="line">[4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; matrix[2]</span><br><span class="line">[7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; matrix[0][0]</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; matrix[1][1]</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; matrix[2][2]</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h3 id="8-9-通过-for-语句来创建并初始化二维列表"><a href="#8-9-通过-for-语句来创建并初始化二维列表" class="headerlink" title="8.9 通过 for 语句来创建并初始化二维列表"></a>8.9 通过 for 语句来创建并初始化二维列表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; A = [0] * 3</span><br><span class="line">&gt;&gt;&gt; for i in range(3):</span><br><span class="line">...     A[i] = [0] * 3</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; A</span><br><span class="line">[[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span><br></pre></td></tr></table></figure>

<h3 id="8-10-浅拷贝和深拷贝"><a href="#8-10-浅拷贝和深拷贝" class="headerlink" title="8.10 浅拷贝和深拷贝"></a>8.10 浅拷贝和深拷贝</h3><p>浅拷贝：利用列表的 copy() 方法或者切片来实现<br>深拷贝：利用 copy 模块的 deepcopy() 函数来实现<br><strong>浅拷贝可以用于处理一维列表，对于嵌套列表的拷贝，只能拷贝第一层数据，其余仅拷贝其引用：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; y = x.copy()        # 列表的 copy 方法</span><br><span class="line">&gt;&gt;&gt; x[1][1] = 0</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[[1, 2, 3], [4, 0, 6], [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">[[1, 2, 3], [4, 0, 6], [7, 8, 9]]</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; import copy</span><br><span class="line">&gt;&gt;&gt; x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; y = copy.copy(x)    # copy 模块的copy函数 列表、字符串、元组 都可以拷贝</span><br></pre></td></tr></table></figure>
<p><img src="/image/%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt="浅拷贝"></p>
<p><strong>深拷贝可以用于处理多维列表：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; y = copy.deepcopy(x)</span><br><span class="line">&gt;&gt;&gt; x[1][1] = 0</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">[[1, 2, 3], [4, 0, 6], [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br></pre></td></tr></table></figure>
<p><img src="/image/%E6%B7%B1%E6%8B%B7%E8%B4%9D.jpg" alt="深拷贝"></p>
<h3 id="8-11-列表推导式"><a href="#8-11-列表推导式" class="headerlink" title="8.11 列表推导式"></a>8.11 列表推导式</h3><h4 id="8-11-1-基础语法"><a href="#8-11-1-基础语法" class="headerlink" title="8.11.1 基础语法"></a>8.11.1 基础语法</h4><p>[expression for target in iterable]</p>
<p><strong>example：</strong></p>
<p>掌握好列表推导式，会使代码变得更为简练和高效。<br>比如下面这个循环语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; this = [1, 2, 3, 4, 5]</span><br><span class="line">...           </span><br><span class="line">&gt;&gt;&gt; for i in range(len(this)):</span><br><span class="line">...           this[i] = this[i] * 2</span><br></pre></td></tr></table></figure>

<p>写成列表推导式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; this = [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; this = [i * 2 for i in this]</span><br></pre></td></tr></table></figure>
<p>注意：这可不仅仅是少写了一行代码而已，从程序的执行效率上来说，列表推导式的效率通常是要比循环语句快上一倍左右的速度。 (因为列表推导式是用底层的C语言来执行)</p>
<h4 id="8-11-2-处理矩阵"><a href="#8-11-2-处理矩阵" class="headerlink" title="8.11.2 处理矩阵"></a>8.11.2 处理矩阵</h4><p>利用列表推导式处理矩阵也是非常方便，比如下面代码是将矩阵第 2 列的元素给提取出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; matrix = [[1, 2, 3],</span><br><span class="line">...                 [4, 5, 6],</span><br><span class="line">...                 [7, 8, 9]]</span><br><span class="line">&gt;&gt;&gt; col2 = [row[1] for row in matrix]       #选取每行的第二个元素</span><br><span class="line">&gt;&gt;&gt; col2</span><br><span class="line">[2, 5, 8]</span><br></pre></td></tr></table></figure>

<p>又比如，下面代码是获取矩阵主对角线上的元素（就是从左上角到右下角这条对角线上的元素）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; diag = [matrix[i][i] for i in range(len(matrix))]   #len()是推导列表里元素的角标</span><br><span class="line">&gt;&gt;&gt; diag</span><br><span class="line">[1, 5, 9]</span><br></pre></td></tr></table></figure>

<h4 id="8-11-3-列表推导式创建二维数组"><a href="#8-11-3-列表推导式创建二维数组" class="headerlink" title="8.11.3 列表推导式创建二维数组"></a>8.11.3 列表推导式创建二维数组</h4><p>利用列表推导式，就可以很轻松地创建一个二维列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; S = [[0] * 3 for i in range(3)]</span><br><span class="line">&gt;&gt;&gt; S</span><br><span class="line">[[0, 0, 0], [0, 0, 0], [0, 0, 0]]</span><br><span class="line">&gt;&gt;&gt; S[1][1] = 1</span><br><span class="line">&gt;&gt;&gt; S</span><br><span class="line">[[0, 0, 0], [0, 1, 0], [0, 0, 0]]</span><br></pre></td></tr></table></figure>

<h4 id="8-11-4-带条件筛选功能的列表推导式"><a href="#8-11-4-带条件筛选功能的列表推导式" class="headerlink" title="8.11.4 带条件筛选功能的列表推导式"></a>8.11.4 带条件筛选功能的列表推导式</h4><p>列表推导式其实还可以添加一个用于筛选的 if 分句，完整语法如下：<br><code>[expression for target in iterable if condition1]</code></p>
<h4 id="8-11-5-多层嵌套的列表推导式"><a href="#8-11-5-多层嵌套的列表推导式" class="headerlink" title="8.11.5 多层嵌套的列表推导式"></a>8.11.5 多层嵌套的列表推导式</h4><p>列表推导式还可以变得更复杂一些，那就是实现嵌套，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[expression for target1 in iterable1</span><br><span class="line">            for target2 in iterable2</span><br><span class="line">            ...</span><br><span class="line">            for targetN in iterableN]</span><br></pre></td></tr></table></figure>
<p>每层嵌套还可以附带一个用于条件筛选的 if 分句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[expression for target1 in iterable1 if condition1</span><br><span class="line">            for target2 in iterable2 if condition2</span><br><span class="line">            ...</span><br><span class="line">            for targetN in iterableN if conditionN]</span><br></pre></td></tr></table></figure>

<h3 id="9-元组"><a href="#9-元组" class="headerlink" title="9.元组"></a>9.元组</h3><p>元组既能像列表那样同时容纳多种类型的对象，也拥有字符串不可变的特性。</p>
<h3 id="9-1-元组和列表的不同点"><a href="#9-1-元组和列表的不同点" class="headerlink" title="9.1 元组和列表的不同点"></a>9.1 元组和列表的不同点</h3><ul>
<li>列表使用方括号，元祖则是圆括号（也可以不带圆括号）</li>
<li>列表中的元素可以被修改，而元组不行</li>
<li>列表中涉及到修改元素的方法元组均不支持</li>
<li>列表的推导式叫列表推导式，元组的“推导式”叫生成器表达式</li>
</ul>
<h3 id="9-2-元组和列表的共同点"><a href="#9-2-元组和列表的共同点" class="headerlink" title="9.2 元组和列表的共同点"></a>9.2 元组和列表的共同点</h3><ul>
<li>都可以通过下标获取元素</li>
<li>都支持切片操作</li>
<li>都支持 count() 方法和 index() 方法</li>
<li>都支持拼接(+)和重复(*)运算符</li>
<li>都支持嵌套</li>
<li>都支持迭代</li>
</ul>
<h3 id="9-3-圆括号的必要性"><a href="#9-3-圆括号的必要性" class="headerlink" title="9.3 圆括号的必要性"></a>9.3 圆括号的必要性</h3><p><strong>与其纠结什么时候省略圆括号会不会带来问题，还不如一直加上为妙。</strong><br><strong>这样也可以增加代码的可读性</strong></p>
<h3 id="9-4-当元组只有一个元素的时候"><a href="#9-4-当元组只有一个元素的时候" class="headerlink" title="9.4 当元组只有一个元素的时候"></a>9.4 当元组只有一个元素的时候</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = (6,)</span><br><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>or</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 789,</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">(789,)</span><br><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &#x27;tuple&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="9-5-打包和解包"><a href="#9-5-打包和解包" class="headerlink" title="9.5 打包和解包"></a>9.5 打包和解包</h3><p>生成一个元组有时候也称之为元组的打包:<br><code>&gt;&gt;&gt; t = (123, &#39;Mortal&#39;, 2.713)</code><br>将他们一次性赋值给三个变量名的行为，我们称之为解包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x</span><br><span class="line">123</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">&#x27;Mortal&#x27;</span><br><span class="line">&gt;&gt;&gt; z</span><br><span class="line">2.713</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong> 赋值号左侧的变量名数量，必须跟右侧序列的元素数量一致，否则通常都会报错</p>
<h3 id="9-6-多重赋值的真相"><a href="#9-6-多重赋值的真相" class="headerlink" title="9.6 多重赋值的真相"></a>9.6 多重赋值的真相</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x, y = 5, 8</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">8</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>相当于</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; _ = (5, 8)</span><br><span class="line">&gt;&gt;&gt; x, y = _</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<h3 id="9-7-元组的修改"><a href="#9-7-元组的修改" class="headerlink" title="9.7 元组的修改"></a>9.7 元组的修改</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; t = [4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; w = (s, t)</span><br><span class="line">&gt;&gt;&gt; w</span><br><span class="line">([1, 2, 3], [4, 5, 6])</span><br><span class="line">&gt;&gt;&gt; w[0][1] = &#x27;大笨蛋&#x27;</span><br><span class="line">&gt;&gt;&gt; w</span><br><span class="line">([1, &#x27;大笨蛋&#x27;, 3], [4, 5, 6])</span><br></pre></td></tr></table></figure>

<h2 id="10-字符串"><a href="#10-字符串" class="headerlink" title="10. 字符串"></a>10. 字符串</h2><h3 id="10-1-1大小写字母变换"><a href="#10-1-1大小写字母变换" class="headerlink" title="10.1.1大小写字母变换"></a>10.1.1大小写字母变换</h3><p><code>capitalize()</code>   返回将字符串中首字母大写，其余小写的新字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;I love little Cat&quot;</span><br><span class="line">&gt;&gt;&gt; x.capitalize()</span><br><span class="line">&#x27;I love little cat&#x27;</span><br></pre></td></tr></table></figure>
<p><code>casefold()</code>    返回全部小写的新字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.capitalize()</span><br><span class="line">&#x27;I love little cat&#x27;</span><br></pre></td></tr></table></figure>
<p><code>title()</code>   返回将字符串中每个单词首字母大写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.title()</span><br><span class="line">&#x27;I Love Little Cat&#x27;</span><br></pre></td></tr></table></figure>
<p><code>swapcase()</code>    返回将原字符串大小反转的新字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.swapcase()</span><br><span class="line">&#x27;i LOVE LITTLE cAT&#x27;</span><br></pre></td></tr></table></figure>
<p><code>upper()</code>   返回全部大写的新字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.upper()</span><br><span class="line">&#x27;I LOVE LITTLE CAT&#x27;</span><br></pre></td></tr></table></figure>
<p><code>lower()</code>   返回全部小写的新字符串</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.lower()</span><br><span class="line">&#x27;i love little cat&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="10-1-2-左中右对齐"><a href="#10-1-2-左中右对齐" class="headerlink" title="10.1.2  左中右对齐"></a>10.1.2  左中右对齐</h3><p><code>center(width, fillchar=&#39; &#39;)</code>   </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.center(15)</span><br><span class="line">&#x27;     小猫爱吃鱼     &#x27;</span><br></pre></td></tr></table></figure>
<p><code>ljust(width, fillchar=&#39; &#39;)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.ljust(15)</span><br><span class="line">&#x27;小猫爱吃鱼          &#x27;</span><br></pre></td></tr></table></figure>
<p><code>rjust(width, fillchar=&#39; &#39;)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.rjust(15)</span><br><span class="line">&#x27;          小猫爱吃鱼&#x27;</span><br></pre></td></tr></table></figure>
<p><code>zfill(15)</code>     用<code>0</code>填充左侧</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;520&quot;.zfill(5)</span><br><span class="line">&#x27;00520&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;-520&quot;.zfill(5)</span><br><span class="line">&#x27;-0520&#x27;</span><br><span class="line">&gt;&gt;&gt; x.center(15, &quot;淦&quot;)</span><br><span class="line">&#x27;淦淦淦有内鬼，停止交易！淦淦淦&#x27;</span><br><span class="line">&gt;&gt;&gt; x.ljust(15, &quot;淦&quot;)</span><br><span class="line">&#x27;有内鬼，停止交易！淦淦淦淦淦淦&#x27;</span><br><span class="line">&gt;&gt;&gt; x.rjust(15, &quot;淦&quot;)</span><br><span class="line">&#x27;淦淦淦淦淦淦有内鬼，停止交易！&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="10-2-1-查找"><a href="#10-2-1-查找" class="headerlink" title="10.2.1 查找"></a>10.2.1 查找</h3><p><code>count(sub[,start[,end]])</code>  <code>find(sub[, start[, end]])</code>  <code>rfind(sub[, start[, end]])</code>  <code>index(sub[, start[, end]])</code>  <code>rindex(sub[, start[, end]])</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;上海自来水来自海上&quot;</span><br><span class="line">&gt;&gt;&gt; x.count(&quot;海&quot;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; x.count(&quot;海&quot;, 0, 5)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; x.find(&quot;海&quot;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; x.rfind(&quot;海&quot;)</span><br><span class="line">7</span><br><span class="line">&gt;&gt;&gt; x.find(&quot;龟&quot;)</span><br><span class="line">-1</span><br><span class="line">&gt;&gt;&gt; x.index(&quot;龟&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    x.index(&quot;龟&quot;)</span><br><span class="line">ValueError: substring not found</span><br></pre></td></tr></table></figure>

<h3 id="10-2-2-替换"><a href="#10-2-2-替换" class="headerlink" title="10.2.2 替换"></a>10.2.2 替换</h3><p><code>expandtabs([tabsize=8])</code>  <code>replace(old, new, count=-1)</code>  <code>translate(table)</code></p>
<p>首先是 <code>expandtabs([tabsize=8])</code> 方法，它的作用是使用空格替换制表符并返回新的字符串。</p>
<p>比如你现在在路边捡到一段代码，里面混了着 Tab 和空格：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; code = &quot;&quot;&quot;</span><br><span class="line">        print(&quot;I love MoralSec.&quot;)</span><br><span class="line">    print(&quot;I love my wife.&quot;)&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>那么使用 <code>expandtabs(tabsize=4)</code> 方法，就可以将字符串中的 Tab 转换成空格，其中 tabsize 参数指定的是一个 Tab 使用多少个空格来代替：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; new_code = code.expandtabs(4)</span><br><span class="line">&gt;&gt;&gt; print(new_code)</span><br><span class="line">    </span><br><span class="line">    print(&quot;I love MoralSec.&quot;)</span><br><span class="line">    print(&quot;I love my wife.&quot;)</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><code>replace(old, new, count=-1)</code> 方法返回一个将所有 old 参数指定的子字符串替换为 new 的新字符串。另外，还有一个 count 参数是指定替换的次数，默认值 -1 表示替换全部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;在吗！我在你家楼下，快点下来!!&quot;.replace(&quot;在吗&quot;, &quot;想你&quot;)</span><br><span class="line">&#x27;想你！我在你家楼下，快点下来!!&#x27;</span><br></pre></td></tr></table></figure>

<p><code>translate(table)</code> 方法，这个是返回一个根据 table 参数（用于指定一个转换规则的表格）转换后的新字符串。</p>
<p>需要使用 <code>str.maketrans(x[, y[, z]])</code> 方法制定一个包含转换规则的表格。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; table = str.maketrans(&quot;ABCDEFG&quot;, &quot;1234567&quot;)</span><br><span class="line">&gt;&gt;&gt; &quot;YOU ARE AN APPLE OF MY EYE&quot;.translate(table)</span><br><span class="line">&#x27;YOU 1R5 1N 1PPL5 O6 MY 5Y5&#x27;</span><br></pre></td></tr></table></figure>

<p>这个 <code>str.maketrans()</code> 方法还支持第三个参数，表示将其指定的字符串忽略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;YOU ARE AN APPLE OF MY EYE&quot;.translate(str.maketrans(&quot;ABCDEFG&quot;, &quot;1234567&quot;,&quot;ARE&quot;))</span><br><span class="line">&#x27;YOU  N PPL O6 MY Y&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="10-3-1-判断"><a href="#10-3-1-判断" class="headerlink" title="10.3.1 判断"></a>10.3.1 判断</h3><p><code>startswith(prefix[, start[, end]])</code>  <code>endswith(suffix[, start[, end]])</code>  <code>istitle()</code>  <code>isupper()</code>  <code>islower()</code>  <code>isalpha()</code>  <code>isascii()</code>  <code>isspace()</code>  <code>isprintable()</code>  <code>isdecimal()</code>  <code>isdigit()</code>  <code>isnumeric()</code>  <code>isalnum()</code>  <code>isidentifier()</code></p>
<p>这 14 个方法都是应对各种情况的判断，所以返回的都是一个布尔类型的值 —— 要么是 True，要么是 False。</p>
<p><code>startswith(prefix[, start[, end]])</code> 方法用于判断 <code>prefix</code> 参数指定的子字符串是否出现在字符串的起始位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;我爱Python&quot;</span><br><span class="line">&gt;&gt;&gt; x.startswith(&quot;我&quot;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x.startswith(&quot;小猫咪&quot;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>对应的，<code>endswith(suffix[, start[, end]])</code> 方法则相反，用于判断 suffix 参数指定的子字符串是否出现在字符串的结束位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.startswith(&quot;我&quot;, 1)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.startswith(&quot;爱&quot;, 1)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x.endswith(&quot;Py&quot;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.endswith(&quot;Py&quot;, 0, 4)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>这个 <code>prefix</code> 和 <code>suffix</code> 参数，其实是支持以元组的形式传入多个待匹配的字符串的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;她爱Pyhon&quot;</span><br><span class="line">&gt;&gt;&gt; if x.startswith((&quot;你&quot;, &quot;我&quot;, &quot;她&quot;)):</span><br><span class="line">...     print(&quot;总有人喜爱Pyhon&quot;)</span><br><span class="line">...</span><br><span class="line">总有人喜爱Pyhon</span><br></pre></td></tr></table></figure>
<p>如果你希望判断一个字符串中的所有单词是否都是以大写字母开头，其余字母均为小写，那么可以使用 istitle() 方法进行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;I Love Python&quot;</span><br><span class="line">&gt;&gt;&gt; x.istitle()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>如果你希望判断一个字符串中所有字母是否都是大写，可以使用 isupper() 方法进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.isupper()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.upper().isupper()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>相反，判断是否所有字母都是小写，用 islower() 方法，我们这里就不再赘述了。</p>
<p>如果你希望判断一个字符串中是否只是由字母组成，可以使用 isalpha() 方法进行检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.isalpha()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; &quot;IlovePython&quot;.isalpha()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>如果你希望判断一个字符串中是否只是由 ASCII 字符组成，可以使用 isascii() 方法进行检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.isascii()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;我爱Pyhon&quot;.isascii()</span><br><span class="line">False</span><br></pre></td></tr></table></figure>
<p>如果你希望判断是否为一个空白字符串，可以用 isspace() 方法进行检测：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;    \t\n&quot;.isspace()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>如果你希望判断一个字符串中是否所有字符都是可打印的，可以使用 isprintable() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x.isprintable()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;I love FishC\n&quot;.isprintable()</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>isdecimal()、isdigit() 和 isnumeric() 三个方法都是用来判断数字的。</p>
<p>首先是十进制数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;12345&quot;</span><br><span class="line">&gt;&gt;&gt; x.isdecimal()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x.isdigit()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x.isnumeric()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>如果写成罗马数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;ⅠⅡⅢⅣⅤ&quot;</span><br><span class="line">&gt;&gt;&gt; x.isdecimal()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isdigit()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isnumeric()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>或者中文数字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;一二三四五&quot;</span><br><span class="line">&gt;&gt;&gt; x.isdecimal()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isdigit()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isnumeric()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>isdecimal() 和 isdigit() 方法都败下阵来了，但 isnumeric() 方法，其实连繁体数字也难不倒它地：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;壹贰叁肆伍&quot;</span><br><span class="line">&gt;&gt;&gt; x.isdecimal()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isdigit()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; x.isnumeric()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>isalnum() 方法则是集大成者，只要 isalpha()、isdecimal()、isdigit() 或者 isnumeric() 任意一个方法返回 True，结果都为 True。</p>
<p>最后，isidentifier() 方法用于判断该字符串是否一个合法的 Python 标识符</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;I a good gay&quot;.isidentifier()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; &quot;I_a_good_gay&quot;.isidentifier()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;FishC520&quot;.isidentifier()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;520FishC&quot;.isidentifier()</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>如果你想判断一个字符串是否为 Python 的保留标识符，就是像 “if”、“for”、“while” 这些关键字的话，可以使用 keyword 模块的 iskeyword() 函数来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import keyword</span><br><span class="line">&gt;&gt;&gt; keyword.iskeyword(&quot;if&quot;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; keyword.iskeyword(&quot;py&quot;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h3 id="10-4-1-截取"><a href="#10-4-1-截取" class="headerlink" title="10.4.1 截取"></a>10.4.1 截取</h3><p><code>lstrip(chars=None)</code>、<code>rstrip(chars=None)</code>、<code>strip(chars=None)</code>、<code>removeprefix(prefix)</code>、<code>removesuffix(suffix)</code></p>
<p>这几个方法都是用来截取字符串的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;    左侧不要留白&quot;.lstrip()</span><br><span class="line">&#x27;左侧不要留白&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;右侧不要留白    &quot;.rstrip()</span><br><span class="line">&#x27;右侧不要留白&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;    左右不要留白    &quot;.strip()</span><br><span class="line">&#x27;左右不要留白&#x27;</span><br></pre></td></tr></table></figure>

<p>例题：如果要从字符串 “<a target="_blank" rel="noopener" href="https://ilovefishc.com/html5/index.html">https://ilovefishc.com/html5/index.html</a>“ 中提取出 “ilovefishc.com”，使用 split() 方法应该如何实现呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;https://ilovefishc.com/html5/index.html&quot;.split(&#x27;//&#x27;)[1].split(&#x27;/&#x27;)[0]</span><br><span class="line">&#x27;ilovefishc.com&#x27;</span><br></pre></td></tr></table></figure>
<p>解析：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;https://ilovefishc.com/html5/index.html&quot;.split(&#x27;//&#x27;)</span><br><span class="line">[&#x27;https:&#x27;, &#x27;ilovefishc.com/html5/index.html&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;https://ilovefishc.com/html5/index.html&quot;.split(&#x27;//&#x27;)[1]            #[1]为返回列表的索引</span><br><span class="line">&#x27;ilovefishc.com/html5/index.html&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;https://ilovefishc.com/html5/index.html&quot;.split(&#x27;//&#x27;)[1].split(&#x27;/&#x27;)</span><br><span class="line">[&#x27;ilovefishc.com&#x27;, &#x27;html5&#x27;, &#x27;index.html&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;https://ilovefishc.com/html5/index.html&quot;.split(&#x27;//&#x27;)[1].split(&#x27;/&#x27;)[0]</span><br><span class="line">&#x27;ilovefishc.com&#x27;</span><br></pre></td></tr></table></figure>



<p>这三个方法都有一个 chars&#x3D;None 的参数， None 在 Python 中表示没有，意思就是去除的是空白。<br>那么这个参数其实是可以给它传入一个字符串的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.lstrip(&quot;wcom.&quot;)</span><br><span class="line">&#x27;github.com&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.rstrip(&quot;wcom.&quot;)</span><br><span class="line">&#x27;www.github&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.strip(&quot;wcom.&quot;)</span><br><span class="line">&#x27;github&#x27;</span><br></pre></td></tr></table></figure>

<p><code>removeprefix(prefix)</code> 和 <code>removesuffix(suffix)</code> 这两个方法,它们允许你指定将要删除的前缀或后缀：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.removeprefix(&quot;www.&quot;)</span><br><span class="line">&#x27;github.com&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.removesuffix(&quot;.com&quot;)</span><br><span class="line">&#x27;www.github&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="10-4-2-拆分"><a href="#10-4-2-拆分" class="headerlink" title="10.4.2 拆分"></a>10.4.2 拆分</h3><p><code>partition(sep)</code>、<code>rpartition(sep)</code>、<code>split(sep=None, maxsplit=-1)</code>、<code>rsplit(sep=None, maxsplit=-1)</code>、<code>splitlines(keepends=False)</code></p>
<p>拆分字符串，言下之意就是把字符串给大卸八块，比如 partition(sep) 和 rpartition(sep) 方法，就是将字符串以 sep 参数指定的分隔符为依据进行切割，返回的结果是一个 3 元组（3 个元素的元组）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;www.github.com&quot;.partition(&quot;.&quot;)</span><br><span class="line">(&#x27;www&#x27;, &#x27;.&#x27;, &#x27;github.com&#x27;)</span><br></pre></td></tr></table></figure>

<p><code>partition(sep)</code> 和 <code>rpartition(sep)</code> 方法的区别是前者是从左往右找分隔符，后者是从右往左找分隔符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;github.com/python&quot;.partition(&quot;/&quot;)</span><br><span class="line">(&#x27;github.com&#x27;, &#x27;/&#x27;, &#x27;python&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>注意：它俩如果找不到分隔符，返回的仍然是一个 3 元组，只不过将原字符串放在第一个元素，其它两个元素为空字符串。</strong></p>
<p><code>split(sep=None, maxsplit=-1)</code> 和 <code>rsplit(sep=None, maxsplit=-1)</code> 方法则是可以将字符串切成一块块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;苟日新，日日新，又日新&quot;.split(&quot;，&quot;)</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新&#x27;, &#x27;又日新&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;苟日新，日日新，又日新&quot;.rsplit(&quot;，&quot;)</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新&#x27;, &#x27;又日新&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;苟日新，日日新，又日新&quot;.split(&quot;，&quot;, 1)</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新，又日新&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;苟日新，日日新，又日新&quot;.rsplit(&quot;，&quot;, 1)</span><br><span class="line">[&#x27;苟日新，日日新&#x27;, &#x27;又日新&#x27;]</span><br></pre></td></tr></table></figure>

<p><code>splitlines(keepends=False)</code> 方法会将字符串进行按行分割，并将结果以列表的形式返回</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;苟日新\n日日新\n又日新&quot;.splitlines()</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新&#x27;, &#x27;又日新&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;苟日新\r日日新\r又日新&quot;.splitlines()</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新&#x27;, &#x27;又日新&#x27;]</span><br><span class="line">&gt;&gt;&gt; &quot;苟日新\r日日新\r\n又日新&quot;.splitlines()</span><br><span class="line">[&#x27;苟日新&#x27;, &#x27;日日新&#x27;, &#x27;又日新&#x27;]</span><br></pre></td></tr></table></figure>

<p><code>keepends</code> 参数用于指定结果是否包含换行符，True 是包含，默认 False 则表示是不包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;苟日新\r日日新\r\n又日新&quot;.splitlines(True)</span><br><span class="line">[&#x27;苟日新\r&#x27;, &#x27;日日新\r\n&#x27;, &#x27;又日新&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="10-4-3-拼接"><a href="#10-4-3-拼接" class="headerlink" title="10.4.3 拼接"></a>10.4.3 拼接</h3><p><code>join(iterable)</code> 方法是用于实现字符串拼接的。</p>
<p>虽然的它的用法在初学者看来是非常难受的，但是在实际开发中，它却常常是受到大神追捧的一个方法。</p>
<p>字符串是作为分隔符使用，然后 <code>iterable</code> 参数指定插入的子字符串：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;.&quot;.join([&quot;www&quot;, &quot;ilovefishc&quot;, &quot;com&quot;])</span><br><span class="line">&#x27;www.ilovefishc.com&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;^&quot;.join((&quot;F&quot;, &quot;ish&quot;, &#x27;C&#x27;))</span><br><span class="line">&#x27;F^ish^C&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&quot;.join((&quot;FishC&quot;, &quot;FishC&quot;))</span><br><span class="line">&#x27;FishCFishC&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="10-5-1-格式化字符串"><a href="#10-5-1-格式化字符串" class="headerlink" title="10.5.1 格式化字符串"></a>10.5.1 格式化字符串</h3><p>在字符串中，格式化字符串的套路就是使用一对花括号（{}）来表示替换字段，就在原字符串中先占一个坑的意思，然后真正的内容被放在了 format() 方法的参数中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; year = 2010</span><br><span class="line">&gt;&gt;&gt; &quot;鱼C工作室成立于 year 年。&quot;</span><br><span class="line">&#x27;鱼C工作室成立于 year 年。&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;鱼C工作室成立于 &#123;&#125; 年。&quot;.format(year)</span><br><span class="line">&#x27;鱼C工作室成立于 2010 年。&#x27;</span><br></pre></td></tr></table></figure>

<p>又比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;1+2=&#123;&#125;, 2的平方是&#123;&#125;，3的立方是&#123;&#125;&quot;.format(1+2, 2*2, 3*3*3)</span><br><span class="line">&#x27;1+2=3, 2的平方是4，3的立方是27&#x27;</span><br></pre></td></tr></table></figure>

<p>在花括号里面，可以写上数字，表示参数的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;1&#125;看到&#123;0&#125;就很激动！&quot;.format(&quot;mortal&quot;, &quot;漂亮的小姐姐&quot;)</span><br><span class="line">&#x27;漂亮的小姐姐看到mortal就很激动！&#x27;</span><br></pre></td></tr></table></figure>

<p>注意，同一个索引值是可以被多次引用的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;0&#125;&#123;0&#125;&#123;1&#125;&#123;1&#125;&quot;.format(&quot;是&quot;, &quot;非&quot;)</span><br><span class="line">&#x27;是是非非&#x27;</span><br></pre></td></tr></table></figure>

<p>还可以通过关键字进行索引，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;我叫&#123;name&#125;，我爱&#123;fav&#125;。&quot;.format(name=&quot;mortal&quot;, fav=&quot;Pyhon&quot;)</span><br><span class="line">&#x27;我叫mortal，我爱Pyhon。&#x27;</span><br></pre></td></tr></table></figure>

<p>当然，位置索引和关键字索引可以组合使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;我叫&#123;name&#125;，我爱&#123;0&#125;。喜爱&#123;0&#125;的人，运气都不会太差^o^&quot;.format(&quot;python&quot;, name=&quot;mortal&quot;)</span><br><span class="line">&#x27;我叫mortal，我爱python。喜爱python的人，运气都不会太差^o^&#x27;</span><br></pre></td></tr></table></figure>

<p>如果我只是想单纯的输出一个纯洁的花括号，那应该怎么办呢？<br>有两种办法可以把这个纯洁的花括号安排进去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;&#125;, &#123;&#125;, &#123;&#125;&quot;.format(1, &quot;&#123;&#125;&quot;, 2)</span><br><span class="line">&#x27;1, &#123;&#125;, 2&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;&#125;, &#123;&#123;&#125;&#125;, &#123;&#125;&quot;.format(1, 2)</span><br><span class="line">&#x27;1, &#123;&#125;, 2&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="10-5-2-字符串格式化语法参考"><a href="#10-5-2-字符串格式化语法参考" class="headerlink" title="10.5.2 字符串格式化语法参考"></a>10.5.2 字符串格式化语法参考</h3><p>以下所解锁的新知识，可以直接在字符串的 format() 方法上使用，也可以用于 Python3.6 后新添加的<strong>f-字符串</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">format_spec     ::=  [[fill]align][sign][#][0][width][grouping_option][.precision][type]</span><br><span class="line">fill            ::=  &lt;any character&gt;</span><br><span class="line">align           ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot;</span><br><span class="line">sign            ::=  &quot;+&quot; | &quot;-&quot; | &quot; &quot;</span><br><span class="line">width           ::=  digit+</span><br><span class="line">grouping_option ::=  &quot;_&quot; | &quot;,&quot;</span><br><span class="line">precision       ::=  digit+</span><br><span class="line">type            ::=  &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-185807-1-1.html">https://fishc.com.cn/thread-185807-1-1.html</a> <a href="%22https://fishc.com.cn/thread-185807-1-1.html%22">字符串格式化语法参考</a></p>
<h4 id="10-5-2-1-对齐选项（-align-）"><a href="#10-5-2-1-对齐选项（-align-）" class="headerlink" title="10.5.2.1 对齐选项（[align]）"></a>10.5.2.1 对齐选项（[align]）</h4><p><img src="/image/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E9%BD%90.png" alt="对齐选项"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:^&#125;&quot;.format(250)</span><br><span class="line">&#x27;250&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:^10&#125;&quot;.format(250)</span><br><span class="line">&#x27;   250    &#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;1:&gt;10&#125;&#123;0:&lt;10&#125;&quot;.format(520, 250)</span><br><span class="line">&#x27;       250520       &#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;left:&gt;10&#125;&#123;right:&lt;10&#125;&quot;.format(right=520, left=250)</span><br><span class="line">&#x27;       250520       &#x27;</span><br></pre></td></tr></table></figure>
<p><code>&quot;&#123;1:&gt;10&#125;&#123;0:&lt;10&#125;&quot;.format(520, 250)</code>  1 ~ 位置索引  &gt; ~ 对齐方向  10 ~ 显示宽度</p>
<h4 id="10-5-2-2-填充选项（-fill-）"><a href="#10-5-2-2-填充选项（-fill-）" class="headerlink" title="10.5.2.2 填充选项（[fill]）"></a>10.5.2.2 填充选项（[fill]）</h4><p>在指定宽度的前面还可以添加一个 ‘0’，则表示为数字类型启用感知正负号的 ‘0’ 填充效果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:010&#125;&quot;.format(520)</span><br><span class="line">&#x27;0000000520&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:010&#125;&quot;.format(-520)</span><br><span class="line">&#x27;-000000520&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>注意，这种用法只对数字有效：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:010&#125;&quot;.format(&quot;FishC&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#39&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    &quot;&#123;:010&#125;&quot;.format(&quot;FishC&quot;)</span><br><span class="line">ValueError: &#x27;=&#x27; alignment not allowed in string format specifier</span><br></pre></td></tr></table></figure>

<p>还可以在对齐（[align]）选项的前面通过填充选项（[fill]）来指定填充的字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;1:%&gt;10&#125;&#123;0:%&lt;10&#125;&quot;.format(520, 250)</span><br><span class="line">&#x27;%%%%%%%250520%%%%%%%&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:0=10&#125;&quot;.format(520)</span><br><span class="line">&#x27;0000000520&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:0=10&#125;&quot;.format(-520)</span><br><span class="line">&#x27;-000000520&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="10-5-3-符号（-sign-）选项"><a href="#10-5-3-符号（-sign-）选项" class="headerlink" title="10.5.3 符号（[sign]）选项"></a>10.5.3 符号（[sign]）选项</h4><p>符号（[sign]）选项仅对数字类型有效，可以使用下面3个值：</p>
<p><img src="/image/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AC%A6%E5%8F%B7.png" alt="字符串符号"></p>
<h4 id="10-5-4-精度（-precision-）选项"><a href="#10-5-4-精度（-precision-）选项" class="headerlink" title="10.5.4 精度（[.precision]）选项"></a>10.5.4 精度（[.precision]）选项</h4><p>精度（[.precision]）选项是一个十进制整数，对于不同类型的参数，它的效果是不一样的：</p>
<ul>
<li>对于以 ‘f’ 或 ‘F’ 格式化的浮点数值来说，是限定小数点后显示多少个数位</li>
<li>对于以 ‘g’ 或 ‘G’ 格式化的浮点数值来说，是限定小数点前后共显示多少个数位</li>
<li>对于非数字类型来说，限定最大字段的大小（换句话说就是要使用多少个来自字段内容的字符）</li>
<li>对于整数来说，则不允许使用该选项值</li>
</ul>
<h4 id="10-5-5-类型（-type-）选项"><a href="#10-5-5-类型（-type-）选项" class="headerlink" title="10.5.5 类型（[type]）选项"></a>10.5.5 类型（[type]）选项</h4><p>类型（[type]）选项决定了数据应该如何呈现。<br>以下类型适用于整数：<br>![适用整数]](&#x2F;image&#x2F;类型整数.jpg)<br>以下类型值适用于浮点数、复数和整数（自动转换为等值的浮点数）如下：<br><img src="/image/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B1%BB%E5%9E%8B.png" alt="字符串类型"></p>
<h4 id="10-5-7-更灵活的玩法"><a href="#10-5-7-更灵活的玩法" class="headerlink" title="10.5.7 更灵活的玩法"></a>10.5.7 更灵活的玩法</h4><p>Python 事实上支持通过关键参数来设置选项的值，比如下面代码通过参数来调整输出的精度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:.&#123;prec&#125;f&#125;&quot;.format(3.1415, prec=2)</span><br><span class="line">&#x27;3.14&#x27;</span><br></pre></td></tr></table></figure>
<p>同时设置多个选项也是没问题的，只要你自己不乱，Python 就不会乱：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;&#123;:&#123;fill&#125;&#123;align&#125;&#123;width&#125;.&#123;prec&#125;&#123;ty&#125;&#125;&quot;.format(3.1415, fill=&#x27;+&#x27;, align=&#x27;^&#x27;, width=10, prec=3, ty=&#x27;g&#x27;)</span><br><span class="line">&#x27;+++3.14+++&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="10-5-8-f-字符串"><a href="#10-5-8-f-字符串" class="headerlink" title="10.5.8  f-字符串"></a>10.5.8  f-字符串</h4><p>Python 随着版本的更迭，它的语法也是在不断完善的。“简洁胜于复杂”是 Python 之禅中强调的理念。</p>
<p>因此，在 Python3.6 的更新中，他们给添加了一个新的语法，叫 f-string，也就是 f-字符串。</p>
<p>f-string 可以直接看作是 format() 方法的语法糖，它进一步简化了格式化字符串的操作并带来了性能上的提升。</p>
<ul>
<li>注：语法糖（英语：Syntactic sugar）是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。</li>
</ul>
<p>来，我们使用 f-string 将前面讲解 format() 方法的例子给大家修改一遍，你就知道该怎么玩了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; year = 2010</span><br><span class="line">&gt;&gt;&gt; f&quot;鱼C工作室成立于 &#123;year&#125; 年&quot;</span><br><span class="line">&#x27;鱼C工作室成立于 2010 年&#x27;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; f&quot;1+2=&#123;1+2&#125;, 2的平方是&#123;2*2&#125;，3的立方是&#123;3*3*3&#125;&quot;</span><br><span class="line">&#x27;1+2=3, 2的平方是4，3的立方是27&#x27;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:010&#125;&quot;.format(-520)</span><br><span class="line">&gt;&gt;&gt; f&quot;&#123;-520:010&#125;&quot;</span><br><span class="line">&#x27;-000000520&#x27;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:,&#125;&quot;.format(123456789)</span><br><span class="line">&gt;&gt;&gt; f&quot;&#123;123456789:,&#125;&quot;</span><br><span class="line">&#x27;123,456,789&#x27;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; &quot;&#123;:.2f&#125;&quot;.format(3.1415)</span><br><span class="line">&gt;&gt;&gt; f&quot;&#123;3.1415:.2f&#125;&quot;</span><br><span class="line">&#x27;3.14&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="11-序列"><a href="#11-序列" class="headerlink" title="11 序列"></a>11 序列</h2><h3 id="11-1-列表、元组、字符串的共同点"><a href="#11-1-列表、元组、字符串的共同点" class="headerlink" title="11.1 列表、元组、字符串的共同点"></a>11.1 列表、元组、字符串的共同点</h3><ul>
<li>都可以通过索引获取每一个元素</li>
<li>第一个元素的索引值都是 0</li>
<li>都可以通过切片的方法获得一个范围内的元素的集合</li>
<li>有很多共同的运算符</li>
</ul>
<p>因此，列表、元组和字符串，Python 将它们统称为序列。<br>根据是否能被修改这一特性，可以将序列分为可变序列和不可变序列：比如列表就是可变序列，而元组和字符串则是不可变序列。</p>
<h3 id="11-2-加号（-）和乘号"><a href="#11-2-加号（-）和乘号" class="headerlink" title="11.2 加号（+）和乘号(*)"></a>11.2 加号（+）和乘号(*)</h3><p>首先是加减乘除，只有加号（+）和乘号（*）可以用上，序列之间的加法表示将两个序列进行拼接；乘法表示将序列进行重复，也就是拷贝：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [1, 2, 3] + [4, 5, 6]</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; (1, 2, 3) + (4, 5, 6)</span><br><span class="line">(1, 2, 3, 4, 5, 6)</span><br><span class="line">&gt;&gt;&gt; &quot;123&quot; + &quot;456&quot;</span><br><span class="line">&#x27;123456&#x27;</span><br><span class="line">&gt;&gt;&gt; [1, 2, 3] * 3</span><br><span class="line">[1, 2, 3, 1, 2, 3, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; (1, 2, 3) * 3</span><br><span class="line">(1, 2, 3, 1, 2, 3, 1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; &quot;123&quot; * 3</span><br><span class="line">&#x27;123123123&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="11-3-关于-“可变”-和-“不可变”-的思考"><a href="#11-3-关于-“可变”-和-“不可变”-的思考" class="headerlink" title="11.3 关于 “可变” 和 “不可变” 的思考"></a>11.3 关于 “可变” 和 “不可变” 的思考</h3><p><strong>可变序列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; id(s)</span><br><span class="line">2285532322944       </span><br><span class="line">&gt;&gt;&gt; s *= 2</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">[1, 2, 3, 1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; id(s)</span><br><span class="line">2285532322944       </span><br></pre></td></tr></table></figure>
<p><strong>不可变序列</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; id(t)</span><br><span class="line">2285532205952       </span><br><span class="line">&gt;&gt;&gt; t *= 2</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">(1, 2, 3, 1, 2, 3)</span><br><span class="line">&gt;&gt;&gt; id(t)</span><br><span class="line">2285532393920           #观察这里</span><br></pre></td></tr></table></figure>
<p>虽然可变序列和不可变序列看上去都是 “可变” 的，但实现原理却是天壤之别：可变序列是在原位置修改 “扩容”，而不可变序列则是将内容 “扩容” 后再放到一个新的位置上去。</p>
<h3 id="11-4-是（is）和不是（is-not）"><a href="#11-4-是（is）和不是（is-not）" class="headerlink" title="11.4  是（is）和不是（is not）"></a>11.4  是（is）和不是（is not）</h3><p>是（is）和不是（is not）被称之为同一性运算符，用于检测两个对象之间的 id 值是否相等：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; y = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; x is y</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; x = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; x is not y</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h3 id="11-5-包含（in）和不包含（not-in）"><a href="#11-5-包含（in）和不包含（not-in）" class="headerlink" title="11.5 包含（in）和不包含（not in）"></a>11.5 包含（in）和不包含（not in）</h3><p>in 运算符是用于判断某个元素是否包含在序列中的，而 not in 则恰恰相反：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;Fish&quot; in &quot;FishC&quot;</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;鱼&quot; in &quot;鱼C&quot;</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &quot;C&quot; not in &quot;FishC&quot;</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h3 id="11-6-del-语句"><a href="#11-6-del-语句" class="headerlink" title="11.6  del 语句"></a>11.6  del 语句</h3><p>del 语句用于删除一个或多个指定的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; y = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; del x, y</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#52&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    x</span><br><span class="line">NameError: name &#x27;x&#x27; is not defined</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#53&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    y</span><br><span class="line">NameError: name &#x27;y&#x27; is not defined</span><br></pre></td></tr></table></figure>

<h3 id="11-7-list-、tuple-和-str"><a href="#11-7-list-、tuple-和-str" class="headerlink" title="11.7 list()、tuple() 和 str()"></a>11.7 list()、tuple() 和 str()</h3><p>list()、tuple() 和 str() 这三个 BIF 函数主要是实现列表、元组和字符串的转换。</p>
<h3 id="11-8-min-和-max"><a href="#11-8-min-和-max" class="headerlink" title="11.8 min() 和 max()"></a>11.8 min() 和 max()</h3><p>min() 和 max() 这两个函数的功能是：对比传入的参数，并返回最小值和最大值。</p>
<p>它们都有两种函数原型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min(iterable, *[, key, default])</span><br><span class="line">min(arg1, arg2, *args[, key])</span><br></pre></td></tr></table></figure>
<p>以及</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">max(iterable, *[, key, default])</span><br><span class="line">max(arg1, arg2, *args[, key])</span><br></pre></td></tr></table></figure>
<p>这第一种传入的是一个可迭代对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 1, 2, 3, 5]</span><br><span class="line">&gt;&gt;&gt; min(s)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; t = &quot;Mortal&quot;</span><br><span class="line">&gt;&gt;&gt; max(t)</span><br><span class="line">&#x27;t&#x27;</span><br></pre></td></tr></table></figure>
<p>这第二种传入多个参数，它们会自动找出其中的最小值和最大值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; min(1, 2, 3, 0, 6)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; max(1, 2, 3, 0, 6)</span><br><span class="line">6</span><br></pre></td></tr></table></figure>
<h3 id="11-9-len-和-sum"><a href="#11-9-len-和-sum" class="headerlink" title="11.9 len() 和 sum()"></a>11.9 len() 和 sum()</h3><p>len() 函数我们前面用过好多次了，基本用法不必啰嗦，大家都懂~</p>
<p>不过它有个最大的可承受范围，可能有些同学还不知道，比如说这样</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(range(2 ** 100))</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#42&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    len(range(2 ** 100))</span><br><span class="line">OverflowError: Python int too large to convert(转换) to C ssize_t</span><br></pre></td></tr></table></figure>
<p>这个错误是由于 len() 函数的参数太大导致的，我们知道 Python 为了执行的效率，它内部几乎都是用效率更高的 C 语言来实现的。<br>而这个 len() 函数为了让 Python 自带的数据结构可以走后门，它会直接读取 C 语言结构体里面对象的长度。<br>所以，如果检测的对象超过某个数值，就会出错。</p>
<p>通常对于 32 位平台来说，这个最大的数值是 <code>2**31 - 1</code>；而对于 64 位平台来说，这个最大的数值是 <code>2**63 - 1</code>。</p>
<p>sum() 函数用于计算迭代对象中各项的和：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 0, 0, 8, 6]</span><br><span class="line">&gt;&gt;&gt; sum(s)</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>它有一个 start 参数，用于指定求和计算的起始数值，比如这里我们设置为从 100 开始加起：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum(s, start=100)</span><br><span class="line">115</span><br></pre></td></tr></table></figure>

<h3 id="11-10-sorted-和-reverse"><a href="#11-10-sorted-和-reverse" class="headerlink" title="11.10 sorted() 和 reverse()"></a>11.10 sorted() 和 reverse()</h3><p>sorted() 函数将重新排序 iterable 参数中的元素，并将结果返回一个新的列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 2, 3, 0, 6]</span><br><span class="line">&gt;&gt;&gt; sorted(s)</span><br><span class="line">[0, 1, 2, 3, 6]</span><br></pre></td></tr></table></figure>
<p>sorted() 函数也支持 key 和 reverse 两个参数，用法跟列表的 sort() 方法一致：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted(s, reverse=True)</span><br><span class="line">[6, 3, 2, 1, 0]</span><br><span class="line">&gt;&gt;&gt; s.sort(reverse=True)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">[6, 3, 2, 1, 0]</span><br><span class="line">&gt;&gt;&gt; t = [&quot;FishC&quot;, &quot;Apple&quot;, &quot;Book&quot;, &quot;Banana&quot;, &quot;Pen&quot;]</span><br><span class="line">&gt;&gt;&gt; sorted(t)</span><br><span class="line">[&#x27;Apple&#x27;, &#x27;Banana&#x27;, &#x27;Book&#x27;, &#x27;FishC&#x27;, &#x27;Pen&#x27;]</span><br><span class="line">&gt;&gt;&gt; sorted(t, key=len)</span><br><span class="line">[&#x27;Pen&#x27;, &#x27;Book&#x27;, &#x27;FishC&#x27;, &#x27;Apple&#x27;, &#x27;Banana&#x27;]</span><br></pre></td></tr></table></figure>
<p>sorted(t, key&#x3D;len) 这个，因为这个 key 参数，指定的是一个干预排序算法的函数。<br>比如这里我们指定为 len() 函数，那么 Python 在排序的过程中，就会先将列表中的每一个元素调用一次 len() 函数，然后比较的是 len() 返回的结果。<br>所以，sorted(t, key&#x3D;len) 比较的就是每个元素的长度。</p>
<p>reverse() 函数将返回参数的反向迭代器。</p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 2, 5, 8, 0]</span><br><span class="line">&gt;&gt;&gt; reverse(s)</span><br><span class="line">&lt;list_reverseiterator object at 0x0000022926732AC0&gt;</span><br></pre></td></tr></table></figure>
<p>大家看，它不是直接返回所见即所得的结果，它返回的一串奇奇怪怪的英文……<br>刚刚我们说过，它返回的结果是一个迭代器，并且我们可以把它当可迭代对象处理。<br>既然如此，我们就可以使用 list() 函数将其转换为列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(reverse(s))</span><br><span class="line">[0, 8, 5, 2, 1]</span><br></pre></td></tr></table></figure>
<p>reverse() 函数也同样支持任何形式的可迭代对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(reverse(&quot;FishC&quot;))</span><br><span class="line">[&#x27;C&#x27;, &#x27;h&#x27;, &#x27;s&#x27;, &#x27;i&#x27;, &#x27;F&#x27;]</span><br><span class="line">&gt;&gt;&gt; list(reverse((1, 2, 5, 9, 3)))</span><br><span class="line">[3, 9, 5, 2, 1]</span><br><span class="line">&gt;&gt;&gt; list(reverse(range(0, 10)))</span><br><span class="line">[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span><br></pre></td></tr></table></figure>

<h3 id="11-11-all-和any"><a href="#11-11-all-和any" class="headerlink" title="11.11 all()和any()"></a>11.11 all()和any()</h3><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191253-1-1.html">all()</a> 函数是判断可迭代对象中是否所有元素的值都为真；</p>
<p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191254-1-1.html">any()</a> 函数则是判断可迭代对象中是否存在某个元素的值为真。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 1, 0]</span><br><span class="line">&gt;&gt;&gt; y = [1, 1, 9]</span><br><span class="line">&gt;&gt;&gt; all(x)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; all(y)</span><br><span class="line">Ture</span><br><span class="line">&gt;&gt;&gt; any(x)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; any(y)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h3 id="11-12-enumerate"><a href="#11-12-enumerate" class="headerlink" title="11.12  enumerate()"></a>11.12  enumerate()</h3><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191255-1-1.html">enumerate()</a> 函数用于返回一个枚举对象，它的功能就是将可迭代对象中的每个元素及从 0 开始的序号共同构成一个二元组的列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; seasons = [&quot;Spring&quot;, &quot;Summer&quot;, &quot;Fall&quot;, &quot;Winter&quot;]</span><br><span class="line">&gt;&gt;&gt; list(enumerate(seasons))</span><br><span class="line">[(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]</span><br></pre></td></tr></table></figure>
<p>它有一个 start 参数，可以自定义序号开始的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i, j in enumerate(seasons, start=10):</span><br><span class="line">...     print(i, &quot;-&gt;&quot;, j)</span><br><span class="line">... </span><br><span class="line">10 -&gt; Spring</span><br><span class="line">11 -&gt; Summer</span><br><span class="line">12 -&gt; Fall</span><br><span class="line">13 -&gt; Winter</span><br></pre></td></tr></table></figure>

<h3 id="11-13-zip"><a href="#11-13-zip" class="headerlink" title="11.13 zip()"></a>11.13 zip()</h3><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191256-1-1.html">zip()</a> 函数用于创建一个聚合多个可迭代对象的迭代器。</p>
<p>做法是将作为参数传入的每个可迭代对象的每个元素依次组合成元组，即第 i 个元组包含来自每个参数的第 i 个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y = [4, 5, 6]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(x, y)</span><br><span class="line">&gt;&gt;&gt; list(zipped)</span><br><span class="line">[(1, 4), (2, 5), (3, 6)]</span><br><span class="line">&gt;&gt;&gt; z = [7, 8, 9]</span><br><span class="line">&gt;&gt;&gt; zipped = zip(x, y, z)</span><br><span class="line">&gt;&gt;&gt; list(zipped)</span><br><span class="line">[(1, 4, 7), (2, 5, 8), (3, 6, 9)]</span><br></pre></td></tr></table></figure>

<p>这里有一点需要大家注意的，就是如果传入的可迭代对象长度不一致，那么将会以最短的那个为准：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; z = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; zipped = zip(x, y, z)</span><br><span class="line">&gt;&gt;&gt; list(zipped)</span><br><span class="line">[(1, 4, &#x27;F&#x27;), (2, 5, &#x27;i&#x27;), (3, 6, &#x27;s&#x27;)]</span><br></pre></td></tr></table></figure>
<p>当我们不关心较长的可迭代对象多出的数据时，使用 zip() 函数无疑是最佳的选择，因为它自动裁掉多余的部分。</p>
<p>但是，如果那些值对于我们来说是有意义的，我们可以使用 itertools 模块的 zip_longest() 函数来代替：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import itertools</span><br><span class="line">&gt;&gt;&gt; zipped = itertools.zip_longest(x, y, z)</span><br><span class="line">&gt;&gt;&gt; list(zipped)</span><br><span class="line">[(1, 4, &#x27;F&#x27;), (2, 5, &#x27;i&#x27;), (3, 6, &#x27;s&#x27;), (None, None, &#x27;h&#x27;), (None, None, &#x27;C&#x27;)]</span><br></pre></td></tr></table></figure>

<h3 id="11-14-map"><a href="#11-14-map" class="headerlink" title="11.14 map()"></a>11.14 map()</h3><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191261-1-1.html">map()</a> 函数会根据提供的函数对指定的可迭代对象的每个元素进行运算，并将返回运算结果的迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mapped = map(ord, &quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; list(mapped)</span><br><span class="line">[70, 105, 115, 104, 67]</span><br></pre></td></tr></table></figure>
<p>如果指定的函数需要两个参数，后面跟着的可迭代对象的数量也应该是两个：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; mapped = map(pow, [2, 3, 10], [5, 2, 3]))</span><br><span class="line">&gt;&gt;&gt; list(mapped)</span><br><span class="line">[32, 9, 1000]</span><br></pre></td></tr></table></figure>
<p>上面代码其实就相当于是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [pow(2, 5), pow(3, 2), pow(10, 3)]</span><br><span class="line">[32, 9, 1000]</span><br></pre></td></tr></table></figure>
<p>可以看出，如果数量一多，使用 map() 函数要方便许多。</p>
<p>如果可迭代对象的长度不一致，那么 Python 采取的做法跟 zip() 函数一样，都是在最短的可迭代对象终止时结束：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(map(max, [1, 3, 5], [2, 2, 2], [0, 3, 9, 8]))</span><br><span class="line">[2, 3, 9]</span><br></pre></td></tr></table></figure>

<h3 id="11-15-filter"><a href="#11-15-filter" class="headerlink" title="11.15 filter()"></a>11.15 filter()</h3><p>与 map() 函数类似，<a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-191307-1-1.html">filter()</a> 函数也是需要传入一个函数作为参数，不过 filter() 函数是根据提供的函数，对指定的可迭代对象的每个元素进行运算，并将运算结果为真的元素，以迭代器的形式返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; filter(str.islower, &quot;FishC&quot;)</span><br><span class="line">&lt;filter object at 0x000001B5170FEFA0&gt;</span><br></pre></td></tr></table></figure>
<p>上面代码我们传入的是字符串的 islower() 方法，作用就是判断传入的参数是否为小写字母，结合到 filter() 函数中使用，就是剔除大写字母，保留小写字母的作用。</p>
<p>如果提供的函数是 None，则会假设它是一个 “鉴真” 函数，即可迭代对象中所有值为假的元素会被移除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(filter(None, [True, False, 1, 0]))</span><br><span class="line">[True, 1]</span><br></pre></td></tr></table></figure>

<h3 id="11-16-可迭代对象和迭代器"><a href="#11-16-可迭代对象和迭代器" class="headerlink" title="11.16 可迭代对象和迭代器"></a>11.16 可迭代对象和迭代器</h3><p>最大的区别是：可迭代对象咱们可以对其进行重复的操作，而迭代器则是一次性的！</p>
<p>将可迭代对象转换为迭代器：iter() 函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = [1, 2, 3, 4, 5]</span><br><span class="line">&gt;&gt;&gt; y = iter(x)</span><br></pre></td></tr></table></figure>
<p>通过 type() 函数，我们可以观察到这个区别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; type(x)</span><br><span class="line">&lt;class &#x27;list&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; type(y)</span><br><span class="line">&lt;class &#x27;list_iterator&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>最后，BIF 里面有一个 next() 函数，它是专门针对迭代器的。<br>它的作用就是逐个将迭代器中的元素提取出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(y)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#52&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    next(y)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>现在如果不想它抛出异常，那么可以给它传入第二个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; z = iter(x)</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(z, &quot;没啦，被你掏空啦~&quot;)</span><br><span class="line">&#x27;没啦，被你掏空啦~&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="12-字典"><a href="#12-字典" class="headerlink" title="12 字典"></a>12 字典</h2><h3 id="12-1-字典的关键特征"><a href="#12-1-字典的关键特征" class="headerlink" title="12.1 字典的关键特征"></a>12.1 字典的关键特征</h3><p>字典是 Python 中唯一实现映射关系的内置类型。<br>字典的关键符号是大括号（{}）和冒号（:）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&quot;吕布&quot;:&quot;口口布&quot;, &quot;关羽&quot;:&quot;关习习&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; type(d)</span><br><span class="line">&lt;class &#x27;dict&#x27;&gt;</span><br></pre></td></tr></table></figure>
<p>这里就是两对映射关系，我们将冒号的左边称为字典的 “键”，右边称为字典的 “值”。<br>在字典中，只要我们提供键，就可以获取其对应的值。方法跟序列类似，只不过这次在方括号中，咱们使用的是键，而非索引值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&quot;吕布&quot;]</span><br><span class="line">&#x27;口口布&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="12-2-创建字典"><a href="#12-2-创建字典" class="headerlink" title="12.2 创建字典"></a>12.2 创建字典</h3><p>创建字典有很多种方法，这里我们把官方文档列举的6种方法介绍给大家！<br>OK，第一种就是刚刚给大家演示过的，直接使用大括号和冒号的组合，将映射关系给“套牢”：<br><code>&gt;&gt;&gt; a = &#123;&quot;吕布&quot;:&quot;口口布&quot;, &quot;关羽&quot;:&quot;关习习&quot;, &quot;刘备&quot;:&quot;刘baby&quot;&#125;</code><br>第二种，使用<code>dict()</code>函数，跟<code>list()、tuple()、str()</code>类似，<code>dict()</code>函数用来生成字典，它的每个参数就是一个键值对，键与值直接使用等号<br><code>&gt;&gt;&gt; b = dict(吕布=&quot;口口布&quot;, 关羽=&quot;关习习&quot;, 刘备=&quot;刘baby&quot;)</code><br>注意：这种写法要求你不能往键上面加引号，尽管它是一个字符串，但是你加引号就会出错.</p>
<p>第三种，使用列表作为参数，列表中的每个元素是使用元组包裹起来的键值对<br><code>&gt;&gt;&gt; c = dict([(&quot;吕布&quot;,&quot;口口布&quot;), (&quot;关羽&quot;,&quot;关习习&quot;), (&quot;刘备&quot;,&quot;刘baby&quot;)])</code><br>第四种，属于“无病呻吟”版本，就是将第一种方法作为参数给到 dict() 函数：<br><code>&gt;&gt;&gt; d = dict(&#123;&quot;刘备&quot;: &quot;刘baby&quot;, &quot;关羽&quot;: &quot;关习习&quot;, &quot;吕布&quot;: &quot;口口布&quot;&#125;)</code><br>第五种，混合拳法：<br><code>&gt;&gt;&gt; e = dict(&#123;&quot;吕布&quot;:&quot;口口布&quot;, &quot;刘备&quot;:&quot;刘baby&quot;&#125;, 关羽=&quot;关习习&quot;)</code><br>第六种，zip() 函数大家应该还有印象吧？它的作用是创建一个聚合多个可迭代对象的迭代器，对吧？那么，它也是可以作为参数传给 dict() 函数的：<br><code>&gt;&gt;&gt; f = dict(zip([&quot;吕布&quot;,&quot;关羽&quot;,&quot;刘备&quot;], [&quot;口口布&quot;,&quot;关习习&quot;,&quot;刘baby&quot;]))</code></p>
<h3 id="12-3-增"><a href="#12-3-增" class="headerlink" title="12.3 增"></a>12.3 增</h3><p>首先是 fromkeys(iterable[, value]) 方法，这个可以算是字典中最特殊的方法，它可以使用 iterable 参数指定的可迭代对象来创建一个新字典，并将所有的值初始化为 value 参数指定的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = dict.fromkeys(&quot;Fish&quot;, 250)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 250, &#x27;i&#x27;: 250, &#x27;s&#x27;: 250, &#x27;h&#x27;: 250&#125;</span><br></pre></td></tr></table></figure>
<p>如果不指定 value 参数，则采用默认值 None：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = dict.fromkeys(&quot;Fish&quot;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: None, &#x27;s&#x27;: None, &#x27;h&#x27;: None&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法适用于从无到有，创建一个所有键的值都相同的字典。<br>这招对于快速初始化一个字典非常有用，如果需要修改某个键的值，这么做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;F&#x27;] = 70</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: None, &#x27;s&#x27;: None, &#x27;h&#x27;: None&#125;</span><br></pre></td></tr></table></figure>
<p>如果在字典中找不到对应的键，那么同样的操作就会变成增加一个新的键值对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;C&#x27;] = 67</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: None, &#x27;s&#x27;: None, &#x27;h&#x27;: None, &#x27;C&#x27;: 67&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-4-删"><a href="#12-4-删" class="headerlink" title="12.4 删"></a>12.4 删</h3><p>删除字典中的指定元素我们可以使用 pop() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&#x27;s&#x27;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: None, &#x27;h&#x27;: None, &#x27;C&#x27;: 67&#125;</span><br></pre></td></tr></table></figure>
<p>那么你会发现，如果 pop() 一个不存在的键，那么会抛出异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&quot;狗&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#7&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d.pop(&quot;狗&quot;)</span><br><span class="line">KeyError: &#x27;狗&#x27;</span><br></pre></td></tr></table></figure>
<p>如果你想让 Python 别这么激动，可以指定一个 default 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.pop(&quot;狗&quot;, &quot;没有~&quot;)</span><br><span class="line">&#x27;没有~&#x27;</span><br></pre></td></tr></table></figure>
<p>跟 pop() 方法类似的还有一个 popitem()，在 Python3.7 之前，它是随机删除一个键值对，在 Python3.7 之后，它删除的是最后一个加入字典的键值对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.popitem()</span><br><span class="line">(&#x27;C&#x27;, 67)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: None, &#x27;h&#x27;: None&#125;</span><br></pre></td></tr></table></figure>
<p>然后 del 关键字也可以删除一个指定的字典元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del d[&#x27;i&#x27;]</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;h&#x27;: None&#125;</span><br></pre></td></tr></table></figure>
<p>当然，如果 del 直接加上字典的变量名就是将整个字典给干掉：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; del d</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#14&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d</span><br><span class="line">NameError: name &#x27;d&#x27; is not defined</span><br></pre></td></tr></table></figure>
<p>如果我们只希望清空字典中的内容，可以使用 clear() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = dict.fromkeys(&quot;FishC&quot;, 250)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 250, &#x27;i&#x27;: 250, &#x27;s&#x27;: 250, &#x27;h&#x27;: 250, &#x27;C&#x27;: 250&#125;</span><br><span class="line">&gt;&gt;&gt; d.clear()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="12-5-改"><a href="#12-5-改" class="headerlink" title="12.5 改"></a>12.5 改</h3><p>类似于序列的操作，只需要指定一个存在于字典中的键，就可以修改其对应的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = dict.fromkeys(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: None, &#x27;s&#x27;: None, &#x27;h&#x27;: None, &#x27;C&#x27;: None&#125;</span><br><span class="line">&gt;&gt;&gt; d[&#x27;s&#x27;] = 115</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: None, &#x27;s&#x27;: 115, &#x27;h&#x27;: None, &#x27;C&#x27;: None&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们想要同时修改多个键值对，那么说实话，逐个操作就有点太麻烦了。<br>这时候，我们可以使用字典的 update() 方法，可以同时给它传入多个键值对，也可以直接给它传入另外一个字典，或者一个包含键值对的可迭代对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.update(&#123;&#x27;i&#x27;:105, &#x27;h&#x27;:104&#125;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: None, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: None&#125;</span><br><span class="line">&gt;&gt;&gt; d.update(F=&#x27;70&#x27;, C=&#x27;67&#x27;)</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: &#x27;70&#x27;, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: &#x27;67&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-6-查"><a href="#12-6-查" class="headerlink" title="12.6 查"></a>12.6 查</h3><p>最简单的查方法就是你给它一个键，它返回你对应的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;C&#x27;]</span><br><span class="line">67</span><br></pre></td></tr></table></figure>
<p>如果指定的键不存在于字典中，那么会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&#x27;c&#x27;]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d[&#x27;c&#x27;]</span><br><span class="line">KeyError: &#x27;c&#x27;</span><br></pre></td></tr></table></figure>

<p>这在有些时候会被认为是用户体验不佳的表现，所以更好的方法是使用 get() 方法，它可以传入一个 default 参数，指定找不到键时返回的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.get(&#x27;c&#x27;, &quot;这里没有c&quot;)</span><br><span class="line">&#x27;这里没有c&#x27;</span><br></pre></td></tr></table></figure>

<p>还有一种情况是我们需要查找一个键是否存在于字典中，如果在，返回它对应的值；如果不在，给它指定一个新的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.setdefault(&#x27;C&#x27;, &quot;code&quot;)</span><br><span class="line">67</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67&#125;</span><br><span class="line">&gt;&gt;&gt; d.setdefault(&#x27;c&#x27;, &quot;code&quot;)</span><br><span class="line">&#x27;code&#x27;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67, &#x27;c&#x27;: &#x27;code&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>对比前面直接复制的操作，这么做的一个显而易见的好处就是不会破坏到已经存在的键值对。</p>
<h3 id="12-7-视图对象"><a href="#12-7-视图对象" class="headerlink" title="12.7 视图对象"></a>12.7 视图对象</h3><p>items()、keys() 和 values() 三个方法分别用于获取字典的键值对、键和值三者的视图对象。</p>
<p>什么是视图对象呢？</p>
<p>这个名字听着挺新鲜，字面上的解释是：视图对象就是字典的一个动态视图，这意味着当字典内容改变时，视图对象的内容也会相应地跟着改变。</p>
<p>举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67, &#x27;c&#x27;: &#x27;code&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; items = d.items()</span><br><span class="line">&gt;&gt;&gt; keys = d.keys()</span><br><span class="line">&gt;&gt;&gt; values = d.values()</span><br><span class="line">&gt;&gt;&gt; items</span><br><span class="line">dict_items([(&#x27;F&#x27;, 70), (&#x27;i&#x27;, 105), (&#x27;s&#x27;, 115), (&#x27;h&#x27;, 104), (&#x27;C&#x27;, 67), (&#x27;c&#x27;, &#x27;code&#x27;)])</span><br><span class="line">&gt;&gt;&gt; keys</span><br><span class="line">dict_keys([&#x27;F&#x27;, &#x27;i&#x27;, &#x27;s&#x27;, &#x27;h&#x27;, &#x27;C&#x27;, &#x27;c&#x27;])</span><br><span class="line">&gt;&gt;&gt; values</span><br><span class="line">dict_values([70, 105, 115, 104, 67, &#x27;code&#x27;])</span><br><span class="line">&gt;&gt;&gt; d.pop(&#x27;c&#x27;)</span><br><span class="line">&#x27;code&#x27;</span><br><span class="line">&gt;&gt;&gt; items</span><br><span class="line">dict_items([(&#x27;F&#x27;, 70), (&#x27;i&#x27;, 105), (&#x27;s&#x27;, 115), (&#x27;h&#x27;, 104), (&#x27;C&#x27;, 67)])</span><br><span class="line">&gt;&gt;&gt; keys</span><br><span class="line">dict_keys([&#x27;F&#x27;, &#x27;i&#x27;, &#x27;s&#x27;, &#x27;h&#x27;, &#x27;C&#x27;])</span><br><span class="line">&gt;&gt;&gt; values</span><br><span class="line">dict_values([70, 105, 115, 104, 67])</span><br></pre></td></tr></table></figure>
<p>最后，为了方便地实现浅拷贝，字典也提供了一个 copy() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = d.copy()</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67&#125;</span><br></pre></td></tr></table></figure>

<h3 id="12-8-字典妙用"><a href="#12-8-字典妙用" class="headerlink" title="12.8 字典妙用"></a>12.8 字典妙用</h3><p>使用 len() 函数来获取字典的键值对数量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(d)</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p>使用 in 和 not in 来判断某个键是否存在于字典中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;C&#x27; in d</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#x27;c&#x27; not in d</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>字典也可以转化为列表，使用 list() 函数就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(d)</span><br><span class="line">[&#x27;F&#x27;, &#x27;i&#x27;, &#x27;s&#x27;, &#x27;h&#x27;, &#x27;C&#x27;]</span><br></pre></td></tr></table></figure>
<p>那么 iter() 函数也可以作用于字典，它会将字典的键构成一个迭代器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = iter(d)</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">&#x27;F&#x27;</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">&#x27;i&#x27;</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">&#x27;s&#x27;</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">&#x27;h&#x27;</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">&#x27;C&#x27;</span><br><span class="line">&gt;&gt;&gt; next(e)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    next(e)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>
<p>在 Python3.8 之后的版本中，咱们可以使用 reversed() 函数对字典内部的键值对进行逆向操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(reversed(d))</span><br><span class="line">[&#x27;C&#x27;, &#x27;h&#x27;, &#x27;s&#x27;, &#x27;i&#x27;, &#x27;F&#x27;]</span><br></pre></td></tr></table></figure>
<p>可以看出，reversed(d) 其实相当于 reversed(d.keys()) 的缩写，那么如果我们想要获得值的逆向序列，可以这么做：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(reversed(d.values()))</span><br><span class="line">[67, 104, 115, 105, 70]</span><br></pre></td></tr></table></figure>
<h3 id="12-9-嵌套"><a href="#12-9-嵌套" class="headerlink" title="12.9 嵌套"></a>12.9 嵌套</h3><p>字典也是可以嵌套的，某个键的值是另外一个字典，并不是什么稀奇的事儿，举个例子，假如三国也有语数英：<br><code>&gt;&gt;&gt; d = &#123;&quot;吕布&quot;: &#123;&quot;语文&quot;:60, &quot;数学&quot;:70, &quot;英语&quot;:80&#125;, &quot;关羽&quot;: &#123;&quot;语文&quot;:80, &quot;数学&quot;:90, &quot;英语&quot;:70&#125;&#125;</code><br>如果想要获取吕布的数学成绩，那么就需要进行两次索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&quot;吕布&quot;][&quot;数学&quot;]</span><br><span class="line">70</span><br></pre></td></tr></table></figure>
<p>那嵌套的也可以是一个列表：<br><code>&gt;&gt;&gt; d = &#123;&quot;吕布&quot;: [60, 70, 80], &quot;关羽&quot;: [80, 90, 70]&#125;</code><br>第二次索引，我们当然也得换成下标索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d[&quot;吕布&quot;][1]</span><br><span class="line">70</span><br></pre></td></tr></table></figure>

<h3 id="12-10-字典推导式"><a href="#12-10-字典推导式" class="headerlink" title="12.10 字典推导式"></a>12.10 字典推导式</h3><p>最后高阶的 —— 字典推导式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#x27;F&#x27;:70, &#x27;i&#x27;:105, &#x27;s&#x27;:115, &#x27;h&#x27;:104, &#x27;C&#x27;:67&#125;</span><br><span class="line">&gt;&gt;&gt; b = &#123;v:k for k,v in d.items()&#125;</span><br><span class="line">&gt;&gt;&gt; b</span><br><span class="line">&#123;70: &#x27;F&#x27;, 105: &#x27;i&#x27;, 115: &#x27;s&#x27;, 104: &#x27;h&#x27;, 67: &#x27;C&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67&#125;</span><br></pre></td></tr></table></figure>
<p>看，这样我们轻而易举地将键和值给掉了个位置。<br>当然，我们也可以加上筛选的条件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = &#123;v:k for k,v in d.items() if v &gt; 100&#125;</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&#123;105: &#x27;i&#x27;, 115: &#x27;s&#x27;, 104: &#x27;h&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>利用字典推导式，我们就可以轻易地让 Python 帮你求出字符串的编码值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;x:ord(x) for x in &quot;FishC&quot;&#125;</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&#123;&#x27;F&#x27;: 70, &#x27;i&#x27;: 105, &#x27;s&#x27;: 115, &#x27;h&#x27;: 104, &#x27;C&#x27;: 67&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-集合"><a href="#13-集合" class="headerlink" title="13 集合"></a>13 集合</h2><h3 id="13-1-创建集合"><a href="#13-1-创建集合" class="headerlink" title="13.1 创建集合"></a>13.1 创建集合</h3><p>创建一个集合通常有三种方法：</p>
<ul>
<li>使用花括号，元素之间以逗号分隔：{“FishC”, “Python”}</li>
<li>使用集合推导式：{s for s in “FishC”}</li>
<li>使用类型构造器，也就是 set()：set(“FishC”)</li>
</ul>
<h3 id="13-2-集合具有随机性"><a href="#13-2-集合具有随机性" class="headerlink" title="13.2 集合具有随机性"></a>13.2 集合具有随机性</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; set(&quot;FishC&quot;)</span><br><span class="line">&#123;&#x27;i&#x27;, &#x27;C&#x27;, &#x27;s&#x27;, &#x27;F&#x27;, &#x27;h&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>从这里我们不难发现，集合无序的特征，传进去的是 ‘F’、’i’、’s’、’h’、’C’，它这里显示的却是 ‘i’、’C’、’s’、’F’、’h’，在你们的电脑上结果还可能不一样，这就是随机性。<br>由于集合是无序的，所以我们不能使用下标索引的方式去访问它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; s[0]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    s[0]</span><br><span class="line">TypeError: &#x27;set&#x27; object is not subscriptable</span><br></pre></td></tr></table></figure>
<p>不过我们可以使用 in 和 not in 来判断某个元素是否存在于集合中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#x27;C&#x27; in s</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; &#x27;c&#x27; not in s</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h3 id="13-3-访问集合"><a href="#13-3-访问集合" class="headerlink" title="13.3 访问集合"></a>13.3 访问集合</h3><p>如果想要访问集合中的元素，可以使用迭代的方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for each in s:</span><br><span class="line">...     print(each)</span><br><span class="line">...</span><br><span class="line">F</span><br><span class="line">h</span><br><span class="line">i</span><br><span class="line">s</span><br><span class="line">C</span><br></pre></td></tr></table></figure>

<h3 id="13-4-集合必杀技-——-去重"><a href="#13-4-集合必杀技-——-去重" class="headerlink" title="13.4 集合必杀技 —— 去重"></a>13.4 集合必杀技 —— 去重</h3><p>集合另外一个特点就是唯一性，小甲鱼本鱼觉得，这也是集合最大的优势。比如利用集合，咱们就可以轻松地实现去重的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; set([1, 1, 2, 3, 5])</span><br><span class="line">&#123;1, 2, 3, 5&#125;</span><br></pre></td></tr></table></figure>
<p>在实际开发中，我们经常需要去检测一个列表中是否存在相同的元素？<br>那么在没有学习过集合之前，我们很有可能需要通过迭代来统计每个元素出现的次数，从而判断是否唯一……<br>但是，现在，咱们只需要这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = [1, 1, 2, 3, 5]</span><br><span class="line">&gt;&gt;&gt; len(s) == len(set(s))</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s = [1, 2, 3, 5]</span><br><span class="line">&gt;&gt;&gt; len(s) == len(set(s))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h3 id="13-5-集合的方法"><a href="#13-5-集合的方法" class="headerlink" title="13.5  集合的方法"></a>13.5  集合的方法</h3><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-203569-1-1.html">集合的各种方法大合集</a><br>列表、元组、字符串、字典它们都有一个 copy() 方法，那么集合也不例外：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = s.copy()</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">&#123;&#x27;h&#x27;, &#x27;s&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;C&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们要检测两个集合之间是否毫不相干，可以使用 isdisjoint(other) 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.isdisjoint(set(&quot;Python&quot;))</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s.isdisjoint(set(&quot;JAVA&quot;))</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>那么这个参数它并不要求必须是集合类型，可以是任何一种可迭代对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.isdisjoint(&quot;Python&quot;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s.isdisjoint(&quot;JAVA&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>下面也是一样的，传入的参数，都只要求是可迭代对象的类型即可。<br>如果我们要检测该集合是否为另一个集合的子集，可以使用 issubset(other) 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.issubset(&quot;FishC.com.cn&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>如果我们要检测该集合是否为另一个集合的超集，可以使用 issuperset(other) 方法（对于两个集合 A、B，如果集合 B 中任意一个元素都是集合 A 中的元素，我们就说这两个集合有包含关系，称集合 A 为集合 B 的超集）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.issuperset(&quot;Fish&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>除了检测子集和超集，我们还可以计算当前集合和其它对象共同构造的并集、交集、差集以及对称差集。<br>并集，就是将集合与其它集合的元素合并在一起，组成一个新的集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.union(&#123;1, 2, 3&#125;)</span><br><span class="line">&#123;1, 2, 3, &#x27;h&#x27;, &#x27;s&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;C&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>交集，就是找到多个集合之间共同的那些元素</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.intersection(&quot;Fish&quot;)</span><br><span class="line">&#123;&#x27;h&#x27;, &#x27;s&#x27;, &#x27;i&#x27;, &#x27;F&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>差集，就是找出存在于该集合，但不存在于其它集合中的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.difference(&quot;Fish&quot;)</span><br><span class="line">&#123;&#x27;C&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>同时，上面的这三个都是支持多个参数的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.union(&#123;1, 2, 3&#125;, &quot;Python&quot;)</span><br><span class="line">&#123;1, 2, 3, &#x27;y&#x27;, &#x27;h&#x27;, &#x27;n&#x27;, &#x27;i&#x27;, &#x27;P&#x27;, &#x27;s&#x27;, &#x27;o&#x27;, &#x27;t&#x27;, &#x27;C&#x27;, &#x27;F&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; s.intersection(&quot;Php&quot;, &quot;Python&quot;)</span><br><span class="line">&#123;&#x27;h&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; s.difference(&quot;Php&quot;, &quot;Python&quot;)</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;F&#x27;, &#x27;i&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个是求对称差集，就是排除掉 s 集合和 other 容器中共有的元素后，剩余的所有元素，这个只能支持一个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.symmetric_difference(&quot;Python&quot;)</span><br><span class="line">&#123;&#x27;t&#x27;, &#x27;y&#x27;, &#x27;F&#x27;, &#x27;s&#x27;, &#x27;P&#x27;, &#x27;C&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;i&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>好了，那么上面这 6 种常见的操作，Python 也提供了相应的运算符，可以直接进行运算。<br>检测子集可以使用小于等于号（&lt;&#x3D;）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &lt;= set(&quot;FishC&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>那么检测真子集我们可以使用小于号（&lt;）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &lt; set(&quot;FishC&quot;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s &lt; set(&quot;FishC.com.cn&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>那么反过来，使用大于号（&gt;）和大于等于号（&gt;&#x3D;）就是检测真超集和超集：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &gt; set(&quot;FishC&quot;)</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; s &gt;= set(&quot;FishC&quot;)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>
<p>并集使用管道符（|）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s | &#123;1, 2, 3&#125; | set(&quot;Python&quot;)</span><br><span class="line">&#123;1, 2, 3, &#x27;y&#x27;, &#x27;h&#x27;, &#x27;n&#x27;, &#x27;i&#x27;, &#x27;P&#x27;, &#x27;s&#x27;, &#x27;o&#x27;, &#x27;t&#x27;, &#x27;C&#x27;, &#x27;F&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>交集使用 and 符号（&amp;）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &amp; set(&quot;Php&quot;) &amp; set(&quot;Python&quot;)</span><br><span class="line">&#123;&#x27;h&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>差集使用减号（-）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s - set(&quot;Php&quot;) - set(&quot;Python&quot;)</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;F&#x27;, &#x27;i&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>对称差集使用脱字符（^）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s ^ set(&quot;Python&quot;)</span><br><span class="line">&#123;&#x27;t&#x27;, &#x27;y&#x27;, &#x27;F&#x27;, &#x27;s&#x27;, &#x27;P&#x27;, &#x27;C&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;i&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>注意：使用运算符的话，符号两边都必须是集合类型的数据才可以，不然会报错。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s &lt;= &quot;FishC&quot;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#46&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    s &lt;= &quot;FishC&quot;</span><br><span class="line">TypeError: &#x27;&lt;=&#x27; not supported between instances of &#x27;set&#x27; and &#x27;str&#x27;</span><br><span class="line">&gt;&gt;&gt; s | [1, 2, 3]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    s | [1, 2, 3]</span><br><span class="line">TypeError: unsupported operand type(s) for |: &#x27;set&#x27; and &#x27;list&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="13-6-冻结的集合"><a href="#13-6-冻结的集合" class="headerlink" title="13.6 冻结的集合"></a>13.6 冻结的集合</h3><p>Python 将集合细分为可变和不可变两种对象，前者是 set()，后者是 frozenset()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = frozenset(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; t</span><br><span class="line">frozenset(&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;h&#x27;&#125;)</span><br></pre></td></tr></table></figure>
<p>被冻结的集合（frozenset()）是不支持修改的。<br>如果我们尝试修改它，那么可怕的事情就会发生：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t.update([1, 1], &quot;23&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    t.update([1, 1], &quot;23&quot;)</span><br><span class="line">AttributeError: &#x27;frozenset&#x27; object has no attribute &#x27;update&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="13-7-仅适用于-set-对象的方法"><a href="#13-7-仅适用于-set-对象的方法" class="headerlink" title="13.7 仅适用于 set() 对象的方法"></a>13.7 仅适用于 set() 对象的方法</h3><p><code>update(*others)</code> 方法使用 others 容器中的元素来更新集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = set(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;h&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; s.update([1, 1], &quot;23&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, 1, &#x27;C&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;h&#x27;, &#x27;3&#x27;, &#x27;2&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>intersection_update(*others)、difference_update(*others) 和 symmetric_difference_update(other) 分别是使用前面讲过的交集、差集和对称差集的方式来更新集合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.intersection_update(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;i&#x27;, &#x27;F&#x27;, &#x27;h&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; s.difference_update(&quot;Php&quot;, &quot;Python&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;C&#x27;, &#x27;i&#x27;, &#x27;F&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; s.symmetric_difference_update(&quot;Python&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;t&#x27;, &#x27;C&#x27;, &#x27;o&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;y&#x27;, &#x27;F&#x27;, &#x27;n&#x27;, &#x27;P&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>如果希望要单纯地往集合里添加数据，可以使用 add(elem) 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.add(&quot;45&quot;)</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;s&#x27;, &#x27;t&#x27;, &#x27;C&#x27;, &#x27;o&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;y&#x27;, &#x27;F&#x27;, &#x27;45&#x27;, &#x27;n&#x27;, &#x27;P&#x27;&#125;</span><br></pre></td></tr></table></figure>
<p>在集合中删除某个元素，可以使用 remove(elem) 或者 discard(elem) 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.remove(&quot;瓦迈&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    s.remove(&quot;瓦迈&quot;)</span><br><span class="line">KeyError: &#x27;瓦迈&#x27;</span><br><span class="line">&gt;&gt;&gt; s.discard(&quot;瓦迈&quot;)</span><br></pre></td></tr></table></figure>

<p>删除还有一个 pop() 方法，用于随机从集合中弹出一个元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.pop()</span><br><span class="line">&#x27;s&#x27;</span><br><span class="line">&gt;&gt;&gt; s.pop()</span><br><span class="line">&#x27;t&#x27;</span><br><span class="line">&gt;&gt;&gt; s.pop()</span><br><span class="line">&#x27;C&#x27;</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">&#123;&#x27;o&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;y&#x27;, &#x27;F&#x27;, &#x27;45&#x27;, &#x27;n&#x27;, &#x27;P&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>最后，clear() 方法就是将集合清空：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s.clear()</span><br><span class="line">&gt;&gt;&gt; s</span><br><span class="line">set()</span><br></pre></td></tr></table></figure>

<h3 id="13-8-可哈希"><a href="#13-8-可哈希" class="headerlink" title="13.8 可哈希"></a>13.8 可哈希</h3><p>想要正确地创建字典和集合，是有一个刚性需求的 —— 那就是字典的键，还有集合的元素，它们都必须是可哈希的。<br>如果一个对象是可哈希的，那么就要求它的哈希值必须在其整个程序的生命周期中都保持不变。<br>通过 hash() 函数，可以轻松获取一个对象的哈希值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hash(1)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; hash(1.0)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; hash(1.001)</span><br><span class="line">2305843009213441</span><br></pre></td></tr></table></figure>
<p>这个哈希值有什么用呢？<br>对于我们来说可能没啥用，但对于字典和集合来说，却是 “木之根，水之源”，这里我们就不再展开论述了，再深挖下去就有点越俎代庖的感觉了……<br>有兴趣的童鞋可以看看这一篇扩展阅读 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-205214-1-1.html">Python字典的实现原理</a><br>Python 中大多数不可变对象是可哈希的，而那些可变的容器则不哈希</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hash(&quot;FishC&quot;)</span><br><span class="line">2090433017907150752</span><br><span class="line">&gt;&gt;&gt; hash([1, 2, 3])</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#36&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    hash([1, 2, 3])</span><br><span class="line">TypeError: unhashable type: &#x27;list&#x27;</span><br></pre></td></tr></table></figure>
<p>如果我们把列表换成元组，元组是不可变的对象，那就应该是可哈希的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; hash((1, 2, 3))</span><br><span class="line">529344067295497451</span><br></pre></td></tr></table></figure>
<p>前面我们说了，只有可哈希的对象，才有资格作为字典的键，以及集合的元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &#123;&quot;Python&quot;:520, &quot;FishC&quot;:1314&#125;</span><br><span class="line">&#123;&#x27;Python&#x27;: 520, &#x27;FishC&#x27;: 1314&#125;</span><br><span class="line">&gt;&gt;&gt; &#123;&quot;Python&quot;, &quot;FishC&quot;, 520, 1314&#125;</span><br><span class="line">&#123;520, 1314, &#x27;Python&#x27;, &#x27;FishC&#x27;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="13-9-嵌套的集合"><a href="#13-9-嵌套的集合" class="headerlink" title="13.9 嵌套的集合"></a>13.9 嵌套的集合</h3><p>如果要实现一个嵌套的集合，可不可行？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = &#123;1, 2, 3&#125;</span><br><span class="line">&gt;&gt;&gt; y = &#123;x, 4, 5&#125;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#39&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    y = &#123;x, 4, 5&#125;</span><br><span class="line">TypeError: unhashable type: &#x27;set&#x27;</span><br></pre></td></tr></table></figure>
<p>这样写是不行的，因为集合它是一个可变的容器，而可变的容器则是不可哈希。<br>那我们非要将集合嵌套，还有没有办法？<br>有！<br>没错，使用 “冰山美人” <code>frozenset()</code> 对象</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = frozenset(x)</span><br><span class="line">&gt;&gt;&gt; y = &#123;x, 4, 5&#125;</span><br><span class="line">&gt;&gt;&gt; y</span><br><span class="line">&#123;frozenset(&#123;1, 2, 3&#125;), 4, 5&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-函数"><a href="#14-函数" class="headerlink" title="14 函数"></a>14 函数</h2><p>Python 函数的主要作用就是打包代码。</p>
<p>有两个显著的好处：</p>
<p>可以最大程度地实现代码重用，减少冗余的代码<br>可以将不同功能的代码段进行封装、分解，从而降低结构的复杂度，提高代码的可读性。</p>
<h3 id="14-1-创建和调用函数"><a href="#14-1-创建和调用函数" class="headerlink" title="14.1 创建和调用函数"></a>14.1 创建和调用函数</h3><p>我们使用 def 语句来定义函数，紧跟着的是函数的名字，后面带一对小括号，冒号下面就是函数体，函数体是一个代码块，也就是每次调用函数时将被执行的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>注：pass 是一个空语句，表示不做任何事情，经常是被用来做一个占位符使用的。调用这个函数，只需要在名字后面加上一对小括号：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="14-3-函数的参数"><a href="#14-3-函数的参数" class="headerlink" title="14.3 函数的参数"></a>14.3 函数的参数</h3><p>从调用角度来看，参数可以细分为：形式参数（parameter）和实际参数（argument）。<br>其中，形式参数是函数定义的时候写的参数名字（比如下面例子中的 name 和 times）；实际参数是在调用函数的时候传递进去的值（比如下面例子中的 “Python” 和 5）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(name, times):</span><br><span class="line">...     for i in range(times):</span><br><span class="line">...         print(f&quot;I love &#123;name&#125;.&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;Python&quot;, 5)</span><br><span class="line">I love Python.</span><br><span class="line">I love Python.</span><br><span class="line">I love Python.</span><br><span class="line">I love Python.</span><br><span class="line">I love Python.</span><br></pre></td></tr></table></figure>

<h3 id="14-4-函数的返回值"><a href="#14-4-函数的返回值" class="headerlink" title="14.4 函数的返回值"></a>14.4 函数的返回值</h3><p>有时候，我们可能需要函数干完活之后能给一个反馈，这在 BIF 函数中也很常见，比如 sum() 函数会返回求和后的结果，len() 函数会返回一个元素的长度，而 list() 函数则会将参数转换为列表后返回……<br>只需要使用 return 语句，就可以让咱们自己定制的函数实现返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def div(x, y):</span><br><span class="line">...     z = x / y</span><br><span class="line">...     return z</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; div(4, 2)</span><br><span class="line">2.0</span><br></pre></td></tr></table></figure>
<p>最后，如果一个函数没有通过 return 语句返回，它也会自己在执行完函数体中的语句之后，悄悄地返回一个 None 值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; print(myfunc())</span><br><span class="line">None</span><br></pre></td></tr></table></figure>

<h3 id="14-5-位置参数"><a href="#14-5-位置参数" class="headerlink" title="14.5 位置参数"></a>14.5 位置参数</h3><p>在通常的情况下，实参是按照形参定义的顺序进行传递的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(s, vt, o):</span><br><span class="line">...    return &quot;&quot;.join((o, vt, s))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;我&quot;, &quot;打了&quot;, &quot;小甲鱼&quot;)</span><br><span class="line">&#x27;小甲鱼打了我&#x27;</span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;小甲鱼&quot;, &quot;打了&quot;, &quot;我&quot;)</span><br><span class="line">&#x27;我打了小甲鱼&#x27;</span><br></pre></td></tr></table></figure>
<p>由于在定义函数的时候，就已经把参数的名字和位置确定了下来，我们将 Python 中这类位置固定的参数称之为位置参数。</p>
<h3 id="14-6-关键字参数"><a href="#14-6-关键字参数" class="headerlink" title="14.6 关键字参数"></a>14.6 关键字参数</h3><p>使用关键字参数，我们只需要知道形参的名字就可以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc(o=&quot;我&quot;, vt=&quot;打了&quot;, s=&quot;小甲鱼&quot;)</span><br><span class="line">&#x27;我打了小甲鱼&#x27;</span><br></pre></td></tr></table></figure>
<p>尽管使用关键字参数需要你多敲一些字符，但对于参数特别多的函数，这一招尤其管用。<br>如果同时使用位置参数和关键字参数，那么使用顺序是需要注意一下的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc(o=&quot;我&quot;, &quot;清蒸&quot;, &quot;小甲鱼&quot;)</span><br><span class="line">SyntaxError: positional argument follows keyword argument</span><br></pre></td></tr></table></figure>
<p>比如这样就不行了，因为位置参数必须是在关键字参数之前，之间也不行哈。</p>
<h3 id="14-7-默认参数"><a href="#14-7-默认参数" class="headerlink" title="14.7 默认参数"></a>14.7 默认参数</h3><p>Python 还允许函数的参数在定义的时候指定默认值，这样以来，在函数调用的时候，如果没有传入实参，那么将采用默认的参数值代替：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(s, vt, o=&quot;小甲鱼&quot;):</span><br><span class="line">...     return &quot;&quot;.join((o, vt, s))</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;香蕉&quot;, &quot;吃&quot;)</span><br><span class="line">&#x27;小甲鱼吃香蕉&#x27;</span><br></pre></td></tr></table></figure>
<p>默认参数的意义就是当用户没有输入该参数的时候，有一个默认值可以使用，不至于造成错误。<br>如果用户指定了该参数值，那么默认的值就会被覆盖：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc(&quot;香蕉&quot;, &quot;吃&quot;, &quot;不二如是&quot;)</span><br><span class="line">&#x27;不二如是吃香蕉&#x27;</span><br></pre></td></tr></table></figure>
<p>这里也有一点是需要注意的，就是如果要使用默认参数，那么应该把它们摆在最后：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(s=&quot;苹果&quot;, vt, o=&quot;小甲鱼&quot;):</span><br><span class="line">        </span><br><span class="line">SyntaxError: non-default argument follows default argument</span><br><span class="line">&gt;&gt;&gt; def myfunc(vt, s=&quot;苹果&quot;, o=&quot;小甲鱼&quot;):</span><br><span class="line">...     return &quot;&quot;.join((o, vt, s))</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;拱了&quot;)</span><br><span class="line">&#x27;小甲鱼拱了苹果&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="14-8-只能使用位置参数"><a href="#14-8-只能使用位置参数" class="headerlink" title="14.8 只能使用位置参数"></a>14.8 只能使用位置参数</h3><p>咱们在使用 help() 函数查看函数文档的时候呢，经常会在函数原型的参数中发现一个斜杠（&#x2F;），比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; help(abs)</span><br><span class="line">Help on built-in function abs in module builtins:</span><br><span class="line">    </span><br><span class="line">abs(x, /)</span><br><span class="line">    Return the absolute value of the argument.</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; help(sum)</span><br><span class="line">Help on built-in function sum in module builtins:</span><br><span class="line">    </span><br><span class="line">sum(iterable, /, start=0)</span><br><span class="line">    Return the sum of a &#x27;start&#x27; value (default: 0) plus an iterable of numbers</span><br><span class="line">    </span><br><span class="line">    When the iterable is empty, return the start value.</span><br><span class="line">    This function is intended specifically for use with numeric values and may</span><br><span class="line">    reject non-numeric types.</span><br></pre></td></tr></table></figure>
<p>这表示斜杠左侧的参数必须传递位置参数，不能是关键字参数，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abs(-1.5)</span><br><span class="line">1.5</span><br><span class="line">&gt;&gt;&gt; abs(x = -1.5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#67&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    abs(x = -1.5)</span><br><span class="line">TypeError: abs() takes no keyword arguments</span><br></pre></td></tr></table></figure>
<p>那斜杠右侧的话呢，就随你了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sum([1, 2, 3], start=6)</span><br><span class="line">12</span><br><span class="line">&gt;&gt;&gt; sum([1, 2, 3], 6)</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h3 id="14-9-只能使用关键字参数"><a href="#14-9-只能使用关键字参数" class="headerlink" title="14.9 只能使用关键字参数"></a>14.9 只能使用关键字参数</h3><p>既然有限制 “只能使用位置参数”，那有没有那种限制 “只能使用关键字参数” 的语法呢？<br>那就是利用星号（*）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def abc(a, *, b, c):</span><br><span class="line">...     print(a, b, c)</span><br></pre></td></tr></table></figure>
<p>这样，参数 a 既可以是位置参数也可以是关键字参数，但参数 b 和参数 c 就必须是关键字参数，才不会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; abc(1, 2, 3)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#98&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    abc(1, 2, 3)</span><br><span class="line">TypeError: abc() takes 1 positional argument but 3 were given</span><br><span class="line">&gt;&gt;&gt; abc(1, b=2, c=3)</span><br><span class="line">1 2 3</span><br><span class="line">&gt;&gt;&gt; abc(a=3, b=2, c=1)</span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure>

<h3 id="14-10-收集参数"><a href="#14-10-收集参数" class="headerlink" title="14.10 收集参数"></a>14.10 收集参数</h3><p>当我们在定义一个函数的时候，假如需要传入的参数的个数是不确定的，按照一般的写法可能需要定义很多个相同的函数然后指定不同的参数个数，这显然是很麻烦的，不能根本解决问题。<br>为解决这个问题，Python 就推出了收集参数的概念。所谓的收集参数，就是说只指定一个参数，然后允许调用函数时传入任意数量的参数。<br>定义收集参数其实也很简单，即使在形参的前面加上星号（*）来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(*args):</span><br><span class="line">...     print(&quot;有%d个参数。&quot; % len(args))</span><br><span class="line">...     print(&quot;第2个参数是：%s&quot; % args[1])</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; myfunc(&quot;小甲鱼&quot;, &quot;不二如是&quot;)</span><br><span class="line">有2个参数。</span><br><span class="line">第2个参数是：不二如是</span><br><span class="line">&gt;&gt;&gt; myfunc(1, 2, 3, 4, 5)</span><br><span class="line">有5个参数。</span><br><span class="line">第二个参数是：2</span><br></pre></td></tr></table></figure>

<p>如果在收集参数后面还需要指定其它参数，那么在调用函数的时候就应该使用关键参数来指定后面的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(*args, a, b):</span><br><span class="line">...     print(args, a, b)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc(1, 2, 3, a=4, b=5)</span><br><span class="line">(1, 2, 3) 4 5</span><br></pre></td></tr></table></figure>
<p>对于这种情况，在传递参数的时候就必须要使用关键字参数了，因为字典的元素都是键值对嘛，所以等号（&#x3D;）左侧是键，右侧是值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc(a=1, b=2, c=3)</span><br><span class="line">&#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span><br></pre></td></tr></table></figure>
<p>混合起来使用就更加灵活了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc(a, *b, **c):</span><br><span class="line">...     print(a, b, c)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc(1, 2, 3, 4, x=5, y=6)</span><br><span class="line">1 (2, 3, 4) &#123;&#x27;x&#x27;: 5, &#x27;y&#x27;: 6&#125;</span><br></pre></td></tr></table></figure>

<h3 id="14-11-解包参数"><a href="#14-11-解包参数" class="headerlink" title="14.11 解包参数"></a>14.11 解包参数</h3><p>这一个星号（*）和两个星号（**）不仅可以用在函数定义的时候，在函数调用的时候也有特殊效果，在形参上使用称之为参数的打包，在实参上的使用，则起到了相反的效果，即解包参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; args = (1, 2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; def myfunc(a, b, c, d):</span><br><span class="line">...     print(a, b, c, d)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc(*args)</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>
<p>那么两个星号（**）对应的是关键字参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; args = &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2, &#x27;c&#x27;:3, &#x27;d&#x27;:4&#125;</span><br><span class="line">&gt;&gt;&gt; myfunc(**args)</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure>

<h3 id="14-12-局部作用域"><a href="#14-12-局部作用域" class="headerlink" title="14.12 局部作用域"></a>14.12 局部作用域</h3><p>如果一个变量定义的位置是在一个函数里面，那么它的作用域就仅限于函数中，我们将它称为局部变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     x = 520</span><br><span class="line">...     print(x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc()</span><br><span class="line">520</span><br></pre></td></tr></table></figure>
<p>变量 x 是在函数 myfunc() 中定义的，所以它的作用域仅限于该函数，如果我们尝试在函数的外部访问这个变量，那么就会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#5&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    print(x)</span><br><span class="line">NameError: name &#x27;x&#x27; is not defined</span><br></pre></td></tr></table></figure>

<h3 id="14-13-全局作用域"><a href="#14-13-全局作用域" class="headerlink" title="14.13 全局作用域"></a>14.13 全局作用域</h3><p>如果是在任何函数的外部去定义一个变量，那么它的作用域就是全局的，我们也将其称为全局变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 880</span><br><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     print(x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc()</span><br><span class="line">880</span><br></pre></td></tr></table></figure>
<p>如果在函数中存在一个跟全局变量同名的局部变量，会发生什么样的事情呢？<br>在函数中，局部变量就会覆盖同名的全局变量的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 880</span><br><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     x = 520</span><br><span class="line">...     print(x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc()</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">880</span><br></pre></td></tr></table></figure>
<p>注意：代码中两个 x 并非同一个变量，只是由于作用域不同，它们同名但并不同样。</p>
<h3 id="14-14-global-语句"><a href="#14-14-global-语句" class="headerlink" title="14.14 global 语句"></a>14.14 global 语句</h3><p>通常我们无法在函数内部修改全局变量的值，除非使用 global 语句破除限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = 880</span><br><span class="line">&gt;&gt;&gt; def myfunc():</span><br><span class="line">...     global x</span><br><span class="line">...     x = 520</span><br><span class="line">...     print(x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; myfunc()</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; print(x)</span><br><span class="line">520</span><br></pre></td></tr></table></figure>

<h3 id="14-15-嵌套函数"><a href="#14-15-嵌套函数" class="headerlink" title="14.15 嵌套函数"></a>14.15 嵌套函数</h3><p>函数也是可以嵌套的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funA():</span><br><span class="line">...     x = 520</span><br><span class="line">...     def funB():</span><br><span class="line">...         x = 880</span><br><span class="line">...         print(&quot;In funB, x =&quot;, x)</span><br><span class="line">...     print(&quot;In funA, x =&quot;, x)</span><br></pre></td></tr></table></figure>
<p>在外部函数 funA() 里面嵌套了一个内部函数 funB()，那么这个内部函数是无法被直接调用的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; funB()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#23&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    funB()</span><br><span class="line">NameError: name &#x27;funB&#x27; is not defined</span><br></pre></td></tr></table></figure>
<p>想要调用 funB()，必须得通过 funA()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funA():</span><br><span class="line">...     x = 520</span><br><span class="line">...     def funB():</span><br><span class="line">...         x = 880</span><br><span class="line">...         print(&quot;In funB, x =&quot;, x)</span><br><span class="line">...     funB()</span><br><span class="line">...     print(&quot;In funA, x =&quot;, x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; funA()</span><br><span class="line">In funB, x = 880</span><br><span class="line">In funA, x = 520</span><br></pre></td></tr></table></figure>
<h3 id="14-16-nonlocal-语句"><a href="#14-16-nonlocal-语句" class="headerlink" title="14.16 nonlocal 语句"></a>14.16 nonlocal 语句</h3><p>通常我们无法在嵌套函数的内部修改外部函数变量的值，除非使用 nonlocal 语句破除限制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funA():</span><br><span class="line">...     x = 520</span><br><span class="line">...     def funB():</span><br><span class="line">...         nonlocal x</span><br><span class="line">...         x = 880</span><br><span class="line">...         print(&quot;In funB, x =&quot;, x)</span><br><span class="line">...     funB()</span><br><span class="line">...     print(&quot;In funA, x =&quot;, x)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; funA()</span><br><span class="line">In funB, x = 880</span><br><span class="line">In funA, x = 880</span><br></pre></td></tr></table></figure>
<h3 id="14-17-LEGB-规则"><a href="#14-17-LEGB-规则" class="headerlink" title="14.17 LEGB 规则"></a>14.17 LEGB 规则</h3><p>只要记住 LEGB，那么就相当于掌握了 Python 变量的解析机制。</p>
<p>其中：</p>
<ul>
<li>L 是 Local，是局部作用域</li>
<li>E 是 Enclosed，是嵌套函数的外层函数作用域</li>
<li>G 是 Global，是全局作用域</li>
<li>B 是 Build-In，也就是内置作用域</li>
</ul>
<p>最后一个是 B，也就是 Build-In，最没地位的那一个。</p>
<p>比如说 Build-In Function —— BIF，你只要起一个变量名跟它一样，那么就足以把这个内置函数给 “毁了”：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str = &quot;小甲鱼把str给毁了&quot;</span><br><span class="line">&gt;&gt;&gt; str(520)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#1&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    str(520)</span><br><span class="line">TypeError: &#x27;str&#x27; object is not callable</span><br></pre></td></tr></table></figure>
<p>是不是，它本来的功能是将参数转换成字符串类型，但由于我们将它作为变量名赋值了，那么 Python 就把它给覆盖了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; str</span><br><span class="line">&#x27;小甲鱼把str给毁了&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="14-18-嵌套作用域的特性"><a href="#14-18-嵌套作用域的特性" class="headerlink" title="14.18 嵌套作用域的特性"></a>14.18 嵌套作用域的特性</h3><p>对于嵌套函数来说，外层函数的作用域是会通过某种形式保存下来的，它并不会跟局部作用域那样，调用完就消失。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funA():</span><br><span class="line">...     x = 520</span><br><span class="line">...     def funB():</span><br><span class="line">...         print(x)</span><br><span class="line">...     return funB</span><br><span class="line">&gt;&gt;&gt; funA()</span><br><span class="line">&lt;function funA.&lt;locals&gt;.funB at 0x0000014C02684040&gt;</span><br><span class="line">&gt;&gt;&gt; funA()()</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; funny = funA()</span><br><span class="line">&gt;&gt;&gt; funny</span><br><span class="line">&lt;function funA.&lt;locals&gt;.funB at 0x0000014C02684550&gt;</span><br><span class="line">&gt;&gt;&gt; funny()</span><br><span class="line">520</span><br></pre></td></tr></table></figure>

<h3 id="14-19-闭包"><a href="#14-19-闭包" class="headerlink" title="14.19 闭包"></a>14.19 闭包</h3><p>所谓闭包（closure），也有人称之为工厂函数（factory function）。</p>
<p>for example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def power(exp):</span><br><span class="line">...     def exp_of(base):</span><br><span class="line">...         return base ** exp</span><br><span class="line">...     return exp_of</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; square = power(2)</span><br><span class="line">&gt;&gt;&gt; cube = power(3)</span><br><span class="line">&gt;&gt;&gt; square</span><br><span class="line">&lt;function power.&lt;locals&gt;.exp_of at 0x000001CF6A1FAF70&gt;</span><br><span class="line">&gt;&gt;&gt; square(2)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; square(5)</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; cube(2)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; cube(5)</span><br><span class="line">125</span><br></pre></td></tr></table></figure>
<p>这里 power() 函数就像是一个工厂，由于参数不同，得到了两个不同的 “生产线”，一个是 square()，一个是 cube()，前者是返回参数的平方，后者是返回参数的立方。</p>
<h3 id="14-20-闭包应用举例"><a href="#14-20-闭包应用举例" class="headerlink" title="14.20 闭包应用举例"></a>14.20 闭包应用举例</h3><p>比如说在游戏开发中，我们需要将游戏中角色的移动位置保护起来，不希望被其他函数轻易就能够修改，所以我们就可以利用闭包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">origin = (0, 0)        # 这个是原点</span><br><span class="line">legal_x = [-100, 100]  # 限定x轴的移动范围</span><br><span class="line">legal_y = [-100, 100]  # 限定y轴的移动范围</span><br><span class="line"># 好，接着我们定义一个create()函数</span><br><span class="line"># 初始化位置是原点</span><br><span class="line">def create(pos_x=0, pos_y=0):</span><br><span class="line">    # 然后我们定义一个实现角色移动的函数moving()</span><br><span class="line">    def moving(direction, step):</span><br><span class="line">    # direction参数设置方向，1为向右或向上，-1为向左或向下，如果是0则不移动</span><br><span class="line">    # step参数是设置移动的距离</span><br><span class="line">        # 为了修改外层作用域的变量</span><br><span class="line">        nonlocal pos_x, pos_y</span><br><span class="line">        # 然后我们真的就去修改它们</span><br><span class="line">        new_x = pos_x + direction[0] * step</span><br><span class="line">        new_y = pos_y + direction[1] * step</span><br><span class="line">        # 检查移动后是否超出x轴的边界</span><br><span class="line">        if new_x &lt; legal_x[0]:</span><br><span class="line">            # 制造一个撞墙反弹的效果</span><br><span class="line">            pos_x = legal_x[0] - (new_x - legal_x[0])</span><br><span class="line">        elif new_x &gt; legal_x[1]:</span><br><span class="line">            pos_x = legal_x[1] - (new_x - legal_x[1])</span><br><span class="line">        else:</span><br><span class="line">            pos_x = new_x</span><br><span class="line">        # 检查移动后是否超出y轴边界</span><br><span class="line">        if new_y &lt; legal_y[0]:</span><br><span class="line">            pos_y = legal_y[0] - (new_y - legal_y[0])</span><br><span class="line">        elif new_y &gt; legal_y[1]:</span><br><span class="line">            pos_y = legal_y[1] - (new_y - legal_y[1])</span><br><span class="line">        else:</span><br><span class="line">            pos_y = new_y</span><br><span class="line">        # 将最终修改后的位置作为结果返回</span><br><span class="line">        return pos_x, pos_y</span><br><span class="line">    # 外层函数返回内层函数的引用</span><br><span class="line">    return moving</span><br></pre></td></tr></table></figure>

<p>程序实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; move = create()</span><br><span class="line">&gt;&gt;&gt; print(&quot;向右移动20步后，位置是:&quot;, move([1, 0], 20))</span><br><span class="line">向右移动20步后，位置是: (20, 0)</span><br><span class="line">&gt;&gt;&gt; print(&quot;向上移动120步后，位置是:&quot;, move([0, 1], 120))</span><br><span class="line">向上移动120步后，位置是: (20, 80)</span><br><span class="line">&gt;&gt;&gt; print(&quot;向左移动66步后，位置是:&quot;, move([-1, 0], 66))</span><br><span class="line">向左移动66步后，位置是: (-46, 80)</span><br><span class="line">&gt;&gt;&gt; print(&quot;向右下角移动88步后，位置是:&quot;, move([1, -1]), 88)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#28&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    print(&quot;向右下角移动88步后，位置是:&quot;, move([1, -1]), 88)</span><br><span class="line">TypeError: moving() missing 1 required positional argument: &#x27;step&#x27;</span><br><span class="line">&gt;&gt;&gt; print(&quot;向右下角移动88步后，位置是:&quot;, move([1, -1], 88))</span><br><span class="line">向右下角移动88步后，位置是: (42, -8)</span><br></pre></td></tr></table></figure>

<h3 id="14-21-装饰器"><a href="#14-21-装饰器" class="headerlink" title="14.21 装饰器"></a>14.21 装饰器</h3><p>装饰器本质上也是一个函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外的功能。</p>
<p>请看下面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">    </span><br><span class="line">def time_master(func):</span><br><span class="line">    def call_func():</span><br><span class="line">        print(&quot;开始运行程序...&quot;)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(&quot;结束程序运行...&quot;)</span><br><span class="line">        print(f&quot;一共耗费了 &#123;(stop-start):.2f&#125; 秒。&quot;)</span><br><span class="line">    return call_func</span><br><span class="line">    </span><br><span class="line">@time_master</span><br><span class="line">def myfunc():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;I love FishC.&quot;)</span><br><span class="line">    </span><br><span class="line">myfunc()</span><br></pre></td></tr></table></figure>
<p>程序实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始运行程序...</span><br><span class="line">I love FishC.</span><br><span class="line">结束程序运行...</span><br><span class="line">一共耗费了 2.01 秒</span><br></pre></td></tr></table></figure>

<p>使用了装饰器，我们并不需要修改原来的代码，只需要在函数的上方加上一个 @time_master，然后函数就能够实现统计运行时间的功能了。</p>
<p>这个 <code>@</code>加上装饰器名字其实是个语法糖，装饰器原本的样子应该这么调用的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">    </span><br><span class="line">def time_master(func):</span><br><span class="line">    def call_func():</span><br><span class="line">        print(&quot;开始运行程序...&quot;)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(&quot;结束程序运行...&quot;)</span><br><span class="line">        print(f&quot;一共耗费了 &#123;(stop-start):.2f&#125; 秒。&quot;)</span><br><span class="line">    return call_func</span><br><span class="line">    </span><br><span class="line">def myfunc():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;I love FishC.&quot;)</span><br><span class="line">    </span><br><span class="line">myfunc = time_master(myfunc)</span><br><span class="line">myfunc()</span><br></pre></td></tr></table></figure>
<p>这个就是装饰器的实现原理啦~</p>
<p>多个装饰器也可以用在同一个函数上：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">def add(func):</span><br><span class="line">    def inner():</span><br><span class="line">        x = func()</span><br><span class="line">        return x + 1</span><br><span class="line">    return inner</span><br><span class="line">    </span><br><span class="line">def cube(func):</span><br><span class="line">    def inner():</span><br><span class="line">        x = func()</span><br><span class="line">        return x * x * x</span><br><span class="line">    return inner</span><br><span class="line">    </span><br><span class="line">def square(func):</span><br><span class="line">    def inner():</span><br><span class="line">        x = func()</span><br><span class="line">        return x * x</span><br><span class="line">    return inner</span><br><span class="line">    </span><br><span class="line">@add</span><br><span class="line">@cube</span><br><span class="line">@square</span><br><span class="line">def test():</span><br><span class="line">    return 2</span><br><span class="line">    </span><br><span class="line">print(test())</span><br></pre></td></tr></table></figure>
<p>程序实现如下：<br><code>65</code></p>
<p>这样的话，就是先计算平方（square 装饰器），再计算立方（cube 装饰器），最后再加 1（add 装饰器）。</p>
<p>如何给装饰器传递参数呢？<br>答案是添加多一层嵌套函数来传递参数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">    </span><br><span class="line">def logger(msg):</span><br><span class="line">    def time_master(func):</span><br><span class="line">        def call_func():</span><br><span class="line">            start = time.time()</span><br><span class="line">            func()</span><br><span class="line">            stop = time.time()</span><br><span class="line">            print(f&quot;[&#123;msg&#125;]一共耗费了 &#123;(stop-start):.2f&#125;&quot;)</span><br><span class="line">        return call_func</span><br><span class="line">    return time_master</span><br><span class="line">    </span><br><span class="line">@logger(msg=&quot;A&quot;)</span><br><span class="line">def funA():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;正在调用funA...&quot;)</span><br><span class="line">    </span><br><span class="line">@logger(msg=&quot;B&quot;)</span><br><span class="line">def funB():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;正在调用funB...&quot;)</span><br><span class="line">    </span><br><span class="line">funA()</span><br><span class="line">funB()</span><br></pre></td></tr></table></figure>
<p>程序实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在调用funA...</span><br><span class="line">[A]一共耗费了 1.01</span><br><span class="line">正在调用funB...</span><br><span class="line">[B]一共耗费了 1.04</span><br></pre></td></tr></table></figure>

<p>我们将语法糖去掉，拆解成原来的样子，你就知道原理了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">    </span><br><span class="line">def logger(msg):</span><br><span class="line">    def time_master(func):</span><br><span class="line">        def call_func():</span><br><span class="line">            start = time.time()</span><br><span class="line">            func()</span><br><span class="line">            stop = time.time()</span><br><span class="line">            print(f&quot;[&#123;msg&#125;]一共耗费了 &#123;(stop-start):.2f&#125;&quot;)</span><br><span class="line">        return call_func</span><br><span class="line">    return time_master</span><br><span class="line">    </span><br><span class="line">def funA():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;正在调用funA...&quot;)</span><br><span class="line">    </span><br><span class="line">def funB():</span><br><span class="line">    time.sleep(1)</span><br><span class="line">    print(&quot;正在调用funB...&quot;)</span><br><span class="line">    </span><br><span class="line">funA = logger(msg=&quot;A&quot;)(funA)</span><br><span class="line">funB = logger(msg=&quot;B&quot;)(funB)</span><br><span class="line">    </span><br><span class="line">funA()</span><br><span class="line">funB()</span><br></pre></td></tr></table></figure>
<p>程序实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">正在调用funA...</span><br><span class="line">[A]一共耗费了 1.02</span><br><span class="line">正在调用funB...</span><br><span class="line">[B]一共耗费了 1.01</span><br></pre></td></tr></table></figure>

<p>这里其实就是给它裹多一层嵌套函数上去，然后通过最外层的这个函数来传递装饰器的参数。<br>这样，logger(msg&#x3D;”A”) 得到的是 timemaster() 函数的引用，然后再调用一次，并传入 funA，也就是这个 logger(msg&#x3D;”A”)(funA)，得到的就是 call_func() 函数的引用，最后将它赋值回 funA()。</p>
<p>咱们对比一下没有参数的描述器，这里其实就是添加了一次调用，然后通过这次调用将参数给传递进去而已。</p>
<h3 id="14-22-1-lambda-表达式"><a href="#14-22-1-lambda-表达式" class="headerlink" title="14.22.1 lambda 表达式"></a>14.22.1 lambda 表达式</h3><p>lambda 表达式，也就是大牛们津津乐道的匿名函数。<br>只要掌握了 lambda 表达式，你也就掌握了一行流代码的核心 —— 仅使用一行代码，就能解决一件看起来相当复杂的事情。<br>它的语法是这样的：</p>
<p><code>lambda arg1, arg2, arg3, ... argN : expression</code></p>
<p>lambda 是个关键字，然后是冒号，冒号左边是传入函数的参数，冒号后边是函数实现表达式以及返回值。<br>我们可以将 lambda 表达式的语法理解为一个极致精简之后的函数，如果使用传统的函数定义方式，应该是这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">def &lt;lambda&gt;(arg1, arg2, arg3, ... argN):</span><br><span class="line">...     return expression</span><br></pre></td></tr></table></figure>

<p>如果要求我们编写一个函数，让它求出传入参数的平方值，以前我们这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def squareX(x):</span><br><span class="line">...     return x * x</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; squareX(3)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>现在我们这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squareY = lambda y : y * y</span><br><span class="line">&gt;&gt;&gt; squareY(3)</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<p>传统定义的函数，函数名就是一个函数的引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squareX</span><br><span class="line">&lt;function squareX at 0x0000015E06668F70&gt;</span><br></pre></td></tr></table></figure>

<p>而 lambda 表达式，整个表达式就是一个函数的引用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; squareY</span><br><span class="line">&lt;function &lt;lambda&gt; at 0x0000015E06749EE0&gt;</span><br></pre></td></tr></table></figure>

<h4 id="14-22-2lambda-表达式的优势"><a href="#14-22-2lambda-表达式的优势" class="headerlink" title="14.22.2lambda 表达式的优势"></a>14.22.2lambda 表达式的优势</h4><p>lambda 是一个表达式，因此它可以用在常规函数不可能存在的地方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; y = [lambda x : x * x, 2, 3]</span><br><span class="line">&gt;&gt;&gt; y[0](y[1])</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; y[0](y[2])</span><br><span class="line">9</span><br></pre></td></tr></table></figure>
<p><strong>注意：这里说的是将整个函数的定义过程都放到列表中哦~</strong></p>
<h4 id="14-22-3-与-map-和-filter-函数搭配使用"><a href="#14-22-3-与-map-和-filter-函数搭配使用" class="headerlink" title="14.22.3 与 map() 和 filter() 函数搭配使用"></a>14.22.3 与 map() 和 filter() 函数搭配使用</h4><p>利用 lambda 表达式与 map() 和 filter() 函数搭配使用，会使代码显得更加 Pythonic：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;  list(mapped = map(lambda x : ord(x) + 10, &quot;FishC&quot;))</span><br><span class="line">[80, 115, 125, 114, 77]</span><br><span class="line">&gt;&gt;&gt; list(filter(lambda x : x % 2, range(10)))</span><br><span class="line">[1, 3, 5, 7, 9]</span><br></pre></td></tr></table></figure>

<h4 id="14-22-4-总结"><a href="#14-22-4-总结" class="headerlink" title="14.22.4 总结"></a>14.22.4 总结</h4><p>lambda 是一个表达式，而非语句，所以它能够出现在 Python 语法不允许 def 语句出现的地方，这是它的最大优势。<br>但由于所有的功能代码都局限在一个表达式中实现，因此，lambda 通常只能实现那些较为简单的需求。<br>当然，Python 肯定是有意这么设计的，让 lambda 去做那些简单的事情，我们就不用花心思去考虑这个函数叫什么，那个函数叫什么……def 语句则负责用于定义功能复杂的函数，去处理那些复杂的工作。</p>
<h3 id="14-23-生成器"><a href="#14-23-生成器" class="headerlink" title="14.23 生成器"></a>14.23 生成器</h3><p>在 Python 中，使用了 yield 语句的函数被称为生成器（generator）。</p>
<p>与普通函数不同的是，生成器是一个返回生成器对象的函数，它只能用于进行迭代操作，更简单的理解是 —— 生成器就是一个特殊的迭代器。在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值, 并在下一次执行 yield 方法时从当前位置继续运行。定义一个生成器，很简单，就是在函数中，使用 yield 表达式代替 return 语句即可。<br>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def counter():</span><br><span class="line">...     i = 0</span><br><span class="line">...     while i &lt;= 5:</span><br><span class="line">...         yield i</span><br><span class="line">...         i += 1</span><br></pre></td></tr></table></figure>

<p>现在我们调用 counter() 函数，得到的不是一个返回值，而是一个生成器对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; counter()</span><br><span class="line">&lt;generator object counter at 0x0000025835D0D5F0&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以把它放到一个 for 语句中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for i in counter():</span><br><span class="line">...     print(i)</span><br><span class="line">... </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<p><strong>注意：生成器不像列表、元组这些可迭代对象，你可以把生成器看作是一个制作机器，它的作用就是每调用一次提供一个数据，并且会记住当时的状态。而列表、元组这些可迭代对象是容器，它们里面存放着早已准备好的数据。</strong></p>
<p>生成器可以看作是一种特殊的迭代器，因为它首先是 “不走回头路”，第二是支持 next() 函数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = counter()</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(c)</span><br><span class="line">5</span><br><span class="line">next(c)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#51&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    next(c)</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>当没有任何元素产出的时候，它就会抛出一个 “<code>StopIteration</code>” 异常。<br>由于生成器每调用一次获取一个结果这样的特性，导致生成器对象是无法使用下标索引这样的随机访问方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = counter()</span><br><span class="line">&gt;&gt;&gt; c[2]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#53&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c[2]</span><br><span class="line">TypeError: &#x27;generator&#x27; object is not subscriptable</span><br></pre></td></tr></table></figure>

<p>使用生成器来求出斐波那契数列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fib():</span><br><span class="line">...     back1, back2 = 0, 1</span><br><span class="line">...     while True:</span><br><span class="line">...         yield back1</span><br><span class="line">...         back1, back2 = back2, back1 + back2</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; f = fib()</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; next(f)</span><br><span class="line">21</span><br></pre></td></tr></table></figure>
<p>只要我们调用 next(f)，就可以继续生成一个新的斐波那契数，由于我们在函数中没有设置结束条件，那么这样我们就得到了一个永恒的斐波那契数列生成器，薪火相传、生生不息。</p>
<h3 id="14-24-生成器表达式"><a href="#14-24-生成器表达式" class="headerlink" title="14.24 生成器表达式"></a>14.24 生成器表达式</h3><p>其实在前面讲解元组的时候，小甲鱼就给大家预告了这一章节的到来。<br>因为列表有推导式，元组则没有，如果非要这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; (i ** 2 for i in range(10))</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at 0x0000019A976CC5F0&gt;</span><br></pre></td></tr></table></figure>
<p>那么我们可以看到，它其实就是得到一个生成器嘛：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t = (i ** 2 for i in range(10))</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">0</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; next(t)</span><br><span class="line">16</span><br><span class="line">&gt;&gt;&gt; for i in t:</span><br><span class="line">...     print(i)</span><br><span class="line">... </span><br><span class="line">25</span><br><span class="line">36</span><br><span class="line">49</span><br><span class="line">64</span><br><span class="line">81</span><br></pre></td></tr></table></figure>
<p>这种利用推导的形式获取生成器的方法，我们称之为生成器表达式。</p>
<h3 id="14-25-递归"><a href="#14-25-递归" class="headerlink" title="14.25 递归"></a>14.25 递归</h3><p>递归就是就是函数调用自身的过程，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funC():</span><br><span class="line">...     print(&quot;AWBDYL&quot;)</span><br><span class="line">...     funC()</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; funC()</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>上面代码会持续输出 “AWBDYL”，直到你把 IDLE 关闭或者使用 Ctrl + c 快捷键强制中断执行。<br>加上一个条件判断语句，让递归在恰当的时候进行回归，那么失控的局面就得到了控制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def funC(i):</span><br><span class="line">...     if i &gt; 0:</span><br><span class="line">...         print(&quot;AWBDYL&quot;)</span><br><span class="line">...         i -= 1</span><br><span class="line">...         funC(i)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; funC(10)</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br><span class="line">AWBDYL</span><br></pre></td></tr></table></figure>
<p>再次强调一下，要让递归正常工作，必须要有一个结束条件，并且每次调用都将向着这个结束条件推进。</p>
<h4 id="14-25-1-使用递归求一个数的阶乘"><a href="#14-25-1-使用递归求一个数的阶乘" class="headerlink" title="14.25.1 使用递归求一个数的阶乘"></a>14.25.1 使用递归求一个数的阶乘</h4><p>一个正整数的阶乘，是指所有小于及等于该数的正整数的积，所以 5 的阶乘是 1×2×3×4×5，结果等于 120。<br>我们先来试试迭代的实现方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def factIter(n):</span><br><span class="line">...     result = n</span><br><span class="line">...     for i in range(1, n):</span><br><span class="line">...         result *= i</span><br><span class="line">...     return result</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; factIter(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; factIter(10)</span><br><span class="line">3628800</span><br></pre></td></tr></table></figure>

<p>那么递归来实现的话，代码则是像下面这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def factRecur(n):</span><br><span class="line">...     if n == 1:</span><br><span class="line">...         return 1</span><br><span class="line">...     else:</span><br><span class="line">...         return n * factRecur(n-1)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; factRecur(5)</span><br><span class="line">120</span><br><span class="line">&gt;&gt;&gt; factRecur(10)</span><br><span class="line">3628800</span><br></pre></td></tr></table></figure>

<h3 id="14-25-2-使用递归求斐波那契数列"><a href="#14-25-2-使用递归求斐波那契数列" class="headerlink" title="14.25.2 使用递归求斐波那契数列"></a>14.25.2 使用递归求斐波那契数列</h3><p>斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。</p>
<p>首几个斐波那契数是：<br>1、 1、 2、 3、 5、 8、 13、 21、 34、 55、 89、 144、 233、 377、 610、 987……<br>我们先来试试迭代的实现方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fibIter(n):</span><br><span class="line">...     a = 1</span><br><span class="line">...     b = 1</span><br><span class="line">...     c = 1</span><br><span class="line">...     while n &gt; 2:</span><br><span class="line">...         c = a + b</span><br><span class="line">...         a = b</span><br><span class="line">...         b = c</span><br><span class="line">...         n -= 1</span><br><span class="line">...     return c</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; fibIter(12)</span><br><span class="line">144</span><br></pre></td></tr></table></figure>

<p>如果使用递归来实现，代码就是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def fibRecur(n):</span><br><span class="line">...     if n == 1 or n == 2:</span><br><span class="line">...         return 1</span><br><span class="line">...     else:</span><br><span class="line">...         return fibRecur(n-1) + fibRecur(n-2)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; fibRecur(12)</span><br><span class="line">144</span><br></pre></td></tr></table></figure>

<h3 id="14-26-1-汉诺塔的故事"><a href="#14-26-1-汉诺塔的故事" class="headerlink" title="14.26.1 汉诺塔的故事"></a>14.26.1 汉诺塔的故事</h3><p>汉诺塔其实是 1883 年的时候，由法国数学家卢卡斯发明的。不过这个游戏呢，与一个古老的印度传说有关：据说在世界中心贝拿勒斯的圣庙里边，有一块黄铜板，上边插着三根宝针。印度教的主神梵天在创造世界的时候，在其中一根针上从下到上地穿好了由大到小的 64 片金片，这就是所谓的汉诺塔原型。然后不论白天还是黑夜，总有一个僧侣按照下面的规则来移动这些金片：“一次只移动一片，不管在哪根针上，小片必须在大片上面。”另外僧侣们预言，当所有的金片都从梵天穿好的那根针上移到另外一根针上时，世界就将在一声霹雳中消灭，而梵塔、 和众生也都将同归于尽。</p>
<h4 id="16-26-2-汉诺塔玩法分解"><a href="#16-26-2-汉诺塔玩法分解" class="headerlink" title="16.26.2 汉诺塔玩法分解"></a>16.26.2 汉诺塔玩法分解</h4><p>对于游戏的玩法，我们可以简单分解为三个步骤：</p>
<ol>
<li>将顶上的 63 个金片从 A 移动到 B</li>
<li>将最底下的第 64 个金片从 A 移动到 C</li>
<li>将 B 上的 63 个金片移动到 C</li>
</ol>
<p>看着跟没说一样……<br>那么先让我们把难度简化为婴儿等级 —— 3 个金片：</p>
<ol>
<li>将顶上的 2 个金片从 A 移动到 B</li>
<li>将最底下的第 3 个金片从 A 移动到 C</li>
<li>将 B 上的 2 个金片移动到 C<br>第 2 个步骤仍然是一步到位，难点就在于第 1 和第 3 个步骤，不过难度经过降级之后，我们可以简单看出：<br>第 1 个步骤只需要借助 C，就可以将两个金片从 A 移到 B，第 3 个步骤只需要借助 A，就可以将 2 个金片从 B 移到 C。<br>于是：</li>
</ol>
<h5 id="1-将顶上的-2-个金片从-A-移动到-B-上，确保大片在小片下方"><a href="#1-将顶上的-2-个金片从-A-移动到-B-上，确保大片在小片下方" class="headerlink" title="1.将顶上的 2 个金片从 A 移动到 B 上，确保大片在小片下方"></a>1.将顶上的 2 个金片从 A 移动到 B 上，确保大片在小片下方</h5><ul>
<li>将顶上的 1 个金片从 A 移到 C 上</li>
<li>将底下的 1 个金片从 A 移到 B 上</li>
<li>将 C 上的 1 个金片移动到 B 上</li>
</ul>
<h5 id="2-将最底下的第-3-个金片从-A-移动到-C-上"><a href="#2-将最底下的第-3-个金片从-A-移动到-C-上" class="headerlink" title="2.将最底下的第 3 个金片从 A 移动到 C 上"></a>2.将最底下的第 3 个金片从 A 移动到 C 上</h5><h5 id="3-将-B-上的-2-个金片移动到-C-上"><a href="#3-将-B-上的-2-个金片移动到-C-上" class="headerlink" title="3.将 B 上的 2 个金片移动到 C 上"></a>3.将 B 上的 2 个金片移动到 C 上</h5><ul>
<li>将顶上的 1 个金片从 B 移到 A 上</li>
<li>将底下的 1 个金片从 B 移到 C 上</li>
<li>将 A 上的 1 个金片移动到 C 上</li>
</ul>
<h4 id="16-26-3-汉诺塔代码实现"><a href="#16-26-3-汉诺塔代码实现" class="headerlink" title="16.26.3 汉诺塔代码实现"></a>16.26.3 汉诺塔代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def hanoi(n, x, y, z):</span><br><span class="line">    if n == 1:</span><br><span class="line">        print(x, &#x27;--&gt;&#x27;, z)  # 如果只有 1 层，直接将金片从 x 移动到 z</span><br><span class="line">    else:</span><br><span class="line">        hanoi(n-1, x, z, y) # 将 x 上的 n-1 个金片移动到 y</span><br><span class="line">        print(x, &#x27;--&gt;&#x27;, z)  # 将最底下的金片从 x 移动到 z</span><br><span class="line">        hanoi(n-1, y, x, z) # 将 y 上的 n-1 个金片移动到 z</span><br><span class="line">    </span><br><span class="line">n = int(input(&#x27;请输入汉诺塔的层数：&#x27;))</span><br><span class="line">hanoi(n, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="16-27-函数文档"><a href="#16-27-函数文档" class="headerlink" title="16.27 函数文档"></a>16.27 函数文档</h3><p>使用<code>help()</code>函数，我们可以快速查看到一个函数的使用文档：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; help(print)</span><br><span class="line">Help on built-in function print in module builtins:</span><br><span class="line">    </span><br><span class="line">print(...)</span><br><span class="line">    print(value, ..., sep=&#x27; &#x27;, end=&#x27;\n&#x27;, file=sys.stdout, flush=False)</span><br><span class="line">    </span><br><span class="line">    Prints the values to a stream, or to sys.stdout by default.</span><br><span class="line">    Optional keyword arguments:</span><br><span class="line">    file:  a file-like object (stream); defaults to the current sys.stdout.</span><br><span class="line">    sep:   string inserted between values, default a space.</span><br><span class="line">    end:   string appended after the last value, default a newline.</span><br><span class="line">    flush: whether to forcibly flush the stream.</span><br></pre></td></tr></table></figure>

<p>创建函数文档非常简单，使用字符串就可以了，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def exchange(dollar, rate=7.28):</span><br><span class="line">...     &quot;&quot;&quot;</span><br><span class="line">...     功能：汇率转换，美元 -&gt; 人民币</span><br><span class="line">...     参数：</span><br><span class="line">...     - dollar 美元数量</span><br><span class="line">...     - rate 汇率，默认值是7.28（2022-08-29）</span><br><span class="line">...     返回值：</span><br><span class="line">...     - 人民币的数量</span><br><span class="line">...     &quot;&quot;&quot;</span><br><span class="line">...     return dollar * rate</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; exchange(20)</span><br><span class="line">145.6</span><br></pre></td></tr></table></figure>
<ul>
<li>注意：函数文档一定是在函数的最顶部。我们可以看到，函数开头的几行字符串并不会被打印出来，但它将作为函数的文档被保存起来。<br>现在通过 help() 函数，就可以查看到 exchange() 的文档了：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; help(exchange)</span><br><span class="line">Help on function exchange in module __main__:</span><br><span class="line"></span><br><span class="line">exchange(dollar, rate=7.28)</span><br><span class="line">    功能：汇率转换，美元 -&gt; 人民币</span><br><span class="line">    参数：</span><br><span class="line">    - dollar 美元数量</span><br><span class="line">    - rate 汇率，默认值是7.28（2022-08-29）</span><br><span class="line">    返回值：</span><br><span class="line">    - 人民币的数量</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; def times(s:str, n:int) -&gt; str:</span><br><span class="line">...     return s * n</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="16-28-类型注释"><a href="#16-28-类型注释" class="headerlink" title="16.28 类型注释"></a>16.28 类型注释</h3><p>有时候，你可能会看到这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def times(s:str, n:int) -&gt; str:</span><br><span class="line">...     return s * n</span><br></pre></td></tr></table></figure>

<p>其实这里面多出来的东东，就是 Python 的类型注释啦~<br>比如上面代码表示该函数的作者，希望调用者传入到 s 参数的是字符串类型，传入到 n 参数的是整数类型，最后还告诉我们函数将会返回一个字符串类型的返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; times(&quot;FishC&quot;, 5)</span><br><span class="line">&#x27;FishCFishCFishCFishCFishC&#x27;</span><br></pre></td></tr></table></figure>

<p>当然，这只不过是函数作者的寄望，如果调用者非要胡来，Python 也是不会出面阻止的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; times(5, 5)</span><br><span class="line">25</span><br></pre></td></tr></table></figure>

<p>因为这只是类型注释，是给人看的，不是给机器看的哈。<br>如果需要使用默认参数，那么类型注释可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def times(s:str = &quot;FishC&quot;, n:int = 5) -&gt; str:</span><br><span class="line">...     return s * n</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; times()</span><br><span class="line">&#x27;FishCFishCFishCFishCFishC&#x27;</span><br></pre></td></tr></table></figure>

<p>如果期望的参数类型是列表，可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def times(s:list, n:int = 5) -&gt; list:</span><br><span class="line">...     return s * n</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; times([1, 2, 3], 3)</span><br><span class="line">[1, 2, 3, 1, 2, 3, 1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>如果还想更进一步，比如期望参数类型是一个整数列表（也就是列表中所有的元素都是整数），那么代码可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def times(s:list[int], n:int = 5) -&gt; list:</span><br><span class="line">...     return s * n</span><br></pre></td></tr></table></figure>

<p>映射类型也可以使用这种方法，比如我们期望字典的键是字符串，值是整数，可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def times(s:dict[str, int], n:int = 5) -&gt; list:</span><br><span class="line">...     return list(s.keys()) * n</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; times(&#123;&#x27;A&#x27;:1, &#x27;B&#x27;:2, &#x27;C&#x27;:3&#125;, 3)</span><br><span class="line">[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></pre></td></tr></table></figure>

<h3 id="16-29-mypy"><a href="#16-29-mypy" class="headerlink" title="16.29 mypy"></a>16.29 mypy</h3><p>Mypy 模块的安装及使用介绍 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-209986-1-1.html">传送门</a></p>
<h3 id="16-30-内省"><a href="#16-30-内省" class="headerlink" title="16.30 内省"></a>16.30 内省</h3><p>内省，其实最先是心理学的基本研究方法之一，又称为自我观察法。它是发生在内部的，我们自己能够意识到的主观现象。<br>Python 通过一些特殊的属性来实现内省，比如我们想知道一个函数的名字，可以使用 __name__：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; times.__name__</span><br><span class="line">&#x27;times&#x27;</span><br></pre></td></tr></table></figure>

<p>使用 <code>___annotations__</code> 查看函数的类型注释：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; times.__annotations__</span><br><span class="line">&#123;&#x27;s&#x27;: dict[str, int], &#x27;n&#x27;: &lt;class &#x27;int&#x27;&gt;, &#x27;return&#x27;: list[str]&#125;</span><br></pre></td></tr></table></figure>

<p>查看函数文档，可以使用 <code>__doc__</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; exchange.__doc__</span><br><span class="line">&#x27;\n\t功能：汇率转换，美元 -&gt; 人民币\n\t参数：\n\t- dollar 美元数量\n\t- rate 汇率，默认值 6.32（2022-03-07）\n\t返回值：\n\t- 人民币数量\n\t&#x27;</span><br></pre></td></tr></table></figure>

<p>阅读不友好，咱们使用 print() 函数给打印一下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(exchange.__doc__)</span><br><span class="line">    </span><br><span class="line">        功能：汇率转换，美元 -&gt; 人民币</span><br><span class="line">        参数：</span><br><span class="line">        - dollar 美元数量</span><br><span class="line">        - rate 汇率，默认值 6.32（2022-03-07）</span><br><span class="line">        返回值：</span><br><span class="line">        - 人民币数量</span><br></pre></td></tr></table></figure>

<h3 id="16-31-1-高阶函数"><a href="#16-31-1-高阶函数" class="headerlink" title="16.31.1 高阶函数"></a>16.31.1 高阶函数</h3><p>在前面的学习中，我们发现，函数是可以被当作变量一样自由使用的，那么当一个函数接收另一个函数作为参数的时候，这种函数就称之为高阶函数。<br>高阶函数几乎就是函数式编程的灵魂所在，所以 Python 专程为此搞了一个模块 —— functools，这里面包含了非常多实用的高阶函数，以及装饰器。</p>
<p><strong>友情提示，这是好东西，一定要收藏</strong> -&gt; functools – <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-209319-1-1.html">高阶函数</a></p>
<h4 id="16-31-2-reduce-函数"><a href="#16-31-2-reduce-函数" class="headerlink" title="16.31.2 reduce() 函数"></a>16.31.2 reduce() 函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; def add(x, y):</span><br><span class="line">...     return x + y</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; functools.reduce(add, [1, 2, 3, 4, 5])</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>它的第一个参数是指定一个函数，这个函数必须接收两个参数，然后第二个参数是一个可迭代对象，reduce() 函数的作用就是将可迭代对象中的元素依次传递到第一个参数指定的函数中，最终返回累积的结果。</p>
<p>其实就相当于这样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; add(add(add(add(1, 2), 3), 4), 5)</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<p>另外，将 reduce() 函数的第一个参数写成 lambda 表达式，代码就更加极客了，比如我们要计算 10 的阶乘，那么可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; functools.reduce(lambda x,y:x*y, range(1, 11))</span><br><span class="line">3628800</span><br></pre></td></tr></table></figure>

<h4 id="16-31-3-偏函数（partial-function）"><a href="#16-31-3-偏函数（partial-function）" class="headerlink" title="16.31.3 偏函数（partial function）"></a>16.31.3 偏函数（partial function）</h4><p>偏函数是对指定函数的二次包装，通常是将现有函数的部分参数预先绑定，从而得到一个新的函数，该函数就称为偏函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; square = functools.partial(pow, exp=2)</span><br><span class="line">&gt;&gt;&gt; square(2)</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; square(3)</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; cube = functools.partial(pow, exp=3)</span><br><span class="line">&gt;&gt;&gt; cube(2)</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; cube(3)</span><br><span class="line">27</span><br></pre></td></tr></table></figure>

<p>偏函数的实现原理大致等价于：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def partial(func, /, *args, **keywords):</span><br><span class="line">    def newfunc(*fargs, **fkeywords):</span><br><span class="line">        newkeywords = &#123;**keywords, **fkeywords&#125;</span><br><span class="line">        return func(*args, *fargs, **newkeywords)</span><br><span class="line">    newfunc.func = func</span><br><span class="line">    newfunc.args = args</span><br><span class="line">    newfunc.keywords = keywords</span><br><span class="line">    return newfunc</span><br></pre></td></tr></table></figure>
<p>其实不难发现，它的实现原理就是闭包！<br>只不过使用偏函数的话更简单了一些，细节实现不用我们去费脑子了，直接拿来就用。</p>
<h4 id="16-31-4-wraps-装饰器"><a href="#16-31-4-wraps-装饰器" class="headerlink" title="16.31.4  @wraps 装饰器"></a>16.31.4  @wraps 装饰器</h4><p>让我们先回到讲解装饰器时候的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">    </span><br><span class="line">def time_master(func):</span><br><span class="line">    def call_func():</span><br><span class="line">        print(&quot;开始运行程序...&quot;)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(&quot;结束程序运行...&quot;)</span><br><span class="line">        print(f&quot;一共耗费了 &#123;(stop-start):.2f&#125; 秒。&quot;)</span><br><span class="line">    return call_func</span><br><span class="line">    </span><br><span class="line">@time_master</span><br><span class="line">def myfunc():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;I love FishC.&quot;)</span><br><span class="line">    </span><br><span class="line">myfunc()</span><br></pre></td></tr></table></figure>

<p>程序实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开始运行程序...</span><br><span class="line">I love FishC.</span><br><span class="line">结束程序运行...</span><br><span class="line">一共耗费了 2.01 秒</span><br></pre></td></tr></table></figure>
<p>这里的代码呢，其实是有一个 “副作用” 的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; myfunc.__name__</span><br><span class="line">&#x27;call_func&#x27;</span><br></pre></td></tr></table></figure>
<p>竟然，myfunc 的名字它不叫 ‘my_func’，而是叫 ‘call_func’……<br>这个其实就是装饰器的一个副作用，虽然通常情况下用起来影响不大，但大佬的眼睛里哪能容得下沙子，对吧？<br>所以发明了这个 @wraps 装饰器来装饰装饰器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import functools</span><br><span class="line">    </span><br><span class="line">def time_master(func):</span><br><span class="line">    @functools.wraps(func)</span><br><span class="line">    def call_func():</span><br><span class="line">        print(&quot;开始运行程序...&quot;)</span><br><span class="line">        start = time.time()</span><br><span class="line">        func()</span><br><span class="line">        stop = time.time()</span><br><span class="line">        print(&quot;结束程序运行...&quot;)</span><br><span class="line">        print(f&quot;一共耗费了 &#123;(stop-start):.2f&#125; 秒。&quot;)</span><br><span class="line">    return call_func</span><br><span class="line">    </span><br><span class="line">@time_master</span><br><span class="line">def myfunc():</span><br><span class="line">    time.sleep(2)</span><br><span class="line">    print(&quot;I love FishC.&quot;)</span><br><span class="line">    </span><br><span class="line">myfunc()</span><br></pre></td></tr></table></figure>

<p>程序实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">开始运行程序...</span><br><span class="line">I love FishC.</span><br><span class="line">结束程序运行...</span><br><span class="line">一共耗费了 2.01 秒</span><br><span class="line">&gt;&gt;&gt; myfunc.__name__</span><br><span class="line">&#x27;myfunc&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="16-35-1-永久储存"><a href="#16-35-1-永久储存" class="headerlink" title="16.35.1 永久储存"></a>16.35.1 永久储存</h3><p>当我们在说 “永久存储” 的时候，是希望将数据保存到硬盘上，而非内存，因为内存在计算机断电后数据将会丢失。</p>
<h4 id="16-35-2-打开文件"><a href="#16-35-2-打开文件" class="headerlink" title="16.35.2 打开文件"></a>16.35.2 打开文件</h4><p>使用 Python 打开一个文件，我们需要用到 open() 函数：<br><code>&gt;&gt;&gt; f = open(&quot;FishC.txt&quot;, &quot;w&quot;)</code><br>第一个参数指定的是文件路径和文件名，这里我们没有添加路径的话，那么默认是将文件创建在 Python 的主文件夹下面，因为执行 IDLE 的程序就放在那里嘛（同样的道理，如果我们在桌面创建一个 test.py 的源文件，然后输入打开文件的代码，那么它就会在桌面创建一个 FishC.txt 的文本文件）。</p>
<p>第二个参数是指定文件的打开模式：<br>:-|:-|<br>字符串|含义<br>‘r’|读取（默认）<br>‘w’|写入（如果文件已存在则先截断清空文件）<br>‘x’|排他性创建文件（如果文件已存在则打开失败）<br>‘a’|追加（如果文件已存在则在末尾追加内容）<br>‘b’|二进制模式<br>‘t’|文本模式（默认）<br>‘+’|更新文件（读取和写入）</p>
<h4 id="16-35-3-文件对象的各种方法大合集"><a href="#16-35-3-文件对象的各种方法大合集" class="headerlink" title="16.35.3 文件对象的各种方法大合集"></a>16.35.3 文件对象的各种方法大合集</h4><p>open() 函数成功调用之后，会返回一个文件对象，那么通过这个文件对象，我们就可以往这个文件里面写入数据啦。<br>文件对象，提供了一系列方法，让你可以对它为所欲为。<br>文件对象的各种方法大合集 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-210581-1-1.html">传送门</a></p>
<p>有两个方法可以将字符串写入到文本对象种，一个是 write()，一个是 writelines()：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.write(&quot;I love Python.&quot;)</span><br><span class="line">14</span><br></pre></td></tr></table></figure>
<p>使用 write() 方法，它有一个返回值，就是总共写入到文件对象中的字符个数。<br>使用 writelines() 方法，则可以将多个字符串同时写入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.writelines([&quot;I love FishC.\n&quot;, &quot;I love my wife.&quot;])</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意：虽然 writelines() 方法支持传入多个字符串，但它不会帮你添加换行符，所以我们要自己添加才行。<code>[/n]</code></strong></p>
<h4 id="16-35-4-关闭文件"><a href="#16-35-4-关闭文件" class="headerlink" title="16.35.4 关闭文件"></a>16.35.4 关闭文件</h4><p>我们使用 close() 方法来关闭文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f.close()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意，文件对象关闭之后，我们就没办法对它进行操作了。如果想要继续操作文件，那么我们必须重新打开它。</strong></p>
<h3 id="16-36-实用高效的速查手册（大家记得收藏哦）"><a href="#16-36-实用高效的速查手册（大家记得收藏哦）" class="headerlink" title="16.36 实用高效的速查手册（大家记得收藏哦）"></a>16.36 实用高效的速查手册（大家记得收藏哦）</h3><p><strong>pathlib 速查手册 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-210695-1-1.html">传送门</a></strong></p>
<p><strong>新旧路径处理模块大比拼（pathlib vs os.path）-&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-211104-1-1.html">传送门</a></strong></p>
<h3 id="16-37-pathlib-Path-实用功能讲解"><a href="#16-37-pathlib-Path-实用功能讲解" class="headerlink" title="16.37 pathlib.Path 实用功能讲解"></a>16.37 pathlib.Path 实用功能讲解</h3><p>使用 Path 里面的 cwd() 方法来获取当前的工作目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Path.cwd()</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39&#x27;)</span><br></pre></td></tr></table></figure>

<p>创建路径对象：<br><code>&gt;&gt;&gt; p = Path(&#39;C:/Users/goodb/AppData/Local/Programs/Python/Python39&#39;)</code></p>
<p>使用斜杠 <code>/</code> 直接进行路径拼接：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; q = p / &quot;FishC.txt&quot;</span><br><span class="line">&gt;&gt;&gt; q</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39/FishC.txt&#x27;)</span><br></pre></td></tr></table></figure>

<p>使用 <code>is_dir()</code> 方法可以判断一个路径是否为一个文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.is_dir()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; q.is_dir()</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>使用 <code>is_file()</code> 方法可以判断一个路径是否为一个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.is_file()</span><br><span class="line">False</span><br><span class="line">&gt;&gt;&gt; q.is_file()</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>通过 <code>exists()</code> 方法测试指定的路径是否真实存在：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.exists()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; q.exists()</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; Path(&quot;C:/404&quot;).exists()</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<p>使用 <code>name</code> 属性去获取路径的最后一个部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.name</span><br><span class="line">&#x27;Python39&#x27;</span><br><span class="line">&gt;&gt;&gt; q.name</span><br><span class="line">&#x27;FishC.txt&#x27;</span><br></pre></td></tr></table></figure>

<p><code>stem</code> 属性用于获取文件名，suffix 属性用于获取文件后缀：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; q.stem</span><br><span class="line">&#x27;FishC&#x27;</span><br><span class="line">&gt;&gt;&gt; q.suffix</span><br><span class="line">&#x27;.txt&#x27;</span><br></pre></td></tr></table></figure>

<p><code>parent</code> 属性用于获取其父级目录：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.parent</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python&#x27;)</span><br><span class="line">&gt;&gt;&gt; q.parent</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39&#x27;)</span><br></pre></td></tr></table></figure>

<p>加个复数，<code>parents</code>，还可以获得其逻辑祖先路径构成的一个不可变序列：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.parents</span><br><span class="line">&lt;WindowsPath.parents&gt;</span><br><span class="line">&gt;&gt;&gt; ps = p.parents</span><br><span class="line">&gt;&gt;&gt; for each in ps:</span><br><span class="line">...     print(each)</span><br><span class="line">...         </span><br><span class="line">C:\Users\goodb\AppData\Local\Programs\Python</span><br><span class="line">C:\Users\goodb\AppData\Local\Programs</span><br><span class="line">C:\Users\goodb\AppData\Local</span><br><span class="line">C:\Users\goodb\AppData</span><br><span class="line">C:\Users\goodb</span><br><span class="line">C:\Users</span><br><span class="line">C:\</span><br></pre></td></tr></table></figure>

<p>还支持索引：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ps[0]</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python&#x27;)</span><br><span class="line">&gt;&gt;&gt; ps[1]</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs&#x27;)</span><br><span class="line">&gt;&gt;&gt; ps[2]</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local&#x27;)</span><br></pre></td></tr></table></figure>

<p><code>parts</code> 属性将路径的各个组件拆分成元组的形式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.parts</span><br><span class="line">(&#x27;C:\\&#x27;, &#x27;Users&#x27;, &#x27;goodb&#x27;, &#x27;AppData&#x27;, &#x27;Local&#x27;, &#x27;Programs&#x27;, &#x27;Python&#x27;, &#x27;Python39&#x27;)</span><br><span class="line">&gt;&gt;&gt; q.parts</span><br><span class="line">(&#x27;C:\\&#x27;, &#x27;Users&#x27;, &#x27;goodb&#x27;, &#x27;AppData&#x27;, &#x27;Local&#x27;, &#x27;Programs&#x27;, &#x27;Python&#x27;, &#x27;Python39&#x27;, &#x27;FishC.txt&#x27;)</span><br></pre></td></tr></table></figure>

<p>最后，还可以查询文件或文件夹的状态信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.stat()</span><br><span class="line">os.stat_result(st_mode=16895, st_ino=281474976983758, st_dev=1289007019, st_nlink=1, st_uid=0, st_gid=0, st_size=4096, st_atime=1648462096, st_mtime=1648205377, st_ctime=1605695407)</span><br><span class="line">&gt;&gt;&gt; q.stat()</span><br><span class="line">os.stat_result(st_mode=33206, st_ino=4503599627467517, st_dev=1289007019, st_nlink=1, st_uid=0, st_gid=0, st_size=0, st_atime=1648206152, st_mtime=1648206152, st_ctime=1648205377)</span><br></pre></td></tr></table></figure>

<p>比如这个 st_size 就是文件或文件夹的尺寸信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.stat().st_size</span><br><span class="line">4096</span><br><span class="line">&gt;&gt;&gt; q.stat().st_size</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>使用 <code>resolve()</code> 方法可以将相对路径转换为绝对路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; Path(&#x27;./doc&#x27;).resolve()</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39/Doc&#x27;)</span><br><span class="line">&gt;&gt;&gt; Path(&#x27;../FishC&#x27;).resolve()</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/FishC&#x27;)</span><br></pre></td></tr></table></figure>

<p>最后还可以通过 iterdir() 获取当前路径下面的所有子文件和子文件夹对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.iterdir()</span><br><span class="line">&lt;generator object Path.iterdir at 0x0000012D57CBE660&gt;</span><br></pre></td></tr></table></figure>

<p>最后还可以通过 iterdir() 获取当前路径下面的所有子文件和子文件夹对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p.iterdir()</span><br><span class="line">&lt;generator object Path.iterdir at 0x0000012D57CBE660&gt;</span><br></pre></td></tr></table></figure>

<p>它生成的是一个迭代器对象，所以可以放到 for 语句中去提取数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; for each in p.iterdir():</span><br><span class="line">...     print(each.name)</span><br><span class="line">... </span><br><span class="line">DLLs</span><br><span class="line">Doc</span><br><span class="line">FishC</span><br><span class="line">FishC.txt</span><br><span class="line">include</span><br><span class="line">Lib</span><br><span class="line">libs</span><br><span class="line">LICENSE.txt</span><br><span class="line">NEWS.txt</span><br><span class="line">python.exe</span><br><span class="line">python3.dll</span><br><span class="line">python39.dll</span><br><span class="line">pythonw.exe</span><br><span class="line">Scripts</span><br><span class="line">tcl</span><br><span class="line">Tools</span><br><span class="line">vcruntime140.dll</span><br><span class="line">vcruntime140_1.dll</span><br></pre></td></tr></table></figure>

<p>如果我们要将当前路径下面的所有文件整理成一个列表，可以这么做（注意，是文件，不包含文件夹，所以我们要加一个条件过滤）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; [x for x in p.iterdir() if x.is_file()]</span><br><span class="line">[WindowsPath(&#x27;FishC.txt&#x27;), WindowsPath(&#x27;LICENSE.txt&#x27;), WindowsPath(&#x27;NEWS.txt&#x27;), WindowsPath(&#x27;python.exe&#x27;), WindowsPath(&#x27;python3.dll&#x27;), WindowsPath(&#x27;python39.dll&#x27;), WindowsPath(&#x27;pythonw.exe&#x27;), WindowsPath(&#x27;vcruntime140.dll&#x27;), WindowsPath(&#x27;vcruntime140_1.dll&#x27;)]</span><br></pre></td></tr></table></figure>
<p>以上是用得比较多的，与路径查询相关的操作。</p>
<p>那么修改路径也是支持的，比如我们可以使用 mkdir() 方法来创建文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = p / &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; n.mkdir()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
<p><strong>注意，如果需要创建的文件夹已经存在，那么它就会报错：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n.mkdir()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#16&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    n.mkdir()</span><br><span class="line">  File &quot;C:\Users\goodb\AppData\Local\Programs\Python\Python39\lib\pathlib.py&quot;, line 1323, in mkdir</span><br><span class="line">    self._accessor.mkdir(self, mode)</span><br><span class="line">FileExistsError: [WinError 183] 当文件已存在时，无法创建该文件。: &#x27;C:\\Users\\goodb\\AppData\\Local\\Programs\\Python\\Python39\\FishC&#x27;</span><br></pre></td></tr></table></figure>
<p>也可以避开这个报错信息，我们设置其 exist_ok 参数的值为 True 即可：<br><code>&gt;&gt;&gt; n.mkdir(exist_ok=True)</code><br>还有一点需要注意的就是，如果路径中有存在多个不存在的父级目录，那么也会出错的，比如这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = p / &quot;FishC/A/B/C&quot;</span><br><span class="line">&gt;&gt;&gt; n.mkdir(exist_ok=True)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#22&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    n.mkdir(exist_ok=True)</span><br><span class="line">  File &quot;C:\Users\goodb\AppData\Local\Programs\Python\Python39\lib\pathlib.py&quot;, line 1323, in mkdir</span><br><span class="line">    self._accessor.mkdir(self, mode)</span><br><span class="line">FileNotFoundError: [WinError 3] 系统找不到指定的路径。: &#x27;C:\\Users\\goodb\\AppData\\Local\\Programs\\Python\\Python39\\FishC\\A\\B\\C&#x27;</span><br></pre></td></tr></table></figure>
<p>它也定义了一个参数用于对付这种情况，将 <code>parents</code> 参数设置为 <code>True</code> 就可以了：<br><code>&gt;&gt;&gt; n.mkdir(parents=True, exist_ok=True)</code></p>
<p><code>Path</code> 内部其实还打包了一个 <code>open()</code> 方法，除了不用传入路径之外，其它参数跟 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-210552-1-1.html">open()</a> 函数是一摸一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = n / &#x27;FishC.txt&#x27;</span><br><span class="line">&gt;&gt;&gt; n</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39/FishC/A/B/C/FishC.txt&#x27;)</span><br><span class="line">&gt;&gt;&gt; f = n.open(&#x27;w&#x27;)</span><br><span class="line">&gt;&gt;&gt; f.write(&quot;I love FishC.&quot;)</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure>

<p>可以给文件或文件夹修改名字，使用 <code>rename()</code> 方法来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n.rename(&quot;NewFishC.txt&quot;)</span><br><span class="line">WindowsPath(&#x27;NewFishC.txt&#x27;)</span><br></pre></td></tr></table></figure>

<p>然后使用 <code>replace()</code> 方法替换文件或文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; m = Path(&quot;NewFishC.txt&quot;)</span><br><span class="line">&gt;&gt;&gt; n</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39/FishC/A/B/C/FishC.txt&#x27;)</span><br><span class="line">&gt;&gt;&gt; m.replace(n)</span><br><span class="line">WindowsPath(&#x27;C:/Users/goodb/AppData/Local/Programs/Python/Python39/FishC/A/B/C/FishC.txt&#x27;)</span><br></pre></td></tr></table></figure>

<p>还有删除操作，<code>rmdir()</code> 和 <code>unlink()</code> 方法，前者用于删除文件夹，后者用于删除文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n.parent.rmdir()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File &quot;&lt;pyshell#6&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">n.parent.rmdir()</span><br><span class="line">File &quot;C:\Users\goodb\AppData\Local\Programs\Python\Python39\lib\pathlib.py&quot;, line 1363, in rmdir</span><br><span class="line">self._accessor.rmdir(self)</span><br><span class="line">OSError: [WinError 145] 目录不是空的。: &#x27;C:\\Users\\goodb\\AppData\\Local\\Programs\\Python\\Python39\\FishC\\A\\B\\C&#x27;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果不是空文件夹，它是删不掉的，我们需要先把里面的文件删了：<br><code>&gt;&gt;&gt; n.unlink()</code><br>现在再删除文件夹，就 OK 啦：<br><code>&gt;&gt;&gt; n.parent.rmdir()</code><br>最后是功能强大的查找，由 <code>glob()</code> 方法来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; p = Path(&#x27;.&#x27;)</span><br><span class="line">&gt;&gt;&gt; list(p.glob(&quot;*.txt&quot;))</span><br><span class="line">[WindowsPath(&#x27;FishC.txt&#x27;), WindowsPath(&#x27;LICENSE.txt&#x27;), WindowsPath(&#x27;NEWS.txt&#x27;)]</span><br></pre></td></tr></table></figure>

<p>这就查找当前目录下的所有 <code>.txt </code>后缀的文件，如果要查找当前目录的下一级目录中的所有 <code>.py</code> 后缀的文件，可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(p.glob(&#x27;*/*.py&#x27;))</span><br><span class="line">[WindowsPath(&#x27;Lib/abc.py&#x27;), WindowsPath(&#x27;Lib/aifc.py&#x27;), WindowsPath(&#x27;Lib/antigravity.py&#x27;), ...]</span><br></pre></td></tr></table></figure>

<p>好了，那么如果希望进行向下递归搜索，也就是查找当前目录以及该目录下面的所有子目录，可以使用两个星号<code>**</code>表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; list(p.glob(&#x27;**/*.py&#x27;))</span><br><span class="line">[WindowsPath(&#x27;Lib/abc.py&#x27;), WindowsPath(&#x27;Lib/aifc.py&#x27;), WindowsPath(&#x27;Lib/antigravity.py&#x27;), ...]</span><br></pre></td></tr></table></figure>

<h3 id="16-37-with-语句和上下文管理器"><a href="#16-37-with-语句和上下文管理器" class="headerlink" title="16.37 with 语句和上下文管理器"></a>16.37 with 语句和上下文管理器</h3><p>上下文管理器为文件操作提供了一种更为优雅的实现方式。<br>我们先来看一下传统的文件操作实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; f = open(&quot;FishC.txt&quot;, &quot;w&quot;)</span><br><span class="line">&gt;&gt;&gt; f.write(&quot;I love FishC.&quot;)</span><br><span class="line">13</span><br><span class="line">&gt;&gt;&gt; f.close()</span><br></pre></td></tr></table></figure>

<p>总结下来无非就是三板斧：打开文件 -&gt; 操作文件 -&gt; 关闭文件<br>那么使用 with 上下文管理器方案，应该如何实现呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; with open(&quot;FishC.txt&quot;, &quot;w&quot;) as f:</span><br><span class="line">...     f.write(&quot;I love FishC.&quot;)</span><br><span class="line">... </span><br><span class="line">13</span><br></pre></td></tr></table></figure>
<p>两者是等效的，通俗来讲，对于文件操作这样的三板斧来说，上文就是打开文件，下文就是关闭文件，这个就是上下文管理器做的事情。<br>使用上下文管理器，最大的优势是能够确保资源的释放（在这里就是文件的正常关闭）。</p>
<h3 id="16-38-pickle"><a href="#16-38-pickle" class="headerlink" title="16.38 pickle"></a>16.38 pickle</h3><p>pickle 模块支持你将 Python 的代码序列化，解决的就是一个永久存储 Python 对象的问题。<br>说白了，就是将咱们的源代码，转变成 0101001 的二进制组合。<br>掌握 pickle，只需要学习两个函数的用法：一个是 dump()，另一个是 load()。<br>使用 dump() 函数将数据写入文件中（文件后缀要求是 .pkl）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">    </span><br><span class="line">x, y, z = 1, 2, 3</span><br><span class="line">s = &quot;FishC&quot;</span><br><span class="line">l = [&quot;小甲鱼&quot;, 520, 3.14]</span><br><span class="line">d = &#123;&quot;one&quot;:1, &quot;two&quot;:2&#125;</span><br><span class="line">    </span><br><span class="line">with open(&quot;data.pkl&quot;, &quot;wb&quot;) as f:</span><br><span class="line">    pickle.dump(x, f)</span><br><span class="line">    pickle.dump(y, f)</span><br><span class="line">    pickle.dump(z, f)</span><br><span class="line">    pickle.dump(s, f)</span><br><span class="line">    pickle.dump(l, f)</span><br><span class="line">    pickle.dump(d, f)</span><br></pre></td></tr></table></figure>

<p>使用 load() 函数读取 pickle 文件中的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pickle</span><br><span class="line">    </span><br><span class="line">with open(&quot;data.pkl&quot;, &quot;rb&quot;) as f:</span><br><span class="line">    x = pickle.load(f)</span><br><span class="line">    y = pickle.load(f)</span><br><span class="line">    z = pickle.load(f)</span><br><span class="line">    s = pickle.load(f)</span><br><span class="line">    l = pickle.load(f)</span><br><span class="line">    d = pickle.load(f)</span><br><span class="line">    </span><br><span class="line">print(x, y, z, s, l, d, sep=&quot;\n&quot;)</span><br></pre></td></tr></table></figure>

<p>如果觉得反复写很多个 dump() 和 load() 太麻烦了，可以将多个对象打包成元组后再进行序列化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">pickle.dump((x, y, z, s, l, d), f)</span><br><span class="line">...</span><br><span class="line">x, y, z, s, l, d = pickle.load(f)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="16-39-异常"><a href="#16-39-异常" class="headerlink" title="16.39 异常"></a>16.39 异常</h3><h4 id="16-39-1-编程时通常会遇到的两类错误"><a href="#16-39-1-编程时通常会遇到的两类错误" class="headerlink" title="16.39.1 编程时通常会遇到的两类错误"></a>16.39.1 编程时通常会遇到的两类错误</h4><p>一类是语法错误，就是不按 Python 规定的语法来写代码，这也是初学者最容易犯的错误，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(“I love FishC.”)</span><br><span class="line">SyntaxError: invalid character &#x27;“&#x27; (U+201C)</span><br></pre></td></tr></table></figure>

<p>另一类错误并非由于语法错误导致的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 1 / 0</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#3&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    1 / 0</span><br><span class="line">ZeroDivisionError: division by zero</span><br></pre></td></tr></table></figure>
<p>这里虽然 Python 的语法没有错，但由于没有过硬的小学数学知识，同样导致了代码无法正确执行，引发了 ZeroDivisionError 这个异常。</p>
<h4 id="16-39-2-异常机制"><a href="#16-39-2-异常机制" class="headerlink" title="16.39.2 异常机制"></a>16.39.2 异常机制</h4><p>Python 通过提供异常机制来识别及响应错误。<br>Python 的异常机制可以分离出程序中的异常处理代码和正常业务代码，使得程序代码更为优雅，并提高了程序的健壮性。</p>
<p>Python 内置异常大合集 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-211613-1-1.html">传送门</a>（Python 的所有内置异常，全部都在这里了，大家遇到看不懂的异常信息，直接打开这个网页，然后 Ctrl+F，输入异常的名称就可以）</p>
<h4 id="16-39-3-处理异常"><a href="#16-39-3-处理异常" class="headerlink" title="16.39.3  处理异常"></a>16.39.3  处理异常</h4><p>利用 <code>try-except</code> 语句来捕获并处理异常语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    检测范围</span><br><span class="line">except [expression [as identifier]]:</span><br><span class="line">    异常处理代码</span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;出错了~&quot;)</span><br><span class="line">... </span><br><span class="line">出错了~</span><br></pre></td></tr></table></figure>

<p>我们可以在 <code>except</code> 后面指定一个异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">... except ZeroDivisionError:</span><br><span class="line">...     print(&quot;除数不能为0。&quot;)</span><br><span class="line">... </span><br><span class="line">除数不能为0。</span><br></pre></td></tr></table></figure>
<p>后面还有一个可选的 as，这样的话可以将异常的原因给提取出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">... except ZeroDivisionError as e:</span><br><span class="line">...     print(e)</span><br><span class="line">... </span><br><span class="line">division by zero</span><br></pre></td></tr></table></figure>
<p>其实就是把冒号后面的那部分异常原因给引用出来。</p>
<p>我们还可以将多个可能出现的异常使用元组的形式给包裹起来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">...     520 + &quot;FishC&quot;</span><br><span class="line">... except (ZeroDivisionError, ValueError, TypeError):</span><br><span class="line">...     pass</span><br><span class="line">... </span><br></pre></td></tr></table></figure>
<p>在这个代码中，但凡检测到 try 语句中包含这三个异常中的任意一个，都会执行 pass 语句，直接忽略跳过。</p>
<p>最后也可以单独处理不同的异常，使用多个 except 语句就可以了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">...     520 + &quot;FishC&quot;</span><br><span class="line">... except ZeroDivisionError:</span><br><span class="line">...     print(&quot;除数不能为0。&quot;)</span><br><span class="line">... except ValueError:</span><br><span class="line">...     print(&quot;值不正确。&quot;)</span><br><span class="line">... except TypeError:</span><br><span class="line">...     print(&quot;类型不正确。&quot;)</span><br><span class="line">... </span><br><span class="line">除数不能为0。</span><br></pre></td></tr></table></figure>

<p><strong>try-except-else</strong></p>
<p><code>try-except</code> 还可以跟 <code>else</code> 进行搭配，它的含义就是当 <code>try</code> 语句没有检测到任何异常的情况下，就执行 <code>else</code> 语句的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;逮到了~&quot;)</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;没逮到~&quot;)</span><br><span class="line">... </span><br><span class="line">逮到了~</span><br></pre></td></tr></table></figure>

<p>如果在 <code>try</code> 语句中检测到异常，那么就执行 except 语句的异常处理内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 1</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;逮到了~&quot;)</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;没逮到~&quot;)</span><br><span class="line">... </span><br><span class="line">1.0</span><br><span class="line">没逮到~</span><br></pre></td></tr></table></figure>

<p><strong>try-except-finally</strong></p>
<p>跟 <code>try-except</code> 语句搭配的还有一个 <code>finally</code>，就是说无论异常发生与否，都必须要执行的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 0</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;逮到了~&quot;)</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;没逮到~&quot;)</span><br><span class="line">... finally:</span><br><span class="line">...     print(&quot;逮没逮到都会咯吱一声~&quot;)</span><br><span class="line">... </span><br><span class="line">逮到了~</span><br><span class="line">逮没逮到都会咯吱一声~</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     1 / 1</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;逮到了~&quot;)</span><br><span class="line">... else:</span><br><span class="line">...     print(&quot;没逮到~&quot;)</span><br><span class="line">... finally:</span><br><span class="line">...     print(&quot;逮没逮到都会咯吱一声~&quot;)</span><br><span class="line">... </span><br><span class="line">1.0</span><br><span class="line">没逮到~</span><br><span class="line">逮没逮到都会咯吱一声~</span><br></pre></td></tr></table></figure>

<p><code>finally</code> 通常是用于执行那些收尾工作，比如关闭文件的操作：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     f = open(&quot;FishC.txt&quot;, &quot;w&quot;)</span><br><span class="line">...     f.write(&quot;I love FishC.&quot;)</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;出错了~&quot;)</span><br><span class="line">... finally:</span><br><span class="line">...     f.close()</span><br></pre></td></tr></table></figure>
<p>这样的话，无论 try 语句中是否存在异常，文件都能够正常被关闭。</p>
<p>现在我们的异常处理语法变成了这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    检测范围</span><br><span class="line">except [expression [as identifier]]:</span><br><span class="line">    异常处理代码</span><br><span class="line">[except [expression [as identifier]]:</span><br><span class="line">    异常处理代码]*</span><br><span class="line">[else:</span><br><span class="line">    没有触发异常时执行的代码]</span><br><span class="line">[finally:</span><br><span class="line">    收尾工作执行的代码]</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    检测范围</span><br><span class="line">finally:</span><br><span class="line">    收尾工作执行的代码</span><br></pre></td></tr></table></figure>

<h4 id="16-39-4-异常的嵌套"><a href="#16-39-4-异常的嵌套" class="headerlink" title="16.39.4 异常的嵌套"></a>16.39.4 异常的嵌套</h4><p>异常也是可以被嵌套的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     try:</span><br><span class="line">...         520 + &quot;FishC&quot;</span><br><span class="line">...     except:</span><br><span class="line">...         print(&quot;内部异常！&quot;)</span><br><span class="line">...     1 / 0</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;外部异常！&quot;)</span><br><span class="line">... finally:</span><br><span class="line">...     print(&quot;收尾工作~&quot;)</span><br><span class="line">... </span><br><span class="line">内部异常！</span><br><span class="line">外部异常！</span><br><span class="line">收尾工作~</span><br></pre></td></tr></table></figure>

<h4 id="16-39-5-raise-语句"><a href="#16-39-5-raise-语句" class="headerlink" title="16.39.5 raise 语句"></a>16.39.5 raise 语句</h4><p>使用 raise 语句，我们可以手动的引发异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise ValueError(&quot;值不正确。&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#23&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    raise ValueError(&quot;值不正确。&quot;)</span><br><span class="line">ValueError: 值不正确。</span><br></pre></td></tr></table></figure>
<p><strong>注意，你不能够 <code>raise</code> 一个并不存在的异常哈：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise FishCError(&quot;小甲鱼说你不行你就不行~&quot;)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#31&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    raise FishCError(&quot;小甲鱼说你不行你就不行~&quot;)</span><br><span class="line">NameError: name &#x27;FishCError&#x27; is not defined</span><br></pre></td></tr></table></figure>

<p>由于这个 <code>FishCError</code> 未定义，所以是小甲鱼不行，不是你不行~</p>
<p>还有一种叫异常链，在 <code>raise</code> 后面加个 <code>from</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; raise ValueError(&quot;这样可不行~&quot;) from ZeroDivisionError</span><br><span class="line">ZeroDivisionError</span><br><span class="line"></span><br><span class="line">The above exception was the direct cause of the following exception:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#37&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    raise ValueError(&quot;这样可不行~&quot;) from ZeroDivisionError</span><br><span class="line">ValueError: 这样可不行~</span><br></pre></td></tr></table></figure>

<h4 id="16-39-6-assert-语句"><a href="#16-39-6-assert-语句" class="headerlink" title="16.39.6 assert 语句"></a>16.39.6 assert 语句</h4><p><code>assert</code> 语句跟 <code>raise</code> 类似，都是主动引发异常，不过 <code>assert</code> 语句只能引发一个叫 <code>AssertionError</code> 的异常。</p>
<p>这个语句的存在意义，通常是用于代码调试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; assert s == &quot;FishC&quot; # 得到期待的结果，通过</span><br><span class="line">&gt;&gt;&gt; assert s != &quot;FishC&quot; # 没有得到期待的结果，引发异常</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#72&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    assert s != &quot;FishC&quot;</span><br><span class="line">AssertionError</span><br></pre></td></tr></table></figure>

<h4 id="16-39-7-利用异常来实现-goto"><a href="#16-39-7-利用异常来实现-goto" class="headerlink" title="16.39.7 利用异常来实现 goto"></a>16.39.7 利用异常来实现 goto</h4><p>有学过 C 语言的同学应该听到过一个叫做 goto 的语句，虽然用的不多，但有时候，有这么一个可以指哪跳哪的功能，可以说是非常方便，比如说要在多个嵌套循环语句里面一把跳出来，就非常方便了……可惜 Python 没有！<br>但是，小甲鱼今天敢把话题撂在这，那就说明小甲鱼有想法了！</p>
<p>没错，通过异常，我们完全可以实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; try:</span><br><span class="line">...     while True:</span><br><span class="line">...         while True:</span><br><span class="line">...             for i in range(10):</span><br><span class="line">...                 if i &gt; 3:</span><br><span class="line">...                     raise</span><br><span class="line">...                 print(i)</span><br><span class="line">...             print(&quot;被跳过~&quot;)</span><br><span class="line">...         print(&quot;被跳过~&quot;)</span><br><span class="line">...     print(&quot;被跳过~&quot;)</span><br><span class="line">... except:</span><br><span class="line">...     print(&quot;到这儿来~&quot;)</span><br><span class="line">... </span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">到这儿来~</span><br></pre></td></tr></table></figure>

<h3 id="16-40-面向对象编程（OOP，Object-Oriented-Programming）"><a href="#16-40-面向对象编程（OOP，Object-Oriented-Programming）" class="headerlink" title="16.40 面向对象编程（OOP，Object-Oriented Programming）"></a>16.40 面向对象编程（OOP，Object-Oriented Programming）</h3><p>所谓的面向对象编程，想要学好它，唯一的捷径就是像造物者一样去思考问题。因为，面向对象最初的灵感就是来源于真实世界：</p>
<p><strong>对象 &#x3D; 属性（对象的静态特征）+ 方法（所能做的事情）</strong></p>
<h4 id="16-40-1-类和对象"><a href="#16-40-1-类和对象" class="headerlink" title="16.40.1 类和对象"></a>16.40.1 类和对象</h4><p>对象诞生之前，需要先创建一个类，再通过类来创造实际的对象。</p>
<p>创建一个类需要用到 class 关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Turtle:</span><br><span class="line">    head = 1</span><br><span class="line">    eyes = 2</span><br><span class="line">    legs = 4</span><br><span class="line">    shell = True</span><br><span class="line">    </span><br><span class="line">    def crawl(self):</span><br><span class="line">        print(&quot;人们总抱怨我动作慢吞吞的，殊不知如不积硅步，无以至千里的道理。&quot;)</span><br><span class="line">    </span><br><span class="line">    def run(self):</span><br><span class="line">        print(&quot;虽然我行动很慢，但如果遇到危险，还是会夺命狂奔的T_T&quot;)</span><br><span class="line">    </span><br><span class="line">    def bite(self):</span><br><span class="line">        print(&quot;人善被人欺，龟善被人骑，我可是会咬人的！&quot;)</span><br><span class="line">    </span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&quot;谁知盘中餐粒粒皆辛苦，吃得好，不如吃得饱~&quot;)</span><br><span class="line">    </span><br><span class="line">    def sleep(self):</span><br><span class="line">        print(&quot;Zzzz...&quot;)</span><br></pre></td></tr></table></figure>

<p>类名的命名方式有一个约定俗成的标准，那就是使用大写字母开头，比如我们这里的 Turtle。<br>其实所谓的属性，就是写在类里面的变量，方法就是写在类里面的函数（实际上会有一点区别，后面我们会有仔细讲解）。<br>使用类名搭配上一对小括号，就像调用函数那样，就可以生成一个基于这个类的对象。</p>
<p>t1 就是一个 Turtle 类的对象，也叫实例对象（instance object），它就拥有了这个类所定义的属性和方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t1 = Turtle()</span><br><span class="line">&gt;&gt;&gt; t1.head</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; t1.legs</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; t1.crawl()</span><br><span class="line">人们总抱怨我动作慢吞吞的，殊不知如不积硅步，无以至千里的道理。</span><br><span class="line">&gt;&gt;&gt; t1.bite()</span><br><span class="line">人善被人欺，龟善被人骑，我可是会咬人的！</span><br><span class="line">&gt;&gt;&gt; t1.sleep()</span><br><span class="line">Zzzz...</span><br><span class="line">&gt;&gt;&gt; t2 = Turtle()</span><br><span class="line">&gt;&gt;&gt; t2.head</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; t2.legs</span><br><span class="line">4</span><br><span class="line">&gt;&gt;&gt; t2.crawl()</span><br><span class="line">人们总抱怨我动作慢吞吞的，殊不知如不积硅步，无以至千里的道理。</span><br><span class="line">&gt;&gt;&gt; t2.bite()</span><br><span class="line">人善被人欺，龟善被人骑，我可是会咬人的！</span><br></pre></td></tr></table></figure>

<p>当对象创建出来之后，我们可以随意修改它的属性值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t2.legs = 3</span><br><span class="line">&gt;&gt;&gt; t2.legs</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; t1.legs</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>我们也可以动态的创建一个属性，这跟在字典中添加一个新的键值对一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; t1.mouth = 1</span><br><span class="line">&gt;&gt;&gt; t1.mouth</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>使用 dir() 函数，可以看到，t1 比 t2 多出了一个 mouth 的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; dir(t1)</span><br><span class="line">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;bite&#x27;, &#x27;crawl&#x27;, &#x27;eat&#x27;, &#x27;eyes&#x27;, &#x27;head&#x27;, &#x27;legs&#x27;, &#x27;mouth&#x27;, &#x27;run&#x27;, &#x27;shell&#x27;, &#x27;sleep&#x27;]</span><br><span class="line">&gt;&gt;&gt; dir(t2)</span><br><span class="line">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;bite&#x27;, &#x27;crawl&#x27;, &#x27;eat&#x27;, &#x27;eyes&#x27;, &#x27;head&#x27;, &#x27;legs&#x27;, &#x27;run&#x27;, &#x27;shell&#x27;, &#x27;sleep&#x27;]</span><br></pre></td></tr></table></figure>

<h4 id="16-40-2-封装"><a href="#16-40-2-封装" class="headerlink" title="16.40.2  封装"></a>16.40.2  封装</h4><p>封装，是面向对象编程的三个基本特征之一，另外两个是继承和多态，我们在后续的课程会给大家讲解。<br>像前面我们定义的 Turtle 类，它就把一个甲鱼的特征属性和行为能力封装到了一起。<br>当然，只要有时间，我们还可以添加更多的细节，使得这个 Turtle 更像一只真正意义上的甲鱼。</p>
<h4 id="16-40-3-self-是什么？"><a href="#16-40-3-self-是什么？" class="headerlink" title="16.40.3 self 是什么？"></a>16.40.3 self 是什么？</h4><p>我们编写一段代码，把 self 给打印出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def get_self(self):</span><br><span class="line">...         print(self)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c.get_self()</span><br><span class="line">&lt;__main__.C object at 0x0000020C981BF0D0&gt;</span><br></pre></td></tr></table></figure>

<p>这是什么？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这就是类 [backcolor=#eee]C[/backcolor] 的实例对象小 [backcolor=#eee]c[/backcolor]：</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&lt;__main__.C object at 0x0000020C981BF0D0&gt;</span><br></pre></td></tr></table></figure>

<p>原来传递给方法的是对象本身，那为什么要这么做呢？<br>我们知道，同一个类可以生成无数多个对象，那么当我们在调用类里面的一个方法的时候，Python 如何知道到底是哪个对象在调用呢？</p>
<p>没错，就是通过这个 self 参数传递的信息。<br>所以，类中的每一个方法，默认的第一个参数都是 self。</p>
<h4 id="16-40-4-继承"><a href="#16-40-4-继承" class="headerlink" title="16.40.4 继承"></a>16.40.4 继承</h4><p>Python 的类是支持继承的：它可以使用现有类的所有功能，并在无需重新编写代码的情况下对这些功能进行扩展。<br>通过继承创建的新类称为 “子类”，被继承的类称为 “父类”、“基类” 或 “超类”。<br>继承语法是将父类写在子类类名后面的小括号中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     x = 520</span><br><span class="line">...</span><br><span class="line">...     def hello(self):</span><br><span class="line">...         print(&quot;你好，我是A~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B(A):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; b = B()</span><br><span class="line">&gt;&gt;&gt; b.x</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; b.hello()</span><br><span class="line">你好，我是A~</span><br></pre></td></tr></table></figure>
<p>基于上面代码的继承关系，类 A 就是父类，类 B 则是子类。</p>
<p>如果在子类 B 里面，存在跟父类 A 一样的属性和方法名，那么子类就会覆盖父类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class B(A):</span><br><span class="line">...     x = 880</span><br><span class="line">...</span><br><span class="line">...     def hello(self):</span><br><span class="line">...         print(&quot;你好，我是B~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; b = B()</span><br><span class="line">&gt;&gt;&gt; b.x</span><br><span class="line">880</span><br><span class="line">&gt;&gt;&gt; b.hello()</span><br><span class="line">你好，我是B~</span><br></pre></td></tr></table></figure>

<h4 id="16-40-5-isinstance-和-issubclass"><a href="#16-40-5-isinstance-和-issubclass" class="headerlink" title="16.40.5 isinstance() 和 issubclass()"></a>16.40.5 isinstance() 和 issubclass()</h4><p><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-212950-1-1.html">isinstance()</a> 函数用于判断一个对象是否属于某个类。<br><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-212963-1-1.html">issubclass()</a> 函数用于判断一个类是否属于某个类的子类。<br>友情提示：</p>
<p>在还没有学习 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-212950-1-1.html">isinstance()</a> 函数之前，我们使用 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-220218-1-1.html">type()</a> 函数判断对象的类型，其实这对 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-220218-1-1.html">type()</a>  函数来说真有点大材小用了（type 其实是 Python 中的神）。<br>对于检测对象类型（也就是检测对象所属的类）这件小事来说，使用 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-212950-1-1.html">isinstance()</a> 函数无疑是更名副其实的！<br>另外，使用 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-212950-1-1.html">isinstance()</a> 函数还会将父类考虑进去：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B(A):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; b = B()</span><br><span class="line">&gt;&gt;&gt; isinstance(b, B)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; isinstance(b, A)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; type(b)</span><br><span class="line">&lt;class &#x27;__main__.B&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h4 id="16-40-6-多重继承"><a href="#16-40-6-多重继承" class="headerlink" title="16.40.6 多重继承"></a>16.40.6 多重继承</h4><p>Python 的类是支持多重继承的，也就是一个子类同时可以继承多个父类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     x = 520</span><br><span class="line">...     def hello(self):</span><br><span class="line">...         print(&quot;你好，我是A~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B:</span><br><span class="line">...     x = 880</span><br><span class="line">...     y = 250</span><br><span class="line">...     def hello(self):</span><br><span class="line">...         print(&quot;你好，我是B~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class C(A, B):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; issubclass(C, A)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; issubclass(C, B)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<p>如果实例化一个类 C 的对象为 c，那么访问 c.x 和调用 c.hello() 得到的结果分别是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c.x</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; c.y</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; c.hello()</span><br><span class="line">你好，我是A~</span><br></pre></td></tr></table></figure>
<p>从例子中可以看出，对于多个父类拥有相同属性和方法的情况，它的访问顺序是按从左到右的。</p>
<h4 id="16-40-7-组合"><a href="#16-40-7-组合" class="headerlink" title="16.40.7 组合"></a>16.40.7 组合</h4><p>类的组合跟继承不同，继承是具有上下从属关系，而组合的多个类则是同级关系，下面代码演示的就是类的组合：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Turtle:</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;不积跬步，无以至千里！&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class Cat:</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;喵喵喵~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class Dog:</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;哟吼，我是一只小狗~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class Garden:</span><br><span class="line">...     t = Turtle()</span><br><span class="line">...     c = Cat()</span><br><span class="line">...     d = Dog()</span><br><span class="line">...     def say(self):</span><br><span class="line">...         self.t.say()</span><br><span class="line">...         self.c.say()</span><br><span class="line">...         self.d.say()</span><br><span class="line">...                </span><br><span class="line">&gt;&gt;&gt; g = Garden()</span><br><span class="line">&gt;&gt;&gt; g.say()</span><br><span class="line">不积跬步，无以至千里！</span><br><span class="line">喵喵喵~</span><br><span class="line">哟吼，我是一只小狗~</span><br></pre></td></tr></table></figure>

<h4 id="16-40-8-绑定"><a href="#16-40-8-绑定" class="headerlink" title="16.40.8 绑定"></a>16.40.8 绑定</h4><p>如16.40.8的、末尾的案例，为什么要加上：<code>self</code>?<br>如果没有加上<code>self</code>,代码就会报错:</p>
<figure class="highlight plaintext"><figcaption><span>class Garden:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...     t = Turtle()</span><br><span class="line">...     c = Cat()</span><br><span class="line">...     d = Dog()</span><br><span class="line">...     def say(self):</span><br><span class="line">...         t.say()</span><br><span class="line">...         c.say()</span><br><span class="line">...         d.say()</span><br><span class="line">...                </span><br><span class="line">&gt;&gt;&gt; g = Garden()</span><br><span class="line">&gt;&gt;&gt; g.say()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#27&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    g.say()</span><br><span class="line">  File &quot;&lt;pyshell#25&gt;&quot;, line 6, in say</span><br><span class="line">    t.say()</span><br><span class="line">NameError: name &#x27;t&#x27; is not defined</span><br></pre></td></tr></table></figure>

<p>想要弄清楚这个问题，我们就需要知道这个 <code>self</code> 到底是用来干嘛的？</p>
<p>在讲解类和对象第一节课的最后，这个 self 其实就是实例对象本身，当时我们求证的代码是这么写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def get_self(self):</span><br><span class="line">...         print(self)</span><br><span class="line">... </span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c.get_self()</span><br><span class="line">&lt;__main__.C object at 0x0000029F9E332850&gt;</span><br><span class="line">&gt;&gt;&gt; c</span><br><span class="line">&lt;__main__.C object at 0x0000029F9E332850&gt;</span><br></pre></td></tr></table></figure>

<p>这里利用实例对象调用方法时，会自动传递 self 参数的原理，我们将 self 参数的值打印出来之后，知道它其实就是实例对象本身。<br>其实呢，这个 self 起到的作用就是俩字 —— 绑定。跟谁绑定？</p>
<p>没错，就是实例对象跟类的方法进行绑定！</p>
<p>因为类的实例对象可以有千千万，但这些实例对象却是共享类里面的方法，所以当我们在调用实例 c.get_self() 的时候，其实际的含义是调用类 C 的 get_self() 方法，并将实例对象作为参数给传递进去，进而实现绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; C.get_self(c)</span><br><span class="line">&lt;__main__.C object at 0x0000029F9E332850&gt;</span><br></pre></td></tr></table></figure>
<p>这个绑定就像是骑共享单车，共享单车就是公共的方法，谁去骑它，那么就需要通过手机扫码绑定（这样它就知道在谁的钱包里扣钱了）。所以，现在大家应该知道绑定的必要性了吧！</p>
<h4 id="16-40-9-只要通过绑定，就可以实现各个对象设置各个对象的属性"><a href="#16-40-9-只要通过绑定，就可以实现各个对象设置各个对象的属性" class="headerlink" title="16.40.9 只要通过绑定，就可以实现各个对象设置各个对象的属性"></a>16.40.9 只要通过绑定，就可以实现各个对象设置各个对象的属性</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     x = 100</span><br><span class="line">...     def set_x(self, v):</span><br><span class="line">...         self.x = v</span><br><span class="line">...                </span><br><span class="line">&gt;&gt;&gt; c1 = C()</span><br><span class="line">&gt;&gt;&gt; c2 = C()</span><br><span class="line">&gt;&gt;&gt; c1.x</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; c2.x</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; c1.set_x(250)</span><br><span class="line">&gt;&gt;&gt; c1.x</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; c2.set_x(520)</span><br><span class="line">&gt;&gt;&gt; c2.x</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; # 注意：如果对象同名属性未设置，会共享使用类的属性。</span><br><span class="line">&gt;&gt;&gt; c3 = C()</span><br><span class="line">&gt;&gt;&gt; c3.x</span><br><span class="line">100</span><br><span class="line">&gt;&gt;&gt; c3.__dict__</span><br><span class="line">&#123;&#125;</span><br><span class="line">&gt;&gt;&gt; c3.set_x(666)</span><br><span class="line">&gt;&gt;&gt; c3.x</span><br><span class="line">666</span><br><span class="line">&gt;&gt;&gt; c3.__dict__</span><br><span class="line">&#123;&#x27;x&#x27;: 666&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-40-10-一个-“旁门左道”-的小技巧"><a href="#16-40-10-一个-“旁门左道”-的小技巧" class="headerlink" title="16.40.10 一个 “旁门左道” 的小技巧"></a>16.40.10 一个 “旁门左道” 的小技巧</h4><p>最小的类，就是只有一个 pass 语句填充的类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     pass</span><br></pre></td></tr></table></figure>
<p>那么这个什么都没有的类，它可以做什么呢？</p>
<p>我们就可以把它当字典来使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c.x = 250</span><br><span class="line">&gt;&gt;&gt; c.y = &quot;小甲鱼&quot;</span><br><span class="line">&gt;&gt;&gt; c.z = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; print(c.x)</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; print(c.y)</span><br><span class="line">小甲鱼</span><br><span class="line">&gt;&gt;&gt; print(c.z)</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>也没啥问题，对吧，因为本来类和对象的属性就是通过字典进行存放的嘛~<br>对比一下，使用字典的话我们得多敲几个字符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d = &#123;&#125;</span><br><span class="line">&gt;&gt;&gt; d[&#x27;x&#x27;] = 250</span><br><span class="line">&gt;&gt;&gt; d[&#x27;y&#x27;] = &quot;小甲鱼&quot;</span><br><span class="line">&gt;&gt;&gt; d[&#x27;z&#x27;] = [1, 2, 3]</span><br><span class="line">&gt;&gt;&gt; print(d[&#x27;x&#x27;])</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; print(d[&#x27;y&#x27;])</span><br><span class="line">小甲鱼</span><br><span class="line">&gt;&gt;&gt; print(d[&#x27;z&#x27;])</span><br><span class="line">[1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>虽然说是有点不按套路出牌，但有时候确实是很好用的。</p>
<h4 id="16-40-11-构造函数（init-self-…-）"><a href="#16-40-11-构造函数（init-self-…-）" class="headerlink" title="16.40.11 构造函数（init(self[, …])）"></a>16.40.11 构造函数（<strong>init</strong>(self[, …])）</h4><p>在类中定义 <code>__init__()</code> 方法，可以实现在实例化对象的时候进行个性化定制：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, x, y):</span><br><span class="line">...         self.x = x</span><br><span class="line">...         self.y = y</span><br><span class="line">...     def add(self):</span><br><span class="line">...         return self.x + self.y</span><br><span class="line">...     def mul(self):</span><br><span class="line">...         return self.x * self.y</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; c = C(2, 3)</span><br><span class="line">&gt;&gt;&gt; c.add()</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; c.mul()</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h4 id="16-40-12-重写"><a href="#16-40-12-重写" class="headerlink" title="16.40.12 重写"></a>16.40.12 重写</h4><p>前面我们在 “继承” 中讲过，如果对于父类的某个属性或方法不满意的话，完全可以重新写一个同名的属性或方法对其进行覆盖。那么这种行为，我们就称之为是子类对父类的重写。<br>这里，我们可以定义一个新的类 —— D，继承自上面的类 C，然后对 add() 和 mul() 方法进行重写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D(C):</span><br><span class="line">...     def __init__(self, x, y, z):</span><br><span class="line">...         C.__init__(self, x, y)</span><br><span class="line">...         self.z = z</span><br><span class="line">...     def add(self):</span><br><span class="line">...         return C.add(self) + self.z</span><br><span class="line">...     def mul(self):</span><br><span class="line">...         return C.mul(self) * self.z</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D(2, 3, 4)</span><br><span class="line">&gt;&gt;&gt; d.add()</span><br><span class="line">9</span><br><span class="line">&gt;&gt;&gt; d.mul()</span><br><span class="line">24</span><br></pre></td></tr></table></figure>

<h4 id="16-40-13-钻石继承"><a href="#16-40-13-钻石继承" class="headerlink" title="16.40.13 钻石继承"></a>16.40.13 钻石继承</h4><p>下面代码中，类 B1 和 类 B2 都是继承自同一个父类 A，而类 C 又同时继承自它们，这种继承模式就被称之为钻石继承，或者菱形继承：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class A:</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         print(&quot;哈喽，我是A~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B1(A):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...        A.__init__(self)</span><br><span class="line">...        print(&quot;哈喽，我是B1~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B2(A):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         A.__init__(self)</span><br><span class="line">...         print(&quot;哈喽，我是B2~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class C(B1, B2):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         B1.__init__(self)</span><br><span class="line">...         B2.__init__(self)</span><br><span class="line">...         print(&quot;哈喽，我是C~&quot;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>钻石继承这种模式，一旦处理不好就容易带来问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">哈喽，我是A~</span><br><span class="line">哈喽，我是B1~</span><br><span class="line">哈喽，我是A~</span><br><span class="line">哈喽，我是B2~</span><br><span class="line">哈喽，我是C~</span><br></pre></td></tr></table></figure>
<p>看，“哈喽，我是A~” 这一句竟然打印了 2 次！<br>也就是说，类 A 的构造函数被调用了 2 次！</p>
<p>怎么解？<br>看下面~</p>
<h4 id="16-40-14-super-函数和-MRO-顺序"><a href="#16-40-14-super-函数和-MRO-顺序" class="headerlink" title="16.40.14 super() 函数和 MRO 顺序"></a>16.40.14 super() 函数和 MRO 顺序</h4><p>上面这种通过类名直接访问的做法，是有一个名字的，叫 “调用未绑定的父类方法”。通常使用其实没有多大问题，但是遇到钻石继承嘛，就容易出事儿了~那么其实 Python 还有一个更好的实现方案，就是使用 super() 函数。super() 函数能够在父类中搜索指定的方法，并自动绑定好 self 参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class B1(A):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...        super().__init__()</span><br><span class="line">...        print(&quot;哈喽，我是B1~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class B2(A):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         super().__init__()</span><br><span class="line">...         print(&quot;哈喽，我是B2~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class C(B1, B2):</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         super().__init__()</span><br><span class="line">...         print(&quot;哈喽，我是C~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">哈喽，我是A~</span><br><span class="line">哈喽，我是B2~</span><br><span class="line">哈喽，我是B1~</span><br><span class="line">哈喽，我是C~</span><br></pre></td></tr></table></figure>
<p>之所以 super() 函数能够有效避免钻石继承带来的问题，是因为它是按照 MRO 顺序去搜索方法，并且自动避免重复调用的问题。</p>
<p>那什么是 MRO 顺序呢？<br>MRO（Method Resolution Order），翻译过来就是 “方法解析顺序”。</p>
<p>想要查找一个类的 MRO 顺序有两种方法~<br>一种是通过调用类的 <code>mro()</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; C.mro()</span><br><span class="line">[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.B1&#x27;&gt;, &lt;class &#x27;__main__.B2&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br><span class="line">&gt;&gt;&gt; B1.mro()</span><br><span class="line">[&lt;class &#x27;__main__.B1&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br></pre></td></tr></table></figure>
<p>另一种则是通过 <code>__mro__</code> 属性：</p>
<p>注：这里大家会看到它们都有一个 <code>&lt;class &#39;object&#39;&gt;</code>，这是因为 object 是所有类的基类，所以就算你不写，它也是会被隐式地继承。</p>
<h4 id="16-40-15-super-也非全知全能！"><a href="#16-40-15-super-也非全知全能！" class="headerlink" title="16.40.15 super() 也非全知全能！"></a>16.40.15 super() 也非全知全能！</h4><p>由于 super() 函数是依赖于 MRO 顺序的，但 MRO 的排序方式，经常会让初学者感到迷惑，从而导致 super() 函数常常不能如大家预期那样去工作…… </p>
<p>这篇扩展阅读 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-213994-1-1.html">传送门</a><br>大家一定要花点时间研究一下，最好是收藏起来，以后在使用 super() 函数时出现问题，随时可以在这里面找到答案。</p>
<h4 id="16-40-16-Mixin"><a href="#16-40-16-Mixin" class="headerlink" title="16.40.16 Mixin"></a>16.40.16 Mixin</h4><p>Mixin 即 Mix-in，翻译过来就是所谓的 “混入” 或者 “乱入”（也有音译为 “迷因”），它是一种设计模式。所谓设计模式，就是利用编程语言已有的特性，针对面向对象开发过程中，反复出现的问题，而设计出来的解决方案。</p>
<p>为了更好地解释什么是 Mixin，我们先来看一段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Animal:</span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    </span><br><span class="line">    def say(self):</span><br><span class="line">        print(f&quot;我叫&#123;self.name&#125;，今年&#123;self.age&#125;岁。&quot;)</span><br><span class="line">    </span><br><span class="line">class Pig(Animal):</span><br><span class="line">    def special(self):</span><br><span class="line">        print(&quot;我的技能是拱大白菜~&quot;)</span><br><span class="line">    </span><br><span class="line">p = Pig(&quot;大肠&quot;, 5)</span><br><span class="line">p.say()</span><br><span class="line">p.special()</span><br></pre></td></tr></table></figure>
<p>代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我叫大肠，今年5岁。</span><br><span class="line">我的技能是拱大白菜~</span><br></pre></td></tr></table></figure>
<p>好，现在由于剧情需要，我们要让大肠起飞……问一下大家，咱们有没有办法在不修改原有类的代码结构的前提下，让大肠，也就是猪，飞起来？<br>其实仔细思考一下并不难，我们可以写一个类，它的功能就是起飞，然后让 Pig 类去继承它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">class FlyMixin:</span><br><span class="line">    def fly(self):</span><br><span class="line">        print(&quot;哦豁，我还会飞~&quot;)</span><br><span class="line">    </span><br><span class="line">class Pig(FlyMixin, Animal):</span><br><span class="line">    def special(self):</span><br><span class="line">        print(&quot;我的技能是拱大白菜~&quot;)</span><br><span class="line">    </span><br><span class="line">p = Pig(&quot;大肠&quot;, 5)</span><br><span class="line">p.say()</span><br><span class="line">p.special()</span><br><span class="line">p.fly()</span><br></pre></td></tr></table></figure>
<p>代码实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我叫大肠，今年5岁。</span><br><span class="line">我的技能是拱大白菜~</span><br><span class="line">哦豁，我还会飞~</span><br></pre></td></tr></table></figure>

<h4 id="16-40-17-多态"><a href="#16-40-17-多态" class="headerlink" title="16.40.17 多态"></a>16.40.17 多态</h4><p>多态在编程中是一个非常重要的概念，它是指同一个运算符、函数或对象在不同的场景下，具有不同的作用效果，这么一个技能。</p>
<p>我们知道加号（+）和乘号（*）运算符在 Python 被广泛使用，但是它们并非只是单一的用途，比如当两边都是数字的时候，它们执行的是算术运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 + 5</span><br><span class="line">8</span><br><span class="line">&gt;&gt;&gt; 3 * 5</span><br><span class="line">15</span><br></pre></td></tr></table></figure>
<p>如果遇到字符串，又会是另外一番面孔：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; &quot;Py&quot; + &quot;FishC&quot;</span><br><span class="line">&#x27;PyFishC&#x27;</span><br><span class="line">&gt;&gt;&gt; &quot;FishC&quot; * 3</span><br><span class="line">&#x27;FishCFishCFishC&#x27;</span><br></pre></td></tr></table></figure>
<p>执行的是拼接和重复~</p>
<p>这种 “见机行事” 的行为，我们就称之为多态。<br>除了运算符之外，Python 中有一些函数也是支持多态的，比如 len() 函数，它的功能是获取一个对象的长度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; len(&quot;FishC&quot;)</span><br><span class="line">5</span><br><span class="line">&gt;&gt;&gt; len([&quot;Python&quot;, &quot;FishC&quot;, &quot;Me&quot;])</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; len(&#123;&quot;name&quot;:&quot;小甲鱼&quot;, &quot;age&quot;:&quot;18&quot;&#125;)</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>你看，给它传递一个字符串，它帮你统计字符的个数；给它传递一个列表，它帮你统计列表中元素的个数；给它传递一个字典，它计算的是字典中键的个数。这就是函数的多态性。</p>
<p>多态的好处这样就一目了然了，尽管我们的接口是不变的，但它却可以根据不同的对象执行不同的操作。</p>
<h4 id="16-40-18-类继承的多态"><a href="#16-40-18-类继承的多态" class="headerlink" title="16.40.18 类继承的多态"></a>16.40.18 类继承的多态</h4><p>Python 允许我们在子类中定义与父类同名的方法。就是如果我们对于父类的某个方法不满意的话，完全是可以在子类中重新定义一个同名的方法进行覆盖，这种做法我们称为重写，这在前面的课程有讲解过了。</p>
<p>重写，其实就是实现类继承的多态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Shape:</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...     def area(self):</span><br><span class="line">...         pass</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; class Square(Shape):</span><br><span class="line">...     def __init__(self, length):</span><br><span class="line">...         super().__init__(&quot;正方形&quot;)</span><br><span class="line">...         self.length = length</span><br><span class="line">...     def area(self):</span><br><span class="line">...         return self.length * self.length</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; class Circle(Shape):</span><br><span class="line">...     def __init__(self, radius):</span><br><span class="line">...         super().__init__(&quot;圆形&quot;)</span><br><span class="line">...         self.radius = radius</span><br><span class="line">...     def area(self):</span><br><span class="line">...         return 3.14 * self.radius * self.radius</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; class Triangle(Shape):</span><br><span class="line">...     def __init__(self, base, height):</span><br><span class="line">...         super().__init__(&quot;三角形&quot;)</span><br><span class="line">...         self.base = base</span><br><span class="line">...         self.height = height</span><br><span class="line">...     def area(self):</span><br><span class="line">...         return self.base * self.height / 2</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s = Square(5)</span><br><span class="line">&gt;&gt;&gt; c = Circle(6)</span><br><span class="line">&gt;&gt;&gt; t = Triangle(3, 4)</span><br><span class="line">&gt;&gt;&gt; s.name</span><br><span class="line">&#x27;正方形&#x27;</span><br><span class="line">&gt;&gt;&gt; c.name</span><br><span class="line">&#x27;圆形&#x27;</span><br><span class="line">&gt;&gt;&gt; t.name</span><br><span class="line">&#x27;三角形&#x27;</span><br><span class="line">&gt;&gt;&gt; s.area()</span><br><span class="line">25</span><br><span class="line">&gt;&gt;&gt; c.area()</span><br><span class="line">113.03999999999999</span><br><span class="line">&gt;&gt;&gt; t.area()</span><br><span class="line">6.0</span><br></pre></td></tr></table></figure>
<p>正方形、圆形、三角形都继承自 <code>Shape</code> 类，但又都重写了构造函数和 area() 方法，这就是多态的体现。</p>
<h4 id="16-40-19-自定义函数的多态"><a href="#16-40-19-自定义函数的多态" class="headerlink" title="16.40.19 自定义函数的多态"></a>16.40.19 自定义函数的多态</h4><p>这个简单，直接看代码你们就懂了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Cat:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.age = age</span><br><span class="line">...     def intro(self):</span><br><span class="line">...         print(f&quot;我是一只沙雕猫咪，我叫&#123;self.name&#125;，今年&#123;self.age&#125;岁~&quot;)</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;mua~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class Dog:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.age = age</span><br><span class="line">...     def intro(self):</span><br><span class="line">...         print(f&quot;我是一只小狗，我叫&#123;self.name&#125;，今年&#123;self.age&#125;岁~&quot;)</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;哟吼~&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class Pig:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.age = age</span><br><span class="line">...     def intro(self):</span><br><span class="line">...         print(f&quot;我是一只小猪，我叫&#123;self.name&#125;，今年&#123;self.age&#125;岁~&quot;)</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;oink~&quot;) # 不要问我猪为什么这么叫，我是跟隔壁幼儿园的小朋友学的，oink~</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = Cat(&quot;web&quot;, 4)</span><br><span class="line">&gt;&gt;&gt; d = Dog(&quot;布布&quot;, 7)</span><br><span class="line">&gt;&gt;&gt; p = Pig(&quot;大肠&quot;, 5)</span><br><span class="line">&gt;&gt;&gt; def animal(x):</span><br><span class="line">...     x.intro()</span><br><span class="line">...     x.say()</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; animal(c)</span><br><span class="line">我是一只沙雕猫咪，我叫宝儿，今年3岁~</span><br><span class="line">mua~</span><br><span class="line">&gt;&gt;&gt; animal(d)</span><br><span class="line">我是一只小狗，我叫布布，今年5岁~</span><br><span class="line">哟吼~</span><br><span class="line">&gt;&gt;&gt; animal(p)</span><br><span class="line">我是一只小猪，我叫大肠，今年5岁~</span><br><span class="line">oink~</span><br></pre></td></tr></table></figure>
<p>看，这个 <code>animal()</code> 函数就具有多态性，该函数接收不同对象作为参数，并在不检查其类型的情况下执行其方法。</p>
<h4 id="16-40-20-鸭子类型"><a href="#16-40-20-鸭子类型" class="headerlink" title="16.40.20 鸭子类型"></a>16.40.20 鸭子类型</h4><p>鸭子类型（Duck Typing）这个概念来源于美国印第安纳州的诗人詹姆斯·惠特科姆·莱利（James Whitcomb Riley, 1849 ~ 1916）的诗句：</p>
<p><strong>“When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”</strong></p>
<p>什么是鸭子类型？<br>举个例子，比如我们定义一个自行车：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class Bicycle:</span><br><span class="line">...     def intro(self):</span><br><span class="line">...         print(&quot;我曾经跨过山和大海，也穿过人山人海~&quot;)</span><br><span class="line">...     def say(self):</span><br><span class="line">...         print(&quot;都有自行车了，要什么兰博基尼？&quot;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>自行车这个类，既有 intro() 方法，也有 say() 方法，所以它即便被前面的 animal() 函数所调用，也不会出错：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; b = Bicycle()</span><br><span class="line">&gt;&gt;&gt; animal(b)</span><br><span class="line">我曾经跨过山和大海，也穿过人山人海~</span><br><span class="line">都有自行车了，要什么兰博基尼？</span><br></pre></td></tr></table></figure>
<p>编程中鸭子类型的概念就是：我们不需要关心对象具体是什么类型，只在乎它的行为方法是否符合要求即可。</p>
<h4 id="16-40-21-私有变量"><a href="#16-40-21-私有变量" class="headerlink" title="16.40.21 私有变量"></a>16.40.21 私有变量</h4><p>在大多数面向对象的编程语言中，都存在着私有变量（private variable）的概念，所谓私有变量，就是指通过某种手段，使得对象中的属性或方法无法被外部所访问。</p>
<p>Python 对于私有变量的实现是引入了一种叫 name mangling 的机制（翻译过来叫 “名字改编”、“名称改写” 或者 “名称修饰”），语法是在变量名前面加上两个连续下划线（__）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, x):</span><br><span class="line">...         self.__x = x</span><br><span class="line">...     def set_x(self, x):</span><br><span class="line">...         self.__x = x</span><br><span class="line">...     def get_x(self):</span><br><span class="line">...         print(self.__x)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C(250)</span><br></pre></td></tr></table></figure>
<p>此时，我们是无法直接通过变量名访问到该变量的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.__x</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#13&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c.__x</span><br><span class="line">AttributeError: &#x27;C&#x27; object has no attribute &#x27;__x&#x27;</span><br></pre></td></tr></table></figure>
<p>想要访问变量的值，就需要使用指定的接口，比如这段代码中的 set_x() 和 get_x() 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.get_x()</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; c.set_x(520)</span><br><span class="line">&gt;&gt;&gt; c.get_x()</span><br><span class="line">520</span><br></pre></td></tr></table></figure>

<h4 id="16-40-22-name-mangling-机制的实现原理"><a href="#16-40-22-name-mangling-机制的实现原理" class="headerlink" title="16.40.22 name mangling 机制的实现原理"></a>16.40.22 name mangling 机制的实现原理</h4><p>我们看看 <code>__dict__</code> 属性里面有啥：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.__dict__</span><br><span class="line">&#123;&#x27;_C__x&#x27;: 250&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这里面没有看到 <code>__x</code>，但是，却多了一个 <code>_C__x</code> 的属性对不对？<br>访问一下试试：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c._C__x</span><br><span class="line">520</span><br></pre></td></tr></table></figure>
<p>果然如此……这个就是传说中的名字改编术！</p>
<p>做法其实也很简单，就是下横线（_）加上类名，再加上变量的名字。<br>方法名也是同样的道理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D:</span><br><span class="line">...     def __func(self):</span><br><span class="line">...         print(&quot;Hello FishC.&quot;)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D()</span><br><span class="line">&gt;&gt;&gt; d.__func()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#12&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d.__func()</span><br><span class="line">AttributeError: &#x27;D&#x27; object has no attribute &#x27;__func&#x27;</span><br><span class="line">&gt;&gt;&gt; d._D__func()</span><br><span class="line">Hello FishC.</span><br></pre></td></tr></table></figure>

<p><strong>注意：name mangling 机制是发生在类实例化对象时候的事情，给对象动态添加属性则不会有同样的效果。</strong></p>
<h4 id="16-40-23-效率提升之道"><a href="#16-40-23-效率提升之道" class="headerlink" title="16.40.23 效率提升之道"></a>16.40.23 效率提升之道</h4><p>Python 对象存储属性的工作原理 —— 字典 <code>__dict__</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, x):</span><br><span class="line">...         self.x = x</span><br><span class="line">...                </span><br><span class="line">&gt;&gt;&gt; c = C(250)</span><br><span class="line">&gt;&gt;&gt; c.x</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; c.__dict__</span><br><span class="line">&#123;&#x27;x&#x27;: 250&#125;</span><br></pre></td></tr></table></figure>

<p>对象动态添加属性，就是将键值对添加到 <code>__dict__</code> 中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.y = 520</span><br><span class="line">&gt;&gt;&gt; c.__dict__</span><br><span class="line">&#123;&#x27;x&#x27;: 250, &#x27;y&#x27;: 520&#125;</span><br></pre></td></tr></table></figure>
<p>甚至你可以直接通过给字典添加键值对的形式来创建对象的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.__dict__[&#x27;z&#x27;] = 666</span><br><span class="line">&gt;&gt;&gt; c.__dict__</span><br><span class="line">&#123;&#x27;x&#x27;: 250, &#x27;y&#x27;: 520, &#x27;z&#x27;: 666&#125;</span><br><span class="line">&gt;&gt;&gt; c.z</span><br><span class="line">666</span><br></pre></td></tr></table></figure>
<p>但是，字典高效率的背后是以付出更多存储空间为代价的（<a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-205214-1-1.html">字典和集合高效背后的玄机</a>）</p>
<p>如果我们明确知道一个类的对象设计出来，就只是需要那么固定的某几个属性，并且不需要有动态添加属性这样的功能，那么利用字典来存放属性，这种空间上的牺牲就是纯纯地浪费！<br>针对这个情况，Python 专门设计了一个 <strong>slots</strong> 类属性，避免了利用字典存放属性造成空间上的浪费。<br>举个例子:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     __slots__ = [&#x27;x&#x27;, &#x27;y&#x27;]</span><br><span class="line">...     def __init__(self, x):</span><br><span class="line">...         self.x = x</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; c = C(250)</span><br></pre></td></tr></table></figure>
<p>这样，我们就创建了一个属性受限制的对象。<br>访问 <code>__slots__</code> 中列举的属性是没问题的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.x</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; c.y = 520</span><br><span class="line">&gt;&gt;&gt; c.y</span><br><span class="line">520</span><br></pre></td></tr></table></figure>
<p>如果想要动态地添加一个属性，那就不好意思了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; c.z = 100</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#27&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c.z = 100</span><br><span class="line">AttributeError: &#x27;C&#x27; object has no attribute &#x27;z&#x27;</span><br></pre></td></tr></table></figure>

<p>这种限制不仅体现在动态添加属性上，如果在类的内部，想创建一个 <code>__slots__</code> 不包含的属性，也是不被允许的：</p>
<figure class="highlight plaintext"><figcaption><span>class D:</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...     __slots__ = [&#x27;x&#x27;, &#x27;y&#x27;]</span><br><span class="line">...     def __init__(self, x, y, z):</span><br><span class="line">...         self.x = x</span><br><span class="line">...         self.y = y</span><br><span class="line">...         self.z = z</span><br><span class="line">&gt;&gt;&gt; d = D(3, 4, 5)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#8&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d = D(3, 4, 5)</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 6, in __init__</span><br><span class="line">    self.z = z</span><br><span class="line">AttributeError: &#x27;D&#x27; object has no attribute &#x27;z&#x27;</span><br></pre></td></tr></table></figure>
<p>甚至是 <code>__dict__</code> 属性，也不存在了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; d.__dict__</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#23&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d.__dict__</span><br><span class="line">AttributeError: &#x27;D&#x27; object has no attribute &#x27;__dict__&#x27;</span><br></pre></td></tr></table></figure>
<p>因为使用了 <code>__slots__</code> 属性，那么对象就会划分一个固定大小的空间来存放指定的属性，这时候 <code>__dict__</code> 属性就不需要了，空间也就节约了出来。</p>
<p>不过这里有一点是需要特别强调的，就是使用 <code>__slots__</code> 属性的副作用其实也相当明显，那就是要以牺牲 Python 动态语言的灵活性，作为前提。使用了 <code>__slots__</code> 属性，就没办法再拥有动态添加属性的功能了……这可以说是它的一个副作用，但实际上很多开发者却利用这个副作用，来限制类属性的滥用。</p>
<p>最后，还有一点需要大家知道的是，继承自父类的 <code>__slots__</code> 属性是不会在子类中生效的，Python 只关注各个具体的类中定义的 <code>__slots__</code> 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class E(C):</span><br><span class="line">...     pass</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; e = E(250)</span><br><span class="line">&gt;&gt;&gt; e.x</span><br><span class="line">250</span><br><span class="line">&gt;&gt;&gt; e.y = 520</span><br><span class="line">&gt;&gt;&gt; e.z = 666</span><br><span class="line">&gt;&gt;&gt; e.__slots__</span><br><span class="line">[&#x27;x&#x27;, &#x27;y&#x27;]</span><br></pre></td></tr></table></figure>
<p>对象 e 虽然拥有 <code>__slots__</code> 属性，但它同时也拥有 <code>__dict__</code> 属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e.__dict__</span><br><span class="line">&#123;&#x27;z&#x27;: 666&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-40-23-魔法方法"><a href="#16-40-23-魔法方法" class="headerlink" title="16.40.23 魔法方法"></a>16.40.23 魔法方法</h4><p>魔法方法就如同它的名字一样，它让 Python 拥有了超凡的魔力。在面向对象开发的过程中，魔法方法总能在你需要的时候出现，并为帮助你轻松地实现你的想法。魔法方法是 Python 内部已经实现的一系列方法的统称，前后双下划线是它们身份的象征（比如 <code>__init__()</code>）。毫不夸张地说，只有掌握了魔法方法，才能算得上是真正地学会了面向对象的 Python 开发。前面我们介绍过 <code>__init__()</code> 魔法方法，它的超能力，就是在类实例化对象的时候自动进行调用，咱们自己写的方法可以做不了这个。</p>
<h5 id="16-40-23-1-new-cls-…"><a href="#16-40-23-1-new-cls-…" class="headerlink" title="16.40.23.1 new(cls[, …])"></a>16.40.23.1 <strong>new</strong>(cls[, …])</h5><p><code>__init__()</code>是对象构建的时候调用的魔法方法，其实参与构建对象还有一个 <code>__new__()</code> 方法，它是在 <code>__init__()</code> 之前被调用的。对象的诞生流程，是先调用 <code>__new__()</code> 方法，创建一个类的实例，然后将其传递给 <code>__init__()</code> 方法进行个性化定制，这么一个流程。需要重写 <code>__new__()</code> 方法的情况极少，通常会用到它不外乎两种情况：</p>
<p>一种情况是在元类中去定制类，元类是 Python 中最难理解的概念之一，是称之为魔法方法背后的魔法方法.<br>另一种情况比较特殊，是在继承不可变数据类型的时候，如果我们想要 “从中作梗”，就可以通过重写 <code>__new__()</code> 魔法方法进行拦截：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class CapStr(str):</span><br><span class="line">...     def __new__(cls, string):</span><br><span class="line">...         string = string.upper()</span><br><span class="line">...         return super().__new__(cls, string)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; cs = CapStr(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; cs</span><br><span class="line">&#x27;FISHC&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="16-40-23-2-del-self"><a href="#16-40-23-2-del-self" class="headerlink" title="16.40.23.2 del(self)"></a>16.40.23.2 <strong>del</strong>(self)</h5><p>相反，<strong>del</strong>() 魔法方法是在对象即将被销毁的时候所自动调用的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self):</span><br><span class="line">...         print(&quot;我来了~&quot;)</span><br><span class="line">...     def __del__(self):</span><br><span class="line">...         print(&quot;我走了~&quot;)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">我来了~</span><br><span class="line">&gt;&gt;&gt; del c</span><br><span class="line">我走了~</span><br></pre></td></tr></table></figure>

<h5 id="16-40-23-3-对象重生之旅"><a href="#16-40-23-3-对象重生之旅" class="headerlink" title="16.40.23.3 对象重生之旅"></a>16.40.23.3 对象重生之旅</h5><p>虽然官方不建议，但他又告诉你可以实现，咱们不妨来尝试一下吧~</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D:</span><br><span class="line">...     def __init__(self, name):</span><br><span class="line">...         self.name = name</span><br><span class="line">...     def __del__(self):</span><br><span class="line">...         global x</span><br><span class="line">...         x = self</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D()</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">&lt;__main__.D object at 0x0000028B34990400&gt;</span><br><span class="line">&gt;&gt;&gt; d.name</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br><span class="line">&gt;&gt;&gt; del d</span><br><span class="line">&gt;&gt;&gt; d</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#12&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d</span><br><span class="line">NameError: name &#x27;d&#x27; is not defined</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line">&lt;__main__.D object at 0x0000028B34990400&gt;</span><br><span class="line">&gt;&gt;&gt; x.name</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br></pre></td></tr></table></figure>
<p>这是一种方法。但是非迫不得已，尽量不要使用全局变量，因为它会污染命名空间。</p>
<p>还有一种方法是通过闭包的形式，将这个对象给保存起来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class E:</span><br><span class="line">...     def __init__(self, name, func):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.func = func</span><br><span class="line">...     def __del__(self):</span><br><span class="line">...         self.func(self)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; def outer():</span><br><span class="line">...     x = 0</span><br><span class="line">...     def inner(y=None):</span><br><span class="line">...         nonlocal x</span><br><span class="line">...         if y:</span><br><span class="line">...             x = y</span><br><span class="line">...         else:</span><br><span class="line">...             return x</span><br><span class="line">...     return inner</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; f = outer()</span><br><span class="line">&gt;&gt;&gt; e = E(&quot;小甲鱼&quot;, f)</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">&lt;__main__.E object at 0x0000024775760790&gt;</span><br><span class="line">&gt;&gt;&gt; e.name</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br><span class="line">&gt;&gt;&gt; del e</span><br><span class="line">&gt;&gt;&gt; e</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#37&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    e</span><br><span class="line">NameError: name &#x27;e&#x27; is not defined</span><br><span class="line">&gt;&gt;&gt; g = f()</span><br><span class="line">&gt;&gt;&gt; g</span><br><span class="line">&lt;__main__.E object at 0x0000024775760790&gt;</span><br><span class="line">&gt;&gt;&gt; g.name</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br></pre></td></tr></table></figure>

<h5 id="16-40-23-4-运算相关的魔法方法"><a href="#16-40-23-4-运算相关的魔法方法" class="headerlink" title="16.40.23.4 运算相关的魔法方法"></a>16.40.23.4 运算相关的魔法方法</h5><p>涉及到的方法数量之庞大，可能会让在座各位都大吃一鲸：<br><img src="/image/%E8%BF%90%E7%AE%97%E7%9B%B8%E5%85%B3%E7%9A%84%E9%AD%94%E6%B3%95%E6%96%B9%E6%B3%95%E5%A4%A7%E5%90%88%E9%9B%86.png" alt="运算相关的魔法方法大合集.png"></p>
<p>一共有 53 个，具体明细可以参考 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-214869-1-1.html">传送门</a><br>用到的时候，拿出来查一下就 OK，写过几次代码也就自然记住了。</p>
<p>涉及到运算相关的操作，Python 也都提供了相应的魔法方法。<br>比如说，我们希望两个字符串相加的结果不是拼接，而是统计两者的字符个数之和，代码可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class S(str):</span><br><span class="line">...     def __add__(self, other):</span><br><span class="line">...         return len(self) + len(other)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; s1 = S(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; s2 = S(&quot;Python&quot;)</span><br><span class="line">&gt;&gt;&gt; s1 + s2</span><br><span class="line">11</span><br></pre></td></tr></table></figure>
<p>只要重写对象的 <code>__add__()</code> 魔法方法，就可以实现对加法运算的拦截。<br>s1 + s2 就相当于 <code>s1.__add__(s2)</code></p>
<h5 id="16-40-23-5-反算术运算相关的魔法方法"><a href="#16-40-23-5-反算术运算相关的魔法方法" class="headerlink" title="16.40.23.5 反算术运算相关的魔法方法"></a>16.40.23.5 反算术运算相关的魔法方法</h5><p>“r” 开头的版本（比如 <code>__radd__()</code>），即 “反算术运算” 的这部分魔法方法，它们其实都是跟上面的算术运算是一一对应的。</p>
<p>那么它们的区别是什么呢？</p>
<p>仍然是拿加法来举例好了，当两个对象相加的时候，如果左侧的对象和右侧的对象不同类型，并且左侧的对象没有定义 <code>__add__()</code> 方法，或者其 <code>__add__()</code> 返回 NotImplemented，那么 Python 就会去右侧的对象中找查找是否有 <code>__radd__()</code> 方法的定义。</p>
<p>举个栗子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class S1(str):</span><br><span class="line">...     def __add__(self, other):</span><br><span class="line">...         return NotImplemented</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; class S2(str):</span><br><span class="line">...     def __radd__(self, other):</span><br><span class="line">...         return len(self) + len(other)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s1 = S1(&quot;Apple&quot;)</span><br><span class="line">&gt;&gt;&gt; s2 = S2(&quot;Banana&quot;)</span><br><span class="line">&gt;&gt;&gt; s1 + s2</span><br><span class="line">12</span><br></pre></td></tr></table></figure>
<p>这里能够成功调用到 <code>__radd__()</code> 方法，首先当然是因为 S2 实现了 <code>__radd__()</code> 方法；其次，s1 和 s2 是两个基于不同类的对象；再有一个条件，就是 S1 必须不能实现 <code>__add__()</code> 方法，不然还是会优先去执行左侧对象的 <code>__add__()</code> 方法（这里我们 <code>__add__()</code> 方法返回 NotImplemented，含义就是明确表示这个方法未实现；如果我们在 S1 中直接不去定义 <code>__add__()</code> 方法，也可以得到相同的结果）。</p>
<h5 id="16-40-23-6-增强赋值运算相关的魔法方法"><a href="#16-40-23-6-增强赋值运算相关的魔法方法" class="headerlink" title="16.40.23.6 增强赋值运算相关的魔法方法"></a>16.40.23.6 增强赋值运算相关的魔法方法</h5><p>“i” 开头的版本（比如 <code>__iadd__()</code>），即 “增强赋值运算” 的这部分魔法方法，它们也是跟上面的算术运算也是对应的，不过呢，这个执行的是运算兼赋值的操作。<br>也就是说 <code>s1 += s2</code>，就相当于 <code>s1 = s1.__iadd(s2)</code>。</p>
<p><strong>注意，它有一个自我赋值的操作，也就是说它会修改对象自身：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class S1(str):</span><br><span class="line">...     def __iadd__(self, other):</span><br><span class="line">...         return len(self) + len(other)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; s1 = S1(&quot;Apple&quot;)</span><br><span class="line">&gt;&gt;&gt; s1 += s2</span><br><span class="line">&gt;&gt;&gt; s1</span><br><span class="line">11</span><br><span class="line">&gt;&gt;&gt; type(s1)</span><br><span class="line">&lt;class &#x27;int&#x27;&gt;</span><br></pre></td></tr></table></figure>

<p>所以，用的时候一定要先想清楚，不然一个不小心，就容易把自己的对象给搞丢咯。</p>
<p>另外，如果增强赋值运算符的左侧对象没有实现相应的魔法方法，比如 +&#x3D; 的左侧对象没有实现  <code>__iadd__()</code> 方法，那么将退而求其次，使用相应的 <code>__add__()</code> 方法和 <code>__radd__()</code> 方法来实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class S2(str):</span><br><span class="line">...     def __radd__(self, other):</span><br><span class="line">...         return len(self) + len(other)</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; s2 = S2(&quot;FishC&quot;)</span><br><span class="line">&gt;&gt;&gt; type(s2)</span><br><span class="line">&lt;class &#x27;__main__.S2&#x27;&gt;</span><br><span class="line">&gt;&gt;&gt; s2 += s2</span><br><span class="line">&gt;&gt;&gt; s2</span><br><span class="line">&#x27;FishCFishC&#x27;</span><br><span class="line">&gt;&gt;&gt; type(s2)</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br></pre></td></tr></table></figure>

<h5 id="16-40-23-7-一些内置函数也有相应的魔法方法"><a href="#16-40-23-7-一些内置函数也有相应的魔法方法" class="headerlink" title="16.40.23.7 一些内置函数也有相应的魔法方法"></a>16.40.23.7 一些内置函数也有相应的魔法方法</h5><p>比如 int() 函数，它相应的魔法方法是 <code>__int__()</code>。那么 int(x) 就相当于调用了 <code>x.__int__()</code>。<br>利用这个特性，我们就可以轻松地实现一个可以将中文转换为整数的对象，来大家请看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class ZH_INT:</span><br><span class="line">    def __init__(self, num):</span><br><span class="line">        self.num = num</span><br><span class="line">    </span><br><span class="line">    def __int__(self):</span><br><span class="line">        try:</span><br><span class="line">            return int(self.num)</span><br><span class="line">        except ValueError:</span><br><span class="line">            zh = &#123;&quot;零&quot;:0, &quot;一&quot;:1, &quot;二&quot;:2, &quot;三&quot;:3, &quot;四&quot;:4, &quot;五&quot;:5, &quot;六&quot;:6, &quot;七&quot;:7, &quot;八&quot;:8, &quot;九&quot;:9,</span><br><span class="line">                  &quot;壹&quot;:1, &quot;贰&quot;:2, &quot;叁&quot;:3, &quot;肆&quot;:4, &quot;伍&quot;:5, &quot;陆&quot;:6, &quot;柒&quot;:7, &quot;捌&quot;:8, &quot;玖&quot;:9, &#125;</span><br><span class="line">            result = 0</span><br><span class="line">            </span><br><span class="line">            for each in self.num:</span><br><span class="line">                if each in zh:</span><br><span class="line">                    result += zh[each]</span><br><span class="line">                else:</span><br><span class="line">                    result += int(each)</span><br><span class="line">                result *= 10</span><br><span class="line">                </span><br><span class="line">            return result // 10</span><br></pre></td></tr></table></figure>
<p>我们通过拦截了 <code>__int__()</code> 魔法方法，让它在原来的基础上添加了对中文数字的识别：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; n = ZH_INT(&quot;五贰零&quot;)</span><br><span class="line">&gt;&gt;&gt; int(n)</span><br><span class="line">520</span><br><span class="line">&gt;&gt;&gt; n = ZH_INT(&quot;五贰零1314&quot;)</span><br><span class="line">&gt;&gt;&gt; int(n)</span><br><span class="line">5201314</span><br></pre></td></tr></table></figure>

<h5 id="16-40-23-8-位运算"><a href="#16-40-23-8-位运算" class="headerlink" title="16.40.23.8 位运算"></a>16.40.23.8 位运算</h5><p>常见的位运算包含按位与（&amp;）、按位或（|）、按位非（^），还有按位异或。<br>前者是对两个整数进行位运算：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bin(2)</span><br><span class="line">&#x27;0b10&#x27;</span><br><span class="line">&gt;&gt;&gt; bin(3)</span><br><span class="line">&#x27;0b11&#x27;</span><br><span class="line">&gt;&gt;&gt; bin(4)</span><br><span class="line">&#x27;0b100&#x27;</span><br><span class="line">&gt;&gt;&gt; 3 &amp; 2</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 3 &amp; 4</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
<p>这里 &amp; 是按位进行 “与” 运算，就是只有当相同的位的值均为 1 的情况下，那么结果才为 1。</p>
<p>按位或也是相同的道理：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 | 2</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; 3 | 4</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<p>按位非则是将每个位进行取反，就是将 1 变成 0，0 变成 1，这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; ~2</span><br><span class="line">-3</span><br><span class="line">&gt;&gt;&gt; ~3</span><br><span class="line">-4</span><br><span class="line">&gt;&gt;&gt; ~4</span><br><span class="line">-5</span><br></pre></td></tr></table></figure>

<h5 id="16-40-23-9-补码"><a href="#16-40-23-9-补码" class="headerlink" title="16.40.23.9 补码"></a>16.40.23.9 补码</h5><p>按位与和按位或运算的结果相信大家都不会感觉到意外，但是按位取反的运算结果，估计会让很多鱼油摸不着头脑……<br>这个其实是涉及到补码的概念：<br><img src="/image/%E8%A1%A5%E7%A0%81.jpg" alt="补码.jpg"><br>感兴趣的童鞋可以看一下这篇扩展阅读 -&gt; <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215498-1-1.html">为什么要使用补码（顺带讲讲二进制的前世今生及转换方法）</a><br>补码其实是在计算机底层对二进制数进行表示、运算和存储使用，对人类并不算太友好，所以这个概念在大多数 Python 教程中，都是不会涉及的，甚至压根儿都不会给你提到，所以感兴趣的童鞋，并且不怕掉头发的童鞋，可以看看，时间有限的童鞋呢，这个扩展阅读可以跳过，也无妨~</p>
<h5 id="16-40-23-10-按位异或"><a href="#16-40-23-10-按位异或" class="headerlink" title="16.40.23.10 按位异或"></a>16.40.23.10 按位异或</h5><p>按位异或，这个比较特殊，就是当两个相同的二进制位的值，不一样的时候，那么结果对应的二进制位的值为 1：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 3 ^ 2</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 3 ^ 4</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h5 id="16-40-23-11-按位移动"><a href="#16-40-23-11-按位移动" class="headerlink" title="16.40.23.11 按位移动"></a>16.40.23.11 按位移动</h5><p>还有一个左移（&lt;&lt;）和右移（&gt;&gt;）运算符，运算符的左侧是运算对象，运算符的右侧是指定移动的位数：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bin(8)</span><br><span class="line">&#x27;0b1000&#x27;</span><br><span class="line">&gt;&gt;&gt; 8 &gt;&gt; 2</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 8 &gt;&gt; 3</span><br><span class="line">1</span><br><span class="line">&gt;&gt;&gt; 8 &lt;&lt; 2</span><br><span class="line">32</span><br><span class="line">&gt;&gt;&gt; 8 &lt;&lt; 3</span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<p>右移 n 位就是除以 2 的 n 次方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 8 // pow(2, 2)</span><br><span class="line">2</span><br><span class="line">&gt;&gt;&gt; 8 // pow(2, 3)</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<p><strong>注意，一定是地板除，因为移位它是会丢失数据的，比如说十进制的数字 9，它的二进制是：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; bin(9)</span><br><span class="line">&#x27;0b1001&#x27;</span><br><span class="line">&gt;&gt;&gt; 9 &gt;&gt; 2</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>相反，左移 n 位就是乘以 2 的 n 次方：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 8 * pow(2, 2)</span><br><span class="line">32</span><br><span class="line">&gt;&gt;&gt; 8 * pow(2, 3)</span><br><span class="line">64</span><br></pre></td></tr></table></figure>
<p>另外，移位计数不能为负数，否则会引发 ValueError 异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 8 &gt;&gt; -2</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#15&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    8 &gt;&gt; -2</span><br><span class="line">ValueError: negative shift count</span><br></pre></td></tr></table></figure>

<h5 id="16-40-23-11-优先级"><a href="#16-40-23-11-优先级" class="headerlink" title="16.40.23.11 优先级"></a>16.40.23.11 优先级</h5><p><img src="/image/%E4%BC%98%E5%85%88%E7%BA%A7.jpg" alt="优先级"><br>在同一个表达式里面，按位或、按位异或、按位与、还有移位，它们的优先级是依次递增的，然后按位非是和正、负号处于同一个优先级行列。</p>
<h5 id="16-40-23-12-math-模块相关的魔法方法"><a href="#16-40-23-12-math-模块相关的魔法方法" class="headerlink" title="16.40.23.12 math 模块相关的魔法方法"></a>16.40.23.12 math 模块相关的魔法方法</h5><p>为了方便大家日后查询，小甲鱼同样将 math 模块翻译了一份中文文档 -&gt; 传送门</p>
<p>math.trunc(x) -&gt; <code>x.__trunc__()</code></p>
<p>math.floor(x) -&gt; <code>x.__floor__()</code></p>
<p>math.ceil(x) -&gt; <code>x.__ceil__()</code></p>
<p>math 模块里面还有一个 ulp() 函数，用于表示对应浮点数的最低有效位，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; import math</span><br><span class="line">&gt;&gt;&gt; 0.1 + 0.2 == 0.3 + math.ulp(0.3)</span><br><span class="line">True</span><br></pre></td></tr></table></figure>

<h5 id="16-40-23-13-特别魔法方法"><a href="#16-40-23-13-特别魔法方法" class="headerlink" title="16.40.23.13 特别魔法方法"></a>16.40.23.13 特别魔法方法</h5><p>就是<code>__index__(self)</code> 方法，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __index__(self):</span><br><span class="line">...         print(&quot;被拦截了~&quot;)</span><br><span class="line">...         return 3</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C()</span><br><span class="line">&gt;&gt;&gt; c[2]</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#5&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c[2]</span><br><span class="line">TypeError: &#x27;C&#x27; object is not subscriptable</span><br></pre></td></tr></table></figure>
<p>其实啊，当对象作为索引值或参数的时候，才会触发 <code>__index__()</code> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; s = &quot;FishC&quot;</span><br><span class="line">&gt;&gt;&gt; s[c]</span><br><span class="line">被拦截了~</span><br><span class="line">&#x27;h&#x27;</span><br><span class="line">&gt;&gt;&gt; bin(c)</span><br><span class="line">被拦截了~</span><br><span class="line">&#x27;0b11&#x27;</span><br></pre></td></tr></table></figure>
<p>这个方法如果不讲，是很容易被误解为由对象的索引访问触发，其实这个方法是让对象做为索引值，被访问才触发，真的是离了个大谱就是……</p>
<h5 id="16-40-23-13-与对象的属性访问相关的-BIF"><a href="#16-40-23-13-与对象的属性访问相关的-BIF" class="headerlink" title="16.40.23.13 与对象的属性访问相关的 BIF"></a>16.40.23.13 与对象的属性访问相关的 BIF</h5><ul>
<li><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215581-1-1.html">hasattr()</a> – 用于判断对象是否拥有某个属性。</li>
<li><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215580-1-1.html">getarrt()</a> – 用于返回对象中指定属性的值。</li>
<li><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215582-1-1.html">setattr()</a> – 用于设置对象中指定属性的值。</li>
<li><a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215583-1-1.html">delattr()</a> – 于删除对象中指定属性的值。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.__age = age</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; c = C(&quot;小甲鱼&quot;, 18)</span><br><span class="line">&gt;&gt;&gt; hasattr(c, &quot;name&quot;)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; getattr(c, &quot;name&quot;)</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br><span class="line">&gt;&gt;&gt; getattr(c, &quot;_C__age&quot;)</span><br><span class="line">18</span><br><span class="line">&gt;&gt;&gt; setattr(c, &quot;_C__age&quot;, 19)</span><br><span class="line">&gt;&gt;&gt; getattr(c, &quot;_C__age&quot;)</span><br><span class="line">19</span><br><span class="line">&gt;&gt;&gt; delattr(c, &quot;_C__age&quot;)</span><br><span class="line">&gt;&gt;&gt; hasattr(c, &quot;_C__age&quot;)</span><br><span class="line">False</span><br></pre></td></tr></table></figure>

<h5 id="16-40-23-14-与对象的属性访问相关的魔法方法"><a href="#16-40-23-14-与对象的属性访问相关的魔法方法" class="headerlink" title="16.40.23.14 与对象的属性访问相关的魔法方法"></a>16.40.23.14 与对象的属性访问相关的魔法方法</h5><p>与 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215580-1-1.html">getarrt()</a> 函数对应的是 <code>__getattribute__()</code> 这个魔法方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.__age = age</span><br><span class="line">...     def __getattribute__(self, attrname):</span><br><span class="line">...         print(&quot;拿来吧你~&quot;)</span><br><span class="line">...         return super().__getattribute__(attrname)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; c = C(&quot;小甲鱼&quot;, 18)</span><br><span class="line">&gt;&gt;&gt; getattr(c, &quot;name&quot;)</span><br><span class="line">拿来吧你~</span><br><span class="line">&gt;&gt;&gt; c._C__age</span><br><span class="line">拿来吧你~</span><br><span class="line">18</span><br><span class="line">&gt;&gt;&gt; c.FishC</span><br><span class="line">拿来吧你~</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#28&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c.y</span><br><span class="line">  File &quot;&lt;pyshell#23&gt;&quot;, line 7, in __getattribute__</span><br><span class="line">    return super().__getattribute__(name)</span><br><span class="line">AttributeError: &#x27;C&#x27; object has no attribute &#x27;FishC&#x27;</span><br></pre></td></tr></table></figure>
<p>大家看，尽管最后这个 “FishC” 是一个不存在的属性，但 <code>__getattribute__()</code> 方法还是会作出响应，然后抛出异常。</p>
<p>那么 <code>__getattr__()</code> 这个魔法方法是干嘛的呢？<br><strong>注意！一定要注意！！这个跟 <a target="_blank" rel="noopener" href="https://fishc.com.cn/thread-215580-1-1.html">getarrt()</a> 函数长得像的，也是跟访问属性有关系，不过它是只有在用户试图获取一个不存在的属性时才会被触发：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class C:</span><br><span class="line">...     def __init__(self, name, age):</span><br><span class="line">...         self.name = name</span><br><span class="line">...         self.__age = age</span><br><span class="line">...     def __getattribute__(self, attrname):</span><br><span class="line">...         print(&quot;拿来吧你~&quot;)</span><br><span class="line">...         return super().__getattribute__(attrname)</span><br><span class="line">...     def __getattr__(self, attrname):</span><br><span class="line">...         if attrname == &quot;FishC&quot;:</span><br><span class="line">...             print(&quot;I love FishC.&quot;)</span><br><span class="line">...         else:</span><br><span class="line">...             raise AttributeError(attrname)</span><br><span class="line">...        </span><br><span class="line">&gt;&gt;&gt; c = C(&quot;小甲鱼&quot;, 18)</span><br><span class="line">&gt;&gt;&gt; c.FishC</span><br><span class="line">拿来吧你~</span><br><span class="line">I love FishC.</span><br><span class="line">&gt;&gt;&gt; c.x</span><br><span class="line">拿来吧你~</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#39&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    c.x</span><br><span class="line">  File &quot;&lt;pyshell#35&gt;&quot;, line 12, in __getattr__</span><br><span class="line">    raise AttributeError(attrname)</span><br><span class="line">AttributeError: x</span><br></pre></td></tr></table></figure>
<p>属性赋值，对应的是 <code>__setattr__()</code> 魔法方法……</p>
<p>很容易，对不对？<br>大家不要掉以轻心，这里面也是有坑的，我举个例子你们就明白了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D:</span><br><span class="line">...     def __setattr__(self, name, value):</span><br><span class="line">...         self.name = value</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D()</span><br><span class="line">&gt;&gt;&gt; d.name = &quot;小甲鱼&quot;</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;pyshell#8&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    d.name = &quot;小甲鱼&quot;</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 3, in __setattr__</span><br><span class="line">    self.name = value</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 3, in __setattr__</span><br><span class="line">    self.name = value</span><br><span class="line">  File &quot;&lt;pyshell#6&gt;&quot;, line 3, in __setattr__</span><br><span class="line">    self.name = value</span><br><span class="line">  [Previous line repeated 1022 more times]</span><br><span class="line">RecursionError: maximum recursion depth exceeded</span><br></pre></td></tr></table></figure>
<p>怎么回事？</p>
<p>怎么报错了？</p>
<p>大家仔细思考一下，self 是什么？</p>
<p>是对象自身，对吧？</p>
<p>那么捕获到赋值操作的时候，我们执行 self.name &#x3D; value，那不就是相当于又给自己调用一次赋值操作，那么又会触发 <strong>setattr</strong>() 的这个魔法方法，然后又再次执行 self.name &#x3D; value 的赋值操作……</p>
<p>这样就导致无限递归了！</p>
<p>遇到这个情况有两种解决方案：</p>
<ol>
<li><p>交给 super()</p>
</li>
<li><p>通过字典来存放对象属性</p>
</li>
</ol>
<p>对象的属性和值本来就是存放在一个叫 &#96;&#96;<strong>dict</strong>&#96; 的字典中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D:</span><br><span class="line">...     def __setattr__(self, name, value):</span><br><span class="line">...         self.__dict__[name] = value</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D()</span><br><span class="line">&gt;&gt;&gt; d.name = &quot;小甲鱼&quot;</span><br><span class="line">&gt;&gt;&gt; d.name</span><br><span class="line">&#x27;小甲鱼&#x27;</span><br></pre></td></tr></table></figure>
<p>这样我们就绕开了死亡螺旋~</p>
<p>同样的道理，使用 <code>__delattr__()</code> 魔法方法的时候，也要注意这个死亡螺旋，我们还是得利用这个字典来实现属性的删除：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; class D:</span><br><span class="line">...     def __setattr__(self, name, value):</span><br><span class="line">...         self.__dict__[name] = value</span><br><span class="line">...     def __delattr__(self, name):</span><br><span class="line">...         del self.__dict__[name]</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt; d = D()</span><br><span class="line">&gt;&gt;&gt; d.name = &quot;小甲鱼&quot;</span><br><span class="line">&gt;&gt;&gt; d.__dict__</span><br><span class="line">&#123;&#x27;name&#x27;: &#x27;小甲鱼&#x27;&#125;</span><br><span class="line">&gt;&gt;&gt; del d.name</span><br><span class="line">&gt;&gt;&gt; d.__dict__</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
</div>
    <div class="footer" id="footer">
    <p><h4>版权所有 © 2020 | 作者: Mortal | 主题 By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        <span id="busuanzi_container_site_pv">本站浏览总访问量: <span id="busuanzi_value_site_pv"></span></span>
        <span class="post-meta-divider">|</span>
        <span id="busuanzi_container_site_uv">本站访问人数: <span id="busuanzi_value_site_uv"></span></span>
    
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>

    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>

<input type="hidden" id="web_style" value="black">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
